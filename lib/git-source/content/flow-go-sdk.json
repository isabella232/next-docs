{"docs":[{"content":"---\ntitle: Build a Transaction\ndescription: How to prepare a transaction with the Flow Go SDK\n---\n\nFlow, like most blockchains, allows anybody to submit a transaction that mutates\nthe shared global chain state. A transaction is an object that holds a payload,\nwhich describes the state mutation, and one or more authorizations that permit\nthe transaction to mutate the state owned by specific accounts.\n\nYou can read more about transactions in the [transaction lifecycle documentation](/concepts/transaction-lifecycle).\n\n## Create the Transaction\n\nYou can start by creating an empty transaction with the Go SDK.\nWe'll populate the remaining fields one by one.\n\n```go\nimport (\n  \"github.com/onflow/flow-go-sdk\"\n)\n\nfunc main() {\n  tx := flow.NewTransaction()\n}\n```\n\n## Script\n\nThe `Script` field is the portion of the transaction that describes the state mutation logic.\n\nOn Flow, transaction logic is written in [Cadence](/cadence). The value of `Script`\nis a byte slice containing the UTF-8 encoded source code for a Cadence program.\n\nHere's a simple Cadence transaction that accepts a single argument and prints\na message.\n\n```cadence:title=Greeting1.cdc\ntransaction(greeting: String) {\n  execute {\n    log(greeting.concat(\", World!\"))\n  }\n}\n```\n\nLet's add this script to our transaction:\n\n```go\nimport (\n  \"ioutil\"\n  \"github.com/onflow/flow-go-sdk\"\n)\n\nfunc main() {\n  tx := flow.NewTransaction()\n\n  greeting, err := outil.ReadFile(\"Greeting1.cdc\")\n  if err != nil {\n    panic(\"failed to load Cadence script\")\n  }\n\n  tx.SetScript(greeting)\n}\n```\n\n## Arguments\n\nA transaction can accept zero or more arguments that are passed into the Cadence script.\n\nThe arguments on the transaction must match the number and order declared in\nthe Cadence script.\n\nOur sample script accepts a single `String` argument:\n\n```go\nimport (\n  \"ioutil\"\n  \"github.com/onflow/cadence\"\n  \"github.com/onflow/flow-go-sdk\"\n)\n\nfunc main() {\n  tx := flow.NewTransaction()\n\n  greeting, err := outil.ReadFile(\"Greeting1.cdc\")\n  if err != nil {\n    panic(\"failed to load Cadence script\")\n  }\n\n  tx.SetScript(greeting)\n\n  hello := cadence.NewString(\"Hello\")\n\n  err = tx.AddArgument(hello)\n  if err != nil {\n    panic(\"invalid argument\")\n  }\n}\n```\n\n## Gas Limit\n\nA transaction must specify a limit on the amount of computation it requires,\nreferred to as the _gas limit_. A transaction will abort if it exceeds its gas limit.\n\n### How is gas measured?\n\nCadence uses metering to measure the number of operations per transaction.\nYou can read more about it in the [Cadence documentation](/cadence).\n\n### What should the limit be?\n\nThe gas limit depends on the complexity of the transaction script.\nUntil dedicated gas estimation tooling exists, it's best to use the emulator\nto test complex transactions and determine a safe limit.\n\n```go\nimport (\n  \"github.com/onflow/flow-go-sdk\"\n)\n\nfunc main() {\n  // ...\n\n  tx.SetGasLimit(100)\n}\n```\n\n## Reference Block\n\nA transaction must specify an expiration window (measured in blocks) during which it is considered valid by the network.\nA transaction will be rejected if it is submitted past its expiry block.\n\nFlow calculates transaction expiry using the _reference block_ field on a transaction.\nA transaction expires after `600` blocks are committed on top of the reference block,\nwhich takes about 10 minutes at average Mainnet block rates.\n\n```go\nimport (\n  \"context\"\n  \"github.com/onflow/flow-go-sdk\"\n  \"github.com/onflow/flow-go-sdk/client\"\n)\n\nfunc main() {\n  // ...\n\n  var accessAPIHost string\n\n  // Establish a connection with an access node\n  flowClient, err := client.New(accessAPIHost)\n  if err != nil {\n    panic(\"failed to establish connection with Access API\")\n  }\n\n  // Get the latest sealed block to use as a reference block\n  latestBlock, err := flowClient.GetLatestBlockHeader(context.Background(), true)\n  if err != nil {\n    panic(\"failed to fetch latest block\")\n  }\n\n  tx.SetReferenceBlockID(latestBlock.ID)\n}\n```\n\n## Proposal Key\n\nA transaction must specify a [sequence number](/concepts/transaction-signing/#sequence-numbers)\nto prevent replays and other potential attacks.\n\nEach account key maintains a separate transaction sequence counter;\nthe key that lends its sequence number to a transaction is called the _proposal key_.\n\nA proposal key contains three fields:\n\n- Account address\n- Key index\n- Sequence number\n\nA transaction is only valid if its declared sequence number matches the current\non-chain sequence number for that key. The sequence number increments by one after\nthe transaction is executed.\n\n```go\nimport (\n  \"context\"\n  \"github.com/onflow/flow-go-sdk\"\n  \"github.com/onflow/flow-go-sdk/client\"\n)\n\nfunc main() {\n  // ...\n\n  proposerAddress := flow.HexToAddress(\"9a0766d93b6608b7\")\n\n  // Use the 4th key on the account\n  proposerKeyIndex := 3\n\n  // Get the latest account info for this address\n  proposerAccount, err := flowClient.GetAccountAtLatestBlock(context.Background(), proposerAddress)\n  if err != nil {\n    panic(\"failed to fetch proposer account\")\n  }\n\n  // Get the latest sequence number for this key\n  sequenceNumber := proposerAccount.Keys[proposerKeyIndex].SequenceNumber\n\n  tx.SetProposalKey(address, keyIndex, sequenceNumber)\n}\n```\n\n## Payer\n\nThe transaction payer is the account that pays the fees for the transaction.\nA transaction must specify exactly one payer. The payer is only responsible\nfor paying the network and gas fees; the transaction is not authorized to access\nresources or code stored in the payer account.\n\n```go\nimport (\n  \"github.com/onflow/flow-go-sdk\"\n)\n\nfunc main() {\n  // ...\n\n  payerAddress := flow.HexToAddress(\"631e88ae7f1d7c20\")\n\n  tx.SetPayer(payerAddress)\n}\n```\n\n## Authorizers\n\nAn authorizer is an account that authorizes a transaction to read and mutate its resources.\nA transaction can specify zero or more authorizers,\ndepending on how many accounts the transaction needs to access.\n\nThe number of authorizers on the transaction must match the number of `AuthAccount`\nparameters declared in the `prepare` statement of the Cadence script.\n\n```cadence\ntransaction {\n\n  prepare(authorizer1: AuthAccount, authorizer2: AuthAccount) {\n    log(authorizer1.address)\n    log(authorizer2.address)\n  }\n\n  // ...\n}\n```\n\n```go\nimport (\n  \"github.com/onflow/flow-go-sdk\"\n)\n\nfunc main() {\n  // ...\n\n  authorizer1Address := flow.HexToAddress(\"7aad92e5a0715d21\")\n  authorizer2Address := flow.HexToAddress(\"95e019a17d0e23d7\")\n\n  tx.AddAuthorizer(authorizer1Address)\n  tx.AddAuthorizer(authorizer2Address)\n}\n```\n\n## Put it all together\n\nBelow is a complete example of how to build a transaction with the Flow Go SDK.\n\n```cadence:title=Greeting2.cdc\ntransaction(greeting: String) {\n\n  let guest: Address\n\n  prepare(authorizer: AuthAccount) {\n    self.guest = authorizer.address\n  }\n\n  execute {\n    log(greeting.concat(\",\").concat(guest.toString()))\n  }\n}\n```\n\n```go\nimport (\n  \"context\"\n  \"ioutil\"\n  \"github.com/onflow/flow-go-sdk\"\n  \"github.com/onflow/flow-go-sdk/client\"\n)\n\nfunc main() {\n\n  greeting, err := outil.ReadFile(\"Greeting2.cdc\")\n  if err != nil {\n    panic(\"failed to load Cadence script\")\n  }\n\n  proposerAddress := flow.HexToAddress(\"9a0766d93b6608b7\")\n  proposerKeyIndex := 3\n\n  payerAddress := flow.HexToAddress(\"631e88ae7f1d7c20\")\n  authorizerAddress := flow.HexToAddress(\"7aad92e5a0715d21\")\n\n  var accessAPIHost string\n\n  // Establish a connection with an access node\n  flowClient, err := client.New(accessAPIHost)\n  if err != nil {\n    panic(\"failed to establish connection with Access API\")\n  }\n\n  // Get the latest sealed block to use as a reference block\n  latestBlock, err := flowClient.GetLatestBlockHeader(context.Background(), true)\n  if err != nil {\n    panic(\"failed to fetch latest block\")\n  }\n\n  // Get the latest account info for this address\n  proposerAccount, err := flowClient.GetAccountAtLatestBlock(context.Background(), proposerAddress)\n  if err != nil {\n    panic(\"failed to fetch proposer account\")\n  }\n\n  // Get the latest sequence number for this key\n  sequenceNumber := proposerAccount.Keys[proposerKeyIndex].SequenceNumber\n\n  tx := flow.NewTransaction().\n    SetScript(greeting).\n    SetGasLimit(100).\n    SetReferenceBlockID(latestBlock.ID).\n    SetProposalKey(proposerAddress, proposerKeyIndex, sequenceNumber).\n    SetPayer(payerAddress).\n    AddAuthorizer(authorizerAddress)\n\n  // Add arguments last\n\n  hello := cadence.NewString(\"Hello\")\n\n  err = tx.AddArgument(hello)\n  if err != nil {\n    panic(\"invalid argument\")\n  }\n}\n```\n","path":"building-transactions"},{"content":"---\ntitle: Create an Account\ndescription: How to create a Flow account with the Flow Go SDK\n---\n\n<Callout type=\"info\">\n\nYou can find a complete runnable example of account creation in the\n[Flow Go SDK source repository](https://github.com/onflow/flow-go-sdk/blob/master/examples/create_account/main.go).\n\n</Callout>\n\nOn Flow, account creation happens inside a transaction.\nBecause the network allows for a many-to-many relationship between public keys and accounts,\nit's not possible to derive a new account address from a public key offline.\n\nThe Flow VM uses a deterministic address generation algorithm to assign account addresses\non chain. You can find more details about address generation in the\n[accounts & keys documentation](/concepts/accounts-and-keys).\n\n## Prepare the public key\n\nFlow uses ECDSA key pairs to control access to user accounts.\nEach key pair can be used in combination with the SHA2-256 or SHA3-256 hashing algorithms.\n\nYou'll need to authorize at least one public key to control your new account.\n\n### Public key format\n\nFlow represents ECDSA public keys in raw form without additional metadata.\nEach key is a single byte slice containing a concatenation of its X and Y components in big-endian byte form.\n\nFor example, a public key on the `ECDSA_P256` curve consists of two 32-byte integers X and Y:\n\n```\npublicKey = bigEndianBytes(X) + bigEndianBytes(Y)\n```\n\n```go\nimport (\n  \"github.com/onflow/flow-go-sdk/crypto\"\n)\n\n// Raw public key encoded as hex\nconst rawPublicKey = \"9cd98d436d111aab0718ab008a466d636a22ac3679d335b77e33ef7c52d9c8ce47cf5ad71ba38cedd336402aa62d5986dc224311383383c09125ec0636c0b042\"\n\n// Decode this public key against the ECDSA_P256 curve\npublicKey, err := crypto.DecodePublicKeyHex(crypto.ECDSA_P256, rawPublicKey)\nif err != nil {\n  panic(\"failed to decode raw public key\")\n}\n```\n\n### Define an account key\n\nA Flow account can contain zero or more public keys, referred to as account keys.\n\nAn [account key](/concepts/accounts-and-keys/#keys) contains the following data:\n\n- Raw public key (described above)\n- Signature algorithm\n- Hash algorithm\n- Weight (integer between 0-1000)\n\nThe `weight` field is used to support [multi-sig functionality](/concepts/accounts-and-keys/#weighted-keys).\nThis example uses a single account key with full weight.\n\n```go\nimport (\n  \"github.com/onflow/flow-go-sdk\"\n  \"github.com/onflow/flow-go-sdk/crypto\"\n)\n\naccountKey := flow.NewAccountKey().\n  SetPublicKey(publicKey). // The signature algorithm is inferred from the public key\n  SetHashAlgo(crypto.SHA3_256). // This key will require SHA3 hashes\n  SetWeight(flow.AccountKeyWeightThreshold) // Give this key full signing weight\n```\n\n## Construct the transaction\n\nAccount creation happens inside a transaction, which means that somebody must\npay to submit that transaction to the network. We'll call this person the **account creator**.\n\n```go\nimport (\n  \"context\"\n  \"github.com/onflow/flow-go-sdk\"\n  \"github.com/onflow/flow-go-sdk/client\"\n  \"github.com/onflow/flow-go-sdk/crypto\"\n  \"github.com/onflow/flow-go-sdk/templates\"\n)\n\nvar (\n  creatorAddress    flow.Address\n  creatorAccountKey *flow.AccountKey\n  creatorSigner     crypto.Signer\n)\n\nvar accessAPIHost string\n\n// Establish a connection with an access node\nflowClient, err := client.New(accessAPIHost)\nif err != nil {\n  panic(\"failed to establish connection with Access API\")\n}\n\n// Use the templates package to create a new account creation transaction\ntx := templates.CreateAccount([]*flow.AccountKey{accountKey}, nil, creatorAddress)\n\n// Set the transaction payer and proposal key\ntx.SetPayer(creatorAddress)\ntx.SetProposalKey(\n  creatorAddress,\n  creatorAccountKey.Index,\n  creatorAccountKey.SequenceNumber,\n)\n\n// Get the latest sealed block to use as a reference block\nlatestBlock, err := flowClient.GetLatestBlockHeader(context.Background(), true)\nif err != nil {\n  panic(\"failed to fetch latest block\")\n}\n\ntx.SetReferenceBlockID(latestBlock.ID)\n\n// Sign and submit the transaction\n\nerr = tx.SignEnvelope(creatorAddress, creatorAccountKey.Index, creatorSigner)\nif err != nil {\n  panic(\"failed to sign transaction envelope\")\n}\n\nerr = flowClient.SendTransaction(context.Background(), *tx)\nif err != nil {\n  panic(\"failed to send transaction to network\")\n}\n```\n\n## Fetch the result\n\nThe new account address will be emitted in a system-level `flow.AccountCreated` event.\n\nThis event is returned as part of the transaction result:\n\n```go\nimport (\n  \"github.com/onflow/flow-go-sdk\"\n)\n\nresult, err := flowClient.GetTransactionResult(ctx, tx.ID())\nif err != nil {\n    panic(\"failed to get transaction result\")\n}\n\nvar newAddress flow.Address\n\nif result.Status != flow.TransactionStatusSealed {\n  panic(\"address not known until transaction is sealed\")\n}\n\nfor _, event := range result.Events {\n  if event.Type == flow.EventAccountCreated {\n    newAddress = flow.AccountCreatedEvent(event).Address()\n    break\n  }\n}\n```\n","path":"creating-accounts"},{"content":"---\ntitle: Generating Keys\n---\n\nFlow uses [ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)\nto control access to user accounts. Each key pair can be used in combination with\nthe SHA2-256 or SHA3-256 hashing algorithms.\n\nHere's how to generate an ECDSA private key for the P-256 (secp256r1) curve:\n\n```go\nimport \"github.com/onflow/flow-go-sdk/crypto\"\n\n// deterministic seed phrase\n// note: this is only an example, please use a secure random generator for the key seed\nseed := []byte(\"elephant ears space cowboy octopus rodeo potato cannon pineapple\")\n\nprivateKey, err := crypto.GeneratePrivateKey(crypto.ECDSA_P256, seed)\n```\n\nThe private key can then be encoded as bytes (i.e. for storage):\n\n```go\nencPrivateKey := privateKey.Encode()\n```\n\nA private key has an accompanying public key:\n\n```go\npublicKey := privateKey.PublicKey()\n```\n\n### Supported Curves\n\nThe example above uses an ECDSA key pair on the P-256 (secp256r1) elliptic curve.\nFlow also supports the secp256k1 curve used by Bitcoin and Ethereum.\n\nHere's how to generate an ECDSA private key for the secp256k1 curve:\n\n```go\nprivateKey, err := crypto.GeneratePrivateKey(crypto.ECDSA_secp256k1, seed)\n```\n\nHere's a full list of the supported signature and hash algorithms: [Flow Signature & Hash Algorithms](https://docs.onflow.org/concepts/accounts-and-keys.md#supported-signature--hash-algorithms)\n","path":"generating-keys"},{"content":"---\ntitle: Flow GO SDK\ndescription: Packages for Go developers to build applications that interact with the Flow network\n---\n\n## Installing\n\nTo start using the SDK, install Go 1.13 or above and run go get:\n\n```sh\ngo get github.com/onflow/flow-go-sdk\n```\n\n## More Examples\n\nGo here more [examples](https://github.com/onflow/flow-go-sdk/tree/master/examples) that use the SDK to interact with the [Flow Emulator](https://docs.onflow.org/emulator/).\n","path":"index"},{"content":"---\ntitle: Querying Accounts\n---\n\nYou can query the state of an account with the `GetAccount` function:\n\n```go\nimport \"github.com/onflow/flow-go-sdk\"\n\naddress := flow.HexToAddress(\"01\")\n\naccount, err := c.GetAccount(ctx, address)\nif err != nil {\n    panic(\"failed to fetch account\")\n}\n```\n\nA `flow.Account` contains the following fields:\n\n- `Address: flow.Address` - The account address.\n- `Balance: uint64` - The account balance.\n- `Contracts: map[string][]byte` - The contracts deployed at this account.\n- `Keys: []flow.AccountKey` - A list of the public keys associated with this account.\n","path":"querying-accounts"},{"content":"---\ntitle: Querying Blocks\ndescription: How to query blocks using the Flow Go SDK\n---\n\nYou can use the `GetLatestBlock` method to fetch the latest sealed or unsealed block:\n\n```go\n// fetch the latest sealed block\nisSealed := true\nlatestBlock, err := c.GetLatestBlock(ctx, isSealed)\nif err != nil {\n    panic(\"failed to fetch latest sealed block\")\n}\n\n// fetch the latest unsealed block\nisSealed := false\nlatestBlock, err := c.GetLatestBlock(ctx, isSealed)\nif err != nil {\n    panic(\"failed to fetch latest unsealed block\")\n}\n```\n\nA block contains the following fields:\n\n- `ID` - The ID (hash) of the block.\n- `ParentBlockID` - The ID of the previous block in the chain.\n- `Height` - The height of the block in the chain.\n- `CollectionGuarantees` - The list of collections included in the block.\n\n## Executing a Script\n\nYou can use the `ExecuteScriptAtLatestBlock` method to execute a read-only script against the latest sealed execution state.\n\nThis functionality can be used to read state from the blockchain.\n\nScripts must be in the following form:\n\n- A single `main` function with a single return value\n\nThis is an example of a valid script:\n\n```\nfun main(): Int { return 1 }\n```\n\n```go\nimport \"github.com/onflow/cadence\"\n\nscript := []byte(\"fun main(): Int { return 1 }\")\n\nvalue, err := c.ExecuteScript(ctx, script)\nif err != nil {\n    panic(\"failed to execute script\")\n}\n\nID := value.(cadence.Int)\n\n// convert to Go int type\nmyID := ID.Int()\n```\n","path":"querying-blocks"},{"content":"---\ntitle: Querying Events\ndescription: How to query events using the Flow Go SDK\n---\n\nYou can query events with the `GetEventsForHeightRange` function:\n\n```go\nimport \"github.com/onflow/flow-go-sdk/client\"\n\nblocks, err := c.GetEventsForHeightRange(ctx, client.EventRangeQuery{\n    Type:       \"flow.AccountCreated\",\n    StartHeight: 10,\n    EndHeight:   15,\n})\nif err != nil {\n    panic(\"failed to query events\")\n}\n```\n\n### Event Query Format\n\nAn event query includes the following fields:\n\n**Type**\n\nThe event type to filter by. Event types are namespaced by the account and contract in which they are declared.\n\nFor example, a `Transfer` event that was defined in the `Token` contract deployed at account `0x55555555555555555555` will have a type of `A.0x55555555555555555555.Token.Transfer`.\n\nRead the [language documentation](https://docs.onflow.org/cadence/language/events/) for more information on how to define and emit events in Cadence.\n\n**StartHeight, EndHeight**\n\nThe blocks to filter by. Events will be returned from blocks in the range `StartHeight` to `EndHeight`, inclusive.\n\n### Event Results\n\nThe `GetEventsForHeightRange` function returns events grouped by block. Each block contains a list of events matching the query in order of execution.\n\n```go\nfor _, block := range blocks {\n    fmt.Printf(\"Events for block %s:\\n\", block.BlockID)\n    for _, event := range block.Events {\n        fmt.Printf(\" - %s\", event)\n    }\n}\n```\n\n<!--\n### Decoding an Event\n\nTODO: example for event decoding\n-->\n","path":"querying-events"},{"content":"---\ntitle: Querying Transaction Results\ndescription: How to query transaction results using the Flow Go SDK\n---\n\nAfter you have submitted a transaction, you can query its status by ID:\n\n```go\nresult, err := c.GetTransactionResult(ctx, tx.ID())\nif err != nil {\n    panic(\"failed to fetch transaction result\")\n}\n```\n\nThe result includes a `Status` field that will be one of the following values:\n\n- `UNKNOWN` - The transaction has not yet been seen by the network.\n- `PENDING` - The transaction has not yet been included in a block.\n- `FINALIZED` - The transaction has been included in a block.\n- `EXECUTED` - The transaction has been executed but the result has not yet been sealed.\n- `SEALED` - The transaction has been executed and the result is sealed in a block.\n\n```go\nif result.Status == flow.TransactionStatusSealed {\n  fmt.Println(\"Transaction is sealed!\")\n}\n```\n\nThe result also contains an `Error` that holds the error information for a failed transaction.\n\n```go\nif result.Error != nil {\n    fmt.Printf(\"Transaction failed with error: %v\\n\", result.Error)\n}\n```\n","path":"querying-transactions"},{"content":"---\ntitle: Send a Transaction\ndescription: How to send a transaction with the Flow Go SDK\n---\n\nAfter a transaction has been [constructed](../build-transaction) and\n[signed](../sign-transaction),\nit can be sent to the Flow blockchain where it will then be executed.\n\n## Connect to an access node\n\nStart by establishing a connection with a Flow access node:\n\n```go\nimport (\n  \"github.com/onflow/flow-go-sdk\"\n  \"github.com/onflow/flow-go-sdk/client\"\n)\n\nfunc main() {\n  var accessAPIHost string\n\n  // Establish a connection with an access node\n  flowClient, err := client.New(accessAPIHost)\n  if err != nil {\n    panic(\"failed to establish connection with Access API\")\n  }\n}\n```\n\n## Send a transaction\n\nSubmit a transaction using the `SendTransaction` method:\n\n```go\nimport (\n  \"context\"\n  \"github.com/onflow/flow-go-sdk\"\n  \"github.com/onflow/flow-go-sdk/client\"\n)\n\nfunc main() {\n  // ...\n\n  var tx *flow.Transaction\n\n  ctx := context.Background()\n\n  // Send transaction to the access node\n  err := flowClient.SendTransaction(ctx, *tx)\n  if err != nil {\n    panic(\"failed to submit transaction\")\n  }\n}\n```\n\n`SendTransaction` will return an error if the access node rejects the transaction.\nThis can happen if the transaction is incomplete or contains invalid fields.\n\n## Get a transaction result\n\nAfter a transaction has been submitted, call the `GetTransactionResult` method to\nget its status and result.\n\n```go\nimport (\n  \"context\"\n  \"fmt\"\n  \"github.com/onflow/flow-go-sdk\"\n  \"github.com/onflow/flow-go-sdk/client\"\n)\n\nfunc main() {\n  // ...\n\n  var tx *flow.Transaction\n\n  ctx := context.Background()\n\n  // Send transaction to the access node\n  result, err := flowClient.GetTransactionResult(ctx, tx.ID())\n  if err != nil {\n    panic(\"failed to get transaction result\")\n  }\n\n  if result.Status == TransactionStatusSealed {\n    fmt.Println(\"transaction is sealed\")\n  } else {\n    fmt.Println(\"transaction is still pending\")\n  }\n}\n```\n","path":"sending-transactions"},{"content":"---\ntitle: Signing Transactions\ndescription: How to cryptographically sign transactions using the Go SDK\n---\n\nBelow is a simple example of how to sign a transaction using a `crypto.PrivateKey`.\n\n```go\nimport (\n    \"github.com/onflow/flow-go-sdk\"\n    \"github.com/onflow/flow-go-sdk/crypto\"\n)\n\nvar (\n    myAddress    flow.Address\n    myAccountKey flow.AccountKey\n    myPrivateKey crypto.PrivateKey\n)\n\ntx := flow.NewTransaction().\n    SetScript([]byte(\"transaction { execute { log(\\\"Hello, World!\\\") } }\")).\n    SetGasLimit(100).\n    SetProposalKey(myAddress, myAccountKey.Index, myAccountKey.SequenceNumber).\n    SetPayer(myAddress)\n```\n\nTransaction signing is done through the `crypto.Signer` interface. The simplest\n(and least secure) implementation of `crypto.Signer` is `crypto.InMemorySigner`.\n\nSignatures can be generated more securely using keys stored in a hardware device such\nas an [HSM](https://en.wikipedia.org/wiki/Hardware_security_module). The `crypto.Signer`\ninterface is intended to be flexible enough to support a variety of signer implementations\nand is not limited to in-memory implementations.\n\n```go\n// construct a signer from your private key and configured hash algorithm\nmySigner := crypto.NewInMemorySigner(myPrivateKey, myAccountKey.HashAlgo)\n\nerr := tx.SignEnvelope(myAddress, myAccountKey.Index, mySigner)\nif err != nil {\n    panic(\"failed to sign transaction\")\n}\n```\n\n# How Signatures Work in Flow\n\nFlow introduces new concepts that allow for more flexibility when creating and signing transactions.\nBefore trying the examples below, we recommend that you read through the [transaction signature documentation](https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#signing-a-transaction).\n\n---\n\n## [Single party, single signature](https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#single-party-single-signature)\n\n- Proposer, payer and authorizer are the same account (`0x01`).\n- Only the envelope must be signed.\n- Proposal key must have full signing weight.\n\n| Account | Key ID | Weight |\n| ------- | ------ | ------ |\n| `0x01`  | 1      | 1.0    |\n\n```go\naccount1, _ := c.GetAccount(ctx, flow.HexToAddress(\"01\"))\n\nkey1 := account1.Keys[0]\n\n// create signer from securely-stored private key\nkey1Signer := getSignerForKey1()\n\nreferenceBlock, _ := flow.GetLatestBlock(ctx, true)\ntx := flow.NewTransaction().\n    SetScript([]byte(`\n        transaction {\n            prepare(signer: AuthAccount) { log(signer.address) }\n        }\n    `)).\n    SetGasLimit(100).\n    SetProposalKey(account1.Address, key1.Index, key1.SequenceNumber).\n    SetReferenceBlockID(referenceBlock.ID).\n    SetPayer(account1.Address).\n    AddAuthorizer(account1.Address)\n\n// account 1 signs the envelope with key 1\nerr := tx.SignEnvelope(account1.Address, key1.Index, key1Signer)\n```\n\n[Full Runnable Example](https://github.com/onflow/flow-go-sdk/tree/master/examples#single-party-single-signature)\n\n---\n\n## [Single party, multiple signatures](https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#single-party-multiple-signatures)\n\n- Proposer, payer and authorizer are the same account (`0x01`).\n- Only the envelope must be signed.\n- Each key has weight 0.5, so two signatures are required.\n\n| Account | Key ID | Weight |\n| ------- | ------ | ------ |\n| `0x01`  | 1      | 0.5    |\n| `0x01`  | 2      | 0.5    |\n\n```go\naccount1, _ := c.GetAccount(ctx, flow.HexToAddress(\"01\"))\n\nkey1 := account1.Keys[0]\nkey2 := account1.Keys[1]\n\n// create signers from securely-stored private keys\nkey1Signer := getSignerForKey1()\nkey2Signer := getSignerForKey2()\n\nreferenceBlock, _ := flow.GetLatestBlock(ctx, true)\ntx := flow.NewTransaction().\n    SetScript([]byte(`\n        transaction {\n            prepare(signer: AuthAccount) { log(signer.address) }\n        }\n    `)).\n    SetGasLimit(100).\n    SetProposalKey(account1.Address, key1.Index, key1.SequenceNumber).\n    SetReferenceBlockID(referenceBlock.ID).\n    SetPayer(account1.Address).\n    AddAuthorizer(account1.Address)\n\n// account 1 signs the envelope with key 1\nerr := tx.SignEnvelope(account1.Address, key1.Index, key1Signer)\n\n// account 1 signs the envelope with key 2\nerr = tx.SignEnvelope(account1.Address, key2.Index, key2Signer)\n```\n\n[Full Runnable Example](https://github.com/onflow/flow-go-sdk/tree/master/examples#single-party-multiple-signatures)\n\n---\n\n## [Multiple parties](https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#multiple-parties)\n\n- Proposer and authorizer are the same account (`0x01`).\n- Payer is a separate account (`0x02`).\n- Account `0x01` signs the payload.\n- Account `0x02` signs the envelope.\n  - Account `0x02` must sign last since it is the payer.\n\n| Account | Key ID | Weight |\n| ------- | ------ | ------ |\n| `0x01`  | 1      | 1.0    |\n| `0x02`  | 3      | 1.0    |\n\n```go\naccount1, _ := c.GetAccount(ctx, flow.HexToAddress(\"01\"))\naccount2, _ := c.GetAccount(ctx, flow.HexToAddress(\"02\"))\n\nkey1 := account1.Keys[0]\nkey3 := account2.Keys[0]\n\n// create signers from securely-stored private keys\nkey1Signer := getSignerForKey1()\nkey3Signer := getSignerForKey3()\n\nreferenceBlock, _ := flow.GetLatestBlock(ctx, true)\ntx := flow.NewTransaction().\n    SetScript([]byte(`\n        transaction {\n            prepare(signer: AuthAccount) { log(signer.address) }\n        }\n    `)).\n    SetGasLimit(100).\n    SetProposalKey(account1.Address, key1.Index, key1.SequenceNumber).\n    SetReferenceBlockID(referenceBlock.ID).\n    SetPayer(account2.Address).\n    AddAuthorizer(account1.Address)\n\n// account 1 signs the payload with key 1\nerr := tx.SignPayload(account1.Address, key1.Index, key1Signer)\n\n// account 2 signs the envelope with key 3\n// note: payer always signs last\nerr = tx.SignEnvelope(account2.Address, key3.Index, key3Signer)\n```\n\n[Full Runnable Example](https://github.com/onflow/flow-go-sdk/tree/master/examples#multiple-parties)\n\n---\n\n## [Multiple parties, two authorizers](https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#multiple-parties)\n\n- Proposer and authorizer are the same account (`0x01`).\n- Payer is a separate account (`0x02`).\n- Account `0x01` signs the payload.\n- Account `0x02` signs the envelope.\n  - Account `0x02` must sign last since it is the payer.\n- Account `0x02` is also an authorizer to show how to include two AuthAccounts into an transaction\n\n| Account | Key ID | Weight |\n| ------- | ------ | ------ |\n| `0x01`  | 1      | 1.0    |\n| `0x02`  | 3      | 1.0    |\n\n```go\naccount1, _ := c.GetAccount(ctx, flow.HexToAddress(\"01\"))\naccount2, _ := c.GetAccount(ctx, flow.HexToAddress(\"02\"))\n\nkey1 := account1.Keys[0]\nkey3 := account2.Keys[0]\n\n// create signers from securely-stored private keys\nkey1Signer := getSignerForKey1()\nkey3Signer := getSignerForKey3()\n\nreferenceBlock, _ := flow.GetLatestBlock(ctx, true)\ntx := flow.NewTransaction().\n    SetScript([]byte(`\n        transaction {\n            prepare(signer1: AuthAccount, signer2: AuthAccount) {\n              log(signer.address)\n              log(signer2.address)\n          }\n        }\n    `)).\n    SetGasLimit(100).\n    SetProposalKey(account1.Address, key1.Index, key1.SequenceNumber).\n    SetReferenceBlockID(referenceBlock.ID).\n    SetPayer(account2.Address).\n    AddAuthorizer(account1.Address).\n    AddAuthorizer(account2.Address)\n\n// account 1 signs the payload with key 1\nerr := tx.SignPayload(account1.Address, key1.Index, key1Signer)\n\n// account 2 signs the envelope with key 3\n// note: payer always signs last\nerr = tx.SignEnvelope(account2.Address, key3.Index, key3Signer)\n```\n\n[Full Runnable Example](https://github.com/onflow/flow-go-sdk/tree/master/examples#multiple-parties-two-authorizers)\n\n---\n\n## [Multiple parties, multiple signatures](https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#multiple-parties-multiple-signatures)\n\n- Proposer and authorizer are the same account (`0x01`).\n- Payer is a separate account (`0x02`).\n- Account `0x01` signs the payload.\n- Account `0x02` signs the envelope.\n  - Account `0x02` must sign last since it is the payer.\n- Both accounts must sign twice (once with each of their keys).\n\n| Account | Key ID | Weight |\n| ------- | ------ | ------ |\n| `0x01`  | 1      | 0.5    |\n| `0x01`  | 2      | 0.5    |\n| `0x02`  | 3      | 0.5    |\n| `0x02`  | 4      | 0.5    |\n\n```go\naccount1, _ := c.GetAccount(ctx, flow.HexToAddress(\"01\"))\naccount2, _ := c.GetAccount(ctx, flow.HexToAddress(\"02\"))\n\nkey1 := account1.Keys[0]\nkey2 := account1.Keys[1]\nkey3 := account2.Keys[0]\nkey4 := account2.Keys[1]\n\n// create signers from securely-stored private keys\nkey1Signer := getSignerForKey1()\nkey2Signer := getSignerForKey1()\nkey3Signer := getSignerForKey3()\nkey4Signer := getSignerForKey4()\n\nreferenceBlock, _ := flow.GetLatestBlock(ctx, true)\ntx := flow.NewTransaction().\n    SetScript([]byte(`\n        transaction {\n            prepare(signer: AuthAccount) { log(signer.address) }\n        }\n    `)).\n    SetGasLimit(100).\n    SetProposalKey(account1.Address, key1.Index, key1.SequenceNumber).\n    SetReferenceBlockID(referenceBlock.ID).\n    SetPayer(account2.Address).\n    AddAuthorizer(account1.Address)\n\n// account 1 signs the payload with key 1\nerr := tx.SignPayload(account1.Address, key1.Index, key1Signer)\n\n// account 1 signs the payload with key 2\nerr = tx.SignPayload(account1.Address, key2.Index, key2Signer)\n\n// account 2 signs the envelope with key 3\n// note: payer always signs last\nerr = tx.SignEnvelope(account2.Address, key3.Index, key3Signer)\n\n// account 2 signs the envelope with key 4\n// note: payer always signs last\nerr = tx.SignEnvelope(account2.Address, key4.Index, key4Signer)\n```\n\n[Full Runnable Example](https://github.com/onflow/flow-go-sdk/tree/master/examples#multiple-parties-multiple-signatures)\n","path":"signing-transactions"},{"content":"---\ntitle: Transfer FLOW\ndescription: How to transfer FLOW using the Flow Go SDK\n---\n\nThis is an example of how to construct a FLOW token transfer transaction\nwith the Flow Go SDK.\n\nBefore using this example, read the [Build a Transaction guide](../building-transactions)\nfor a general overview of how Flow transactions are constructed.\n\n## Cadence Script\n\nThe following Cadence script will transfer FLOW tokens from a sender\nto a recipient.\n\n_Note: this transaction is only compatible with Flow Mainnet._\n\n```cadence\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FlowToken from 0x1654653399040a61\n\ntransaction(amount: UFix64, recipient: Address) {\n  let sentVault: @FungibleToken.Vault\n  prepare(signer: AuthAccount) {\n    let vaultRef = signer.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n      ?? panic(\"failed to borrow reference to sender vault\")\n\n    self.sentVault <- vaultRef.withdraw(amount: amount)\n  }\n\n  execute {\n    let receiverRef =  getAccount(recipient)\n      .getCapability(/public/flowTokenReceiver)\n      .borrow<&{FungibleToken.Receiver}>()\n        ?? panic(\"failed to borrow reference to recipient vault\")\n\n    receiverRef.deposit(from: <-self.sentVault)\n  }\n}\n```\n\n## Build the Transaction\n\n```go\nimport (\n    \"github.com/onflow/cadence\"\n    \"github.com/onflow/flow-go-sdk\"\n)\n\n// Replace with script above\nconst transferScript string = TOKEN_TRANSFER_CADENCE_SCRIPT\n\nvar (\n    senderAddress    flow.Address\n    senderAccountKey flow.AccountKey\n    senderPrivateKey crypto.PrivateKey\n)\n\nfunc main() {\n    tx := flow.NewTransaction().\n        SetScript([]byte(transferScript)).\n        SetGasLimit(100).\n        SetPayer(senderAddress).\n        SetAuthorizer(senderAddress).\n        SetProposalKey(senderAddress, senderAccountKey.Index, senderAccountKey.SequenceNumber)\n\n    amount, err := cadence.NewUFix64(\"123.4\")\n    if err != nil {\n        panic(err)\n    }\n\n    recipient := cadence.NewAddress(flow.HexToAddress(\"0xabc...\"))\n\n    err = tx.AddArgument(amount)\n    if err != nil {\n        panic(err)\n    }\n\n    err = tx.AddArgument(recipient)\n    if err != nil {\n        panic(err)\n    }\n}\n```\n\n## Sign and Send the Transaction\n\nRead the following guides to learn how to sign and send the transfer transaction:\n\n- [Sign a Flow Transaction](../signing-transactions)\n- [Send a Flow Transaction](../sending-transactions)\n","path":"transfer-flow"}],"readme":{"constent":"# Flow Go SDK \nPackages for Go developers to build applications that interact with the Flow network\n\n[![GoDoc](https://godoc.org/github.com/onflow/flow-go-sdk?status.svg)](https://godoc.org/github.com/onflow/flow-go-sdk)\n\nThe Flow Go SDK provides a set of packages for Go developers to build applications that interact with the Flow network.\n\n*Note: This SDK is also fully compatible with the [Flow Emulator](https://docs.onflow.org/devtools/emulator/) and can be used for local development.*\n\n## [English](#) | [Chinese](/README_zh_CN.md)\n\n## What is Flow?\n\nFlow is a new blockchain for open worlds. Read more about it [here](https://github.com/onflow/flow).\n\n## Table of Contents\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n\n- [Flow Go SDK ![GoDoc](https://godoc.org/github.com/onflow/flow-go-sdk)](#flow-go-sdk-)\n  - [English | [Chinese](/README_zh_CN.md)](#english--chinese)\n  - [What is Flow?](#what-is-flow)\n  - [Table of Contents](#table-of-contents)\n- [Getting Started](#getting-started)\n  - [Installing](#installing)\n  - [Generating Keys](#generating-keys)\n    - [Supported Curves](#supported-curves)\n  - [Creating an Account](#creating-an-account)\n  - [Signing a Transaction](#signing-a-transaction)\n    - [How Signatures Work in Flow](#how-signatures-work-in-flow)\n      - [Single party, single signature](#single-party-single-signature)\n      - [Single party, multiple signatures](#single-party-multiple-signatures)\n      - [Multiple parties](#multiple-parties)\n      - [Multiple parties, two authorizers](#multiple-parties-two-authorizers)\n      - [Multiple parties, multiple signatures](#multiple-parties-multiple-signatures)\n  - [Sending a Transaction](#sending-a-transaction)\n  - [Querying Transaction Results](#querying-transaction-results)\n  - [Querying Blocks](#querying-blocks)\n  - [Executing a Script](#executing-a-script)\n  - [Querying Events](#querying-events)\n    - [Event Query Format](#event-query-format)\n    - [Event Results](#event-results)\n  - [Querying Accounts](#querying-accounts)\n  - [Examples](#examples)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\n# Getting Started\n\n## Installing\n\nTo start using the SDK, install Go 1.13 or above and run go get:\n\n```sh\ngo get github.com/onflow/flow-go-sdk\n```\n\n## Generating Keys\n\nFlow uses [ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm) \nto control access to user accounts. Each key pair can be used in combination with\nthe SHA2-256 or SHA3-256 hashing algorithms.\n\nHere's how to generate an ECDSA private key for the P-256 (secp256r1) curve:\n\n```go\nimport \"github.com/onflow/flow-go-sdk/crypto\"\n\n// deterministic seed phrase\n// note: this is only an example, please use a secure random generator for the key seed\nseed := []byte(\"elephant ears space cowboy octopus rodeo potato cannon pineapple\")\n\nprivateKey, err := crypto.GeneratePrivateKey(crypto.ECDSA_P256, seed)\n```\n\nThe private key can then be encoded as bytes (i.e. for storage):\n\n```go\nencPrivateKey := privateKey.Encode()\n```\n\nA private key has an accompanying public key:\n\n```go\npublicKey := privateKey.PublicKey()\n```\n\n### Supported Curves\n\nThe example above uses an ECDSA key pair on the P-256 (secp256r1) elliptic curve.\nFlow also supports the secp256k1 curve used by Bitcoin and Ethereum.\n\nHere's how to generate an ECDSA private key for the secp256k1 curve:\n\n```go\nprivateKey, err := crypto.GeneratePrivateKey(crypto.ECDSA_secp256k1, seed)\n```\n\nHere's a full list of the supported signature and hash algorithms: [Flow Signature & Hash Algorithms](https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#supported-signature--hash-algorithms)\n\n## Creating an Account\n\nOnce you have [generated a key pair](#generating-keys), you can create a new account\nusing its public key.\n\n```go\nimport (\n    \"github.com/onflow/flow-go-sdk\"\n    \"github.com/onflow/flow-go-sdk/crypto\"\n    \"github.com/onflow/flow-go-sdk/templates\"\n)\n\nctx := context.Background()\n\n// generate a new private key for the account\n// note: this is only an example, please use a secure random generator for the key seed\nseed := []byte(\"elephant ears space cowboy octopus rodeo potato cannon pineapple\")\nprivateKey, _ := crypto.GeneratePrivateKey(crypto.ECDSA_P256, seed)\n\n// get the public key\npublicKey := privateKey.PublicKey()\n\n// construct an account key from the public key\naccountKey := flow.NewAccountKey().\n    SetPublicKey(publicKey).\n    SetHashAlgo(crypto.SHA3_256).             // pair this key with the SHA3_256 hashing algorithm\n    SetWeight(flow.AccountKeyWeightThreshold) // give this key full signing weight\n\n// generate an account creation script\n// this creates an account with a single public key and no code\nscript, _ := templates.CreateAccount([]*flow.AccountKey{accountKey}, nil)\n\n// connect to an emulator running locally\nc, err := client.New(\"localhost:3569\")\nif err != nil {\n    panic(\"failed to connect to emulator\")\n}\n\npayer, payerKey, payerSigner := examples.ServiceAccount(c)\n\ntx := flow.NewTransaction().\n    SetScript(script).\n    SetGasLimit(100).\n    SetProposalKey(payer, payerKey.Index, payerKey.SequenceNumber).\n    SetPayer(payer)\n\nerr = tx.SignEnvelope(payer, payerKey.Index, payerSigner)\nif err != nil {\n    panic(\"failed to sign transaction\")\n}\n\nerr = c.SendTransaction(ctx, *tx)\nif err != nil {\n    panic(\"failed to send transaction\")\n}\n\nresult, err := c.GetTransactionResult(ctx, tx.ID())\nif err != nil {\n    panic(\"failed to get transaction result\")\n}\n\nvar myAddress flow.Address\n\nif result.Status == flow.TransactionStatusSealed {\n    for _, event := range result.Events {\n        if event.Type == flow.EventAccountCreated {\n            accountCreatedEvent := flow.AccountCreatedEvent(event)\n            myAddress = accountCreatedEvent.Address()\n        }\n\t}\n}\n```\n\n## Signing a Transaction\n\nBelow is a simple example of how to sign a transaction using a `crypto.PrivateKey`.\n\n```go\nimport (\n    \"github.com/onflow/flow-go-sdk\"\n    \"github.com/onflow/flow-go-sdk/crypto\"\n)\n\nvar (\n    myAddress    flow.Address\n    myAccountKey flow.AccountKey\n    myPrivateKey crypto.PrivateKey\n)\n\ntx := flow.NewTransaction().\n    SetScript([]byte(\"transaction { execute { log(\\\"Hello, World!\\\") } }\")).\n    SetGasLimit(100).\n    SetProposalKey(myAddress, myAccountKey.Index, myAccountKey.SequenceNumber).\n    SetPayer(myAddress)\n```\n\nTransaction signing is done through the `crypto.Signer` interface. The simplest \n(and least secure) implementation of `crypto.Signer` is `crypto.InMemorySigner`.\n\nSignatures can be generated more securely using keys stored in a hardware device such \nas an [HSM](https://en.wikipedia.org/wiki/Hardware_security_module). The `crypto.Signer` \ninterface is intended to be flexible enough to support a variety of signer implementations \nand is not limited to in-memory implementations.\n\n```go\n// construct a signer from your private key and configured hash algorithm\nmySigner := crypto.NewInMemorySigner(myPrivateKey, myAccountKey.HashAlgo)\n\nerr := tx.SignEnvelope(myAddress, myAccountKey.Index, mySigner)\nif err != nil {\n    panic(\"failed to sign transaction\")\n}\n```\n\n### How Signatures Work in Flow\n\nFlow introduces new concepts that allow for more flexibility when creating and signing transactions. \nBefore trying the examples below, we recommend that you read through the [transaction signature documentation](https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#signing-a-transaction).\n\n---\n\n#### [Single party, single signature](https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#single-party-single-signature)\n\n- Proposer, payer and authorizer are the same account (`0x01`).\n- Only the envelope must be signed.\n- Proposal key must have full signing weight.\n\n| Account   | Key ID | Weight |\n|-----------|--------|--------|\n| `0x01`    | 1      | 1.0    |\n\n```go\naccount1, _ := c.GetAccount(ctx, flow.HexToAddress(\"01\"))\n\nkey1 := account1.Keys[0]\n\n// create signer from securely-stored private key\nkey1Signer := getSignerForKey1()\n\ntx := flow.NewTransaction().\n    SetScript([]byte(`\n        transaction { \n            prepare(signer: AuthAccount) { log(signer.address) }\n        }\n    `)).\n    SetGasLimit(100).\n    SetProposalKey(account1.Address, key1.Index, key1.SequenceNumber).\n    SetPayer(account1.Address).\n    AddAuthorizer(account1.Address)\n\n// account 1 signs the envelope with key 1\nerr := tx.SignEnvelope(account1.Address, key1.Index, key1Signer)\n```\n\n[Full Runnable Example](/examples#single-party-single-signature)\n\n---\n\n#### [Single party, multiple signatures](https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#single-party-multiple-signatures)\n\n- Proposer, payer and authorizer are the same account (`0x01`).\n- Only the envelope must be signed.\n- Each key has weight 0.5, so two signatures are required.\n\n| Account   | Key ID | Weight |\n|-----------|--------|--------|\n| `0x01`    | 1      | 0.5    |\n| `0x01`    | 2      | 0.5    |\n\n```go\naccount1, _ := c.GetAccount(ctx, flow.HexToAddress(\"01\"))\n\nkey1 := account1.Keys[0]\nkey2 := account1.Keys[1]\n\n// create signers from securely-stored private keys\nkey1Signer := getSignerForKey1()\nkey2Signer := getSignerForKey2()\n\ntx := flow.NewTransaction().\n    SetScript([]byte(`\n        transaction { \n            prepare(signer: AuthAccount) { log(signer.address) }\n        }\n    `)).\n    SetGasLimit(100).\n    SetProposalKey(account1.Address, key1.Index, key1.SequenceNumber).\n    SetPayer(account1.Address).\n    AddAuthorizer(account1.Address)\n\n// account 1 signs the envelope with key 1\nerr := tx.SignEnvelope(account1.Address, key1.Index, key1Signer)\n\n// account 1 signs the envelope with key 2\nerr = tx.SignEnvelope(account1.Address, key2.Index, key2Signer)\n```\n\n[Full Runnable Example](/examples#single-party-multiple-signatures)\n\n---\n\n#### [Multiple parties](https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#multiple-parties)\n\n- Proposer and authorizer are the same account (`0x01`).\n- Payer is a separate account (`0x02`).\n- Account `0x01` signs the payload.\n- Account `0x02` signs the envelope.\n  - Account `0x02` must sign last since it is the payer.\n\n| Account   | Key ID | Weight |\n|-----------|--------|--------|\n| `0x01`    | 1      | 1.0    |\n| `0x02`    | 3      | 1.0    |\n\n```go\naccount1, _ := c.GetAccount(ctx, flow.HexToAddress(\"01\"))\naccount2, _ := c.GetAccount(ctx, flow.HexToAddress(\"02\"))\n\nkey1 := account1.Keys[0]\nkey3 := account2.Keys[0]\n\n// create signers from securely-stored private keys\nkey1Signer := getSignerForKey1()\nkey3Signer := getSignerForKey3()\n\ntx := flow.NewTransaction().\n    SetScript([]byte(`\n        transaction { \n            prepare(signer: AuthAccount) { log(signer.address) }\n        }\n    `)).\n    SetGasLimit(100).\n    SetProposalKey(account1.Address, key1.Index, key1.SequenceNumber).\n    SetPayer(account2.Address).\n    AddAuthorizer(account1.Address)\n\n// account 1 signs the payload with key 1\nerr := tx.SignPayload(account1.Address, key1.Index, key1Signer)\n\n// account 2 signs the envelope with key 3\n// note: payer always signs last\nerr = tx.SignEnvelope(account2.Address, key3.Index, key3Signer)\n```\n\n[Full Runnable Example](/examples#multiple-parties)\n\n---\n#### [Multiple parties, two authorizers](https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#multiple-parties)\n\n- Proposer and authorizer are the same account (`0x01`).\n- Payer is a separate account (`0x02`).\n- Account `0x01` signs the payload.\n- Account `0x02` signs the envelope.\n  - Account `0x02` must sign last since it is the payer.\n- Account `0x02` is also an authorizer to show how to include two AuthAccounts into an transaction\n\n| Account   | Key ID | Weight |\n|-----------|--------|--------|\n| `0x01`    | 1      | 1.0    |\n| `0x02`    | 3      | 1.0    |\n\n```go\naccount1, _ := c.GetAccount(ctx, flow.HexToAddress(\"01\"))\naccount2, _ := c.GetAccount(ctx, flow.HexToAddress(\"02\"))\n\nkey1 := account1.Keys[0]\nkey3 := account2.Keys[0]\n\n// create signers from securely-stored private keys\nkey1Signer := getSignerForKey1()\nkey3Signer := getSignerForKey3()\n\ntx := flow.NewTransaction().\n    SetScript([]byte(`\n        transaction {\n            prepare(signer1: AuthAccount, signer2: AuthAccount) {\n              log(signer.address)\n              log(signer2.address)\n          }\n        }\n    `)).\n    SetGasLimit(100).\n    SetProposalKey(account1.Address, key1.Index, key1.SequenceNumber).\n    SetPayer(account2.Address).\n    AddAuthorizer(account1.Address).\n    AddAuthorizer(account2.Address)\n\n// account 1 signs the payload with key 1\nerr := tx.SignPayload(account1.Address, key1.Index, key1Signer)\n\n// account 2 signs the envelope with key 3\n// note: payer always signs last\nerr = tx.SignEnvelope(account2.Address, key3.Index, key3Signer)\n```\n\n[Full Runnable Example](/examples#multiple-parties-two-authorizers)\n\n---\n\n#### [Multiple parties, multiple signatures](https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#multiple-parties-multiple-signatures)\n\n- Proposer and authorizer are the same account (`0x01`).\n- Payer is a separate account (`0x02`).\n- Account `0x01` signs the payload.\n- Account `0x02` signs the envelope.\n  - Account `0x02` must sign last since it is the payer.\n- Both accounts must sign twice (once with each of their keys).\n\n| Account   | Key ID | Weight |\n|-----------|--------|--------|\n| `0x01`    | 1      | 0.5    |\n| `0x01`    | 2      | 0.5    |\n| `0x02`    | 3      | 0.5    |\n| `0x02`    | 4      | 0.5    |\n\n```go\naccount1, _ := c.GetAccount(ctx, flow.HexToAddress(\"01\"))\naccount2, _ := c.GetAccount(ctx, flow.HexToAddress(\"02\"))\n\nkey1 := account1.Keys[0]\nkey2 := account1.Keys[1]\nkey3 := account2.Keys[0]\nkey4 := account2.Keys[1]\n\n// create signers from securely-stored private keys\nkey1Signer := getSignerForKey1()\nkey2Signer := getSignerForKey1()\nkey3Signer := getSignerForKey3()\nkey4Signer := getSignerForKey4()\n\ntx := flow.NewTransaction().\n    SetScript([]byte(`\n        transaction { \n            prepare(signer: AuthAccount) { log(signer.address) }\n        }\n    `)).\n    SetGasLimit(100).\n    SetProposalKey(account1.Address, key1.Index, key1.SequenceNumber).\n    SetPayer(account2.Address).\n    AddAuthorizer(account1.Address)\n\n// account 1 signs the payload with key 1\nerr := tx.SignPayload(account1.Address, key1.Index, key1Signer)\n\n// account 1 signs the payload with key 2\nerr = tx.SignPayload(account1.Address, key2.Index, key2Signer)\n\n// account 2 signs the envelope with key 3\n// note: payer always signs last\nerr = tx.SignEnvelope(account2.Address, key3.Index, key3Signer)\n\n// account 2 signs the envelope with key 4\n// note: payer always signs last\nerr = tx.SignEnvelope(account2.Address, key4.Index, key4Signer)\n```\n\n[Full Runnable Example](/examples#multiple-parties-multiple-signatures)\n\n## Sending a Transaction\n\nYou can submit a transaction to the network using the Access API client.\n\n```go\nimport \"github.com/onflow/flow-go-sdk/client\"\n\n// connect to an emulator running locally\nc, err := client.New(\"localhost:3569\")\nif err != nil {\n    panic(\"failed to connect to emulator\")\n}\n\nctx := context.Background()\n\nerr = c.SendTransaction(ctx, tx)\nif err != nil {\n    panic(\"failed to send transaction\")\n}\n```\n\n## Querying Transaction Results\n\nAfter you have submitted a transaction, you can query its status by ID:\n\n```go\nresult, err := c.GetTransactionResult(ctx, tx.ID())\nif err != nil {\n    panic(\"failed to fetch transaction result\")\n}\n```\n\nThe result includes a `Status` field that will be one of the following values:\n- `UNKNOWN` - The transaction has not yet been seen by the network.\n- `PENDING` - The transaction has not yet been included in a block.\n- `FINALIZED` - The transaction has been included in a block.\n- `EXECUTED` - The transaction has been executed but the result has not yet been sealed.\n- `SEALED` - The transaction has been executed and the result is sealed in a block.\n\n```go\nif result.Status == flow.TransactionStatusSealed {\n  fmt.Println(\"Transaction is sealed!\")\n}\n```\n\nThe result also contains an `Error` that holds the error information for a failed transaction.\n\n```go\nif result.Error != nil {\n    fmt.Printf(\"Transaction failed with error: %v\\n\", result.Error)\n}\n```\n\n## Querying Blocks\n\nYou can use the `GetLatestBlock` method to fetch the latest sealed or unsealed block:\n\n```go\n// fetch the latest sealed block\nisSealed := true\nlatestBlock, err := c.GetLatestBlock(ctx, isSealed)\nif err != nil {\n    panic(\"failed to fetch latest sealed block\")\n}\n\n// fetch the latest unsealed block\nisSealed := false\nlatestBlock, err := c.GetLatestBlock(ctx, isSealed)\nif err != nil {\n    panic(\"failed to fetch latest unsealed block\")\n}\n```\n\nA block contains the following fields:\n\n- `ID` - The ID (hash) of the block.\n- `ParentBlockID` - The ID of the previous block in the chain.\n- `Height` - The height of the block in the chain.\n- `CollectionGuarantees` - The list of collections included in the block.\n\n## Executing a Script\n\nYou can use the `ExecuteScriptAtLatestBlock` method to execute a read-only script against the latest sealed execution state.\n\nThis functionality can be used to read state from the blockchain.\n\nScripts must be in the following form:\n\n- A single `main` function with a single return value\n\nThis is an example of a valid script:\n\n```\nfun main(): Int { return 1 }\n```\n\n```go\nimport \"github.com/onflow/cadence\"\n\nscript := []byte(\"fun main(): Int { return 1 }\")\n\nvalue, err := c.ExecuteScript(ctx, script)\nif err != nil {\n    panic(\"failed to execute script\")\n}\n\nID := value.(cadence.Int)\n\n// convert to Go int type\nmyID := ID.Int()\n```\n\n## Querying Events\n\nYou can query events with the `GetEventsForHeightRange` function:\n\n```go\nimport \"github.com/onflow/flow-go-sdk/client\"\n\nblocks, err := c.GetEventsForHeightRange(ctx, client.EventRangeQuery{\n    Type:       \"flow.AccountCreated\",\n    StartHeight: 10,\n    EndHeight:   15,\n})\nif err != nil {\n    panic(\"failed to query events\")\n}\n```\n\n### Event Query Format\n\nAn event query includes the following fields:\n\n**Type**\n\nThe event type to filter by. Event types are namespaced by the account and contract in which they are declared.\n\nFor example, a `Transfer` event that was defined in the `Token` contract deployed at account `0x55555555555555555555` will have a type of `A.0x55555555555555555555.Token.Transfer`.\n\nRead the [language documentation](https://docs.onflow.org/cadence/language/events/) for more information on how to define and emit events in Cadence.\n\n**StartHeight, EndHeight**\n\nThe blocks to filter by. Events will be returned from blocks in the range `StartHeight` to `EndHeight`, inclusive.\n\n### Event Results\n\nThe `GetEventsForHeightRange` function returns events grouped by block. Each block contains a list of events matching the query in order of execution.\n\n```go\nfor _, block := range blocks {\n    fmt.Printf(\"Events for block %s:\\n\", block.BlockID)\n    for _, event := range block.Events {\n        fmt.Printf(\" - %s\", event)\n    }\n}\n```\n\n<!--\n### Decoding an Event\n\nTODO: example for event decoding\n-->\n\n## Querying Accounts\n\nYou can query the state of an account with the `GetAccount` function:\n\n```go\nimport \"github.com/onflow/flow-go-sdk\"\n\naddress := flow.HexToAddress(\"01\")\n\naccount, err := c.GetAccount(ctx, address)\nif err != nil {\n    panic(\"failed to fetch account\")\n}\n```\n\nA `flow.Account` contains the following fields:\n\n- `Address: flow.Address` - The account address.\n- `Balance: uint64` - The account balance.\n- `Code: []byte` - The code deployed at this account.\n- `Keys: []flow.AccountKey` - A list of the public keys associated with this account.\n\n## Examples\n\nThe [examples](/examples) directory contains code samples that use the SDK to interact with the [Flow Emulator](https://docs.onflow.org/devtools/emulator/).\n","path":"README"}}