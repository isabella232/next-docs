{"language":[{"content":"---\ntitle: Access control\n---\n\nAccess control allows making certain parts of the program accessible/visible\nand making other parts inaccessible/invisible.\n\nIn Flow and Cadence, there are two types of access control:\n\n1. Access control on objects in account storage using capability security.\n\n    Within Flow, a caller is not able to access an object\n    unless it owns the object or has a specific reference to that object.\n    This means that nothing is truly public by default.\n    Other accounts can not read or write the objects in an account\n    unless the owner of the account has granted them access\n    by providing references to the objects.\n\n2. Access control within contracts and objects\n   using `pub` and `access` keywords.\n\n   For the explanations of the following keywords, we assume that\n   the defining type is either a contract, where capability security\n   doesn't apply, or that the caller would have valid access to the object\n   governed by capability security.\n\nThe high-level reference-based security (point 1 above)\nwill be covered in a later section.\n\nTop-level declarations\n(variables, constants, functions, structures, resources, interfaces)\nand fields (in structures, and resources) are always only able to be written\nto in the scope where it is defined (self).\n\nThere are four levels of access control defined in the code that specify where\na declaration can be accessed or called.\n\n- **Public** or **access(all)** means the declaration\n  is accessible/visible in all scopes.\n\n  This includes the current scope, inner scopes, and the outer scopes.\n\n  For example, a public field in a type can be accessed using the access syntax\n  on an instance of the type in an outer scope.\n  This does not allow the declaration to be publicly writable though.\n\n  An element is made publicly accessible / by any code\n  by using the `pub` or `access(all)` keywords.\n\n- **access(account)** means the declaration is only accessible/visible in the\n  scope of the entire account where it is defined. This means that\n  other contracts in the account are able to access it,\n\n  An element is made accessible by code in the same account (e.g. other contracts)\n  by using the `access(account)` keyword.\n\n- **access(contract)** means the declaration is only accessible/visible in the\n  scope of the contract that defined it. This means that other types\n  and functions that are defined in the same contract can access it,\n  but not other contracts in the same account.\n\n  An element is made accessible by code in the same contract\n  by using the `access(contract)` keyword.\n\n- Private or **access(self)** means the declaration is only accessible/visible\n  in the current and inner scopes.\n\n  For example, an `access(self)` field can only be\n  accessed by functions of the type is part of,\n  not by code in an outer scope.\n\n  An element is made accessible by code in the same containing type\n  by using the `access(self)` keyword.\n\n**Access level must be specified for each declaration**\n\nThe `(set)` suffix can be used to make variables also publicly writable.\n\nTo summarize the behavior for variable declarations, constant declarations, and fields:\n\n| Declaration kind | Access modifier          | Read scope                                           | Write scope       |\n|:-----------------|:-------------------------|:-----------------------------------------------------|:------------------|\n| `let`            | `priv` / `access(self)`  | Current and inner                                    | *None*            |\n| `let`            | `access(contract)`       | Current, inner, and containing contract              | *None*            |\n| `let`            | `access(account)`        | Current, inner, and other contracts in same account  | *None*            |\n| `let`            | `pub`,`access(all)`      | **All**                                              | *None*            |\n| `var`            | `access(self)`           | Current and inner                                    | Current and inner |\n| `var`            | `access(contract)`       | Current, inner, and containing contract              | Current and inner |\n| `var`            | `access(account)`        | Current, inner, and other contracts in same account  | Current and inner |\n| `var`            | `pub` / `access(all)`    | **All**                                              | Current and inner |\n| `var`            | `pub(set)`               | **All**                                              | **All**           |\n\nTo summarize the behavior for functions:\n\n| Access modifier          | Access scope                                        |\n|:-------------------------|:----------------------------------------------------|\n| `priv` / `access(self)`  | Current and inner                                   |\n| `access(contract)`       | Current, inner, and containing contract             |\n| `access(account)`        | Current, inner, and other contracts in same account |\n| `pub` / `access(all)`    | **All**                                             |\n\nDeclarations of structures, resources, events, and [contracts](../contracts) can only be public.\nHowever, even though the declarations/types are publicly visible,\nresources can only be created from inside the contract they are declared in.\n\n```cadence\n// Declare a private constant, inaccessible/invisible in outer scope.\n//\naccess(self) let a = 1\n\n// Declare a public constant, accessible/visible in all scopes.\n//\npub let b = 2\n```\n\n```cadence\n// Declare a public struct, accessible/visible in all scopes.\n//\npub struct SomeStruct {\n\n    // Declare a private constant field which is only readable\n    // in the current and inner scopes.\n    //\n    access(self) let a: Int\n\n    // Declare a public constant field which is readable in all scopes.\n    //\n    pub let b: Int\n\n    // Declare a private variable field which is only readable\n    // and writable in the current and inner scopes.\n    //\n    access(self) var c: Int\n\n    // Declare a public variable field which is not settable,\n    // so it is only writable in the current and inner scopes,\n    // and readable in all scopes.\n    //\n    pub var d: Int\n\n    // Declare a public variable field which is settable,\n    // so it is readable and writable in all scopes.\n    //\n    pub(set) var e: Int\n\n    // The initializer is omitted for brevity.\n\n    // Declare a private function which is only callable\n    // in the current and inner scopes.\n    //\n    access(self) fun privateTest() {\n        // ...\n    }\n\n    // Declare a public function which is callable in all scopes.\n    //\n    pub fun privateTest() {\n        // ...\n    }\n\n    // The initializer is omitted for brevity.\n\n}\n\nlet some = SomeStruct()\n\n// Invalid: cannot read private constant field in outer scope.\n//\nsome.a\n\n// Invalid: cannot set private constant field in outer scope.\n//\nsome.a = 1\n\n// Valid: can read public constant field in outer scope.\n//\nsome.b\n\n// Invalid: cannot set public constant field in outer scope.\n//\nsome.b = 2\n\n// Invalid: cannot read private variable field in outer scope.\n//\nsome.c\n\n// Invalid: cannot set private variable field in outer scope.\n//\nsome.c = 3\n\n// Valid: can read public variable field in outer scope.\n//\nsome.d\n\n// Invalid: cannot set public variable field in outer scope.\n//\nsome.d = 4\n\n// Valid: can read publicly settable variable field in outer scope.\n//\nsome.e\n\n// Valid: can set publicly settable variable field in outer scope.\n//\nsome.e = 5\n```\n","path":"language/access-control"},{"content":"---\ntitle: Accounts\n---\n\nEvery account can be accessed through two types:\n\n- As a **Public Account** with the type `PublicAccount`,\n  which represents the publicly available portion of an account.\n\n  ```cadence\n  struct PublicAccount {\n\n      let address: Address\n      let storageUsed: UInt64\n      let storageCapacity: UInt64\n\n      // Storage operations\n\n      fun getCapability<T>(_ path: PublicPath): Capability<T>\n      fun getLinkTarget(_ path: CapabilityPath): Path?\n  }\n  ```\n\n  Any code can get the `PublicAccount` for an account address\n  using the built-in `getAccount` function:\n\n  ```cadence\n  fun getAccount(_ address: Address): PublicAccount\n  ```\n\n- As an **Authorized Account** with type `AuthAccount`,\n  which represents the authorized portion of an account.\n\n  Access to an `AuthAccount` means having full access to its [storage](#account-storage),\n  public keys, and code.\n\n  Only [signed transactions](transactions) can get the `AuthAccount` for an account.\n  For each script signer of the transaction, the corresponding `AuthAccount` is passed\n  to the `prepare` phase of the transaction.\n\n  ```cadence\n  struct AuthAccount {\n\n      let address: Address\n      let storageUsed: UInt64\n      let storageCapacity: UInt64\n\n      // Contracts\n\n      let contracts: AuthAccount.Contracts\n\n      // Key management\n\n      fun addPublicKey(_ publicKey: [UInt8])\n      fun removePublicKey(_ index: Int)\n\n      // Storage operations\n\n      fun save<T>(_ value: T, to: StoragePath)\n      fun load<T>(from: StoragePath): T?\n      fun copy<T: AnyStruct>(from: StoragePath): T?\n\n      fun borrow<T: &Any>(from: StoragePath): T?\n\n      fun link<T: &Any>(_ newCapabilityPath: CapabilityPath, target: Path): Capability<T>?\n      fun getCapability<T>(_ path: CapabilityPath): Capability<T>\n      fun getLinkTarget(_ path: CapabilityPath): Path?\n      fun unlink(_ path: CapabilityPath)\n\n      struct Contracts {\n          fun add(\n              name: String,\n              code: [UInt8],\n              ... contractInitializerArguments\n          ): DeployedContract\n\n          fun update__experimental(name: String, code: [UInt8]): DeployedContract\n\n          fun get(name: String): DeployedContract?\n\n          fun remove(name: String): DeployedContract?\n      }\n  }\n\n  struct DeployedContract {\n      let name: String\n      let code: [UInt8]\n  }\n  ```\n\n## Account Creation\n\nAccounts can be created by calling the `AuthAccount` constructor\nand passing the account that should pay for the account creation for the `payer` parameter.\n\nThe `payer` must have enough funds to be able to create an account.\nIf the account does not have the required funds, the program aborts.\n\nTo authorize access to the account, keys can be added using the `addPublicKey` function.\nKeys can also later be removed using the `removePublicKey` function.\n\nFor example, to create an account and have the signer of the transaction pay for the account creation,\nand authorize one key to access the account:\n\n```cadence\ntransaction(key: [UInt8]) {\n    prepare(signer: AuthAccount) {\n        let account = AuthAccount(payer: signer)\n        account.addPublicKey(key)\n    }\n}\n```\n\n## Account Storage\n\nAll accounts have storage.\nBoth resources and structures can be stored in account storage.\n\n### Paths\n\nObjects are stored under paths.\nPaths consist of a domain and an identifier.\n\nPaths start with the character `/`, followed by the domain, the path separator `/`,\nand finally the identifier.\nFor example, the path `/storage/test` has the domain `storage` and the identifier `test`.\n\nThere are only three valid domains: `storage`, `private`, and `public`.\n\nObjects in storage are always stored in the `storage` domain.\n\nPaths in the storage domain have type `StoragePath`,\nin the private domain `PrivatePath`,\nand in the public domain `PublicPath`.\n\n`PrivatePath` and `PublicPath` are subtypes of `CapabilityPath`.\n\nBoth `StoragePath` and `CapabilityPath` are subtypes of `Path`.\n\n<table>\n  <tr>\n    <td colspan=\"3\">Path</td>\n  </tr>\n  <tr>\n    <td colspan=\"2\">CapabilityPath</td>\n    <td colspan=\"2\" rowspan=\"2\">StoragePath</td>\n  </tr>\n  <tr>\n    <td>PrivatePath</td>\n    <td>PublicPath</td>\n  </tr>\n</table>\n\n### Account Storage API\n\nAccount storage is accessed through the following functions of `AuthAccount`.\nThis means that any code that has access to the authorized account has access\nto all its stored objects.\n\n- `cadence•fun save<T>(_ value: T, to: StoragePath)`\n\n  Saves an object to account storage.\n  Resources are moved into storage, and structures are copied.\n\n  `T` is the type parameter for the object type.\n  It can be inferred from the argument's type.\n\n  If there is already an object stored under the given path, the program aborts.\n\n  The path must be a storage path, i.e., only the domain `storage` is allowed.\n\n- `cadence•fun load<T>(from: StoragePath): T?`\n\n  Loads an object from account storage.\n  If no object is stored under the given path, the function returns `nil`.\n  If there is an object stored, the stored resource or structure is moved\n  out of storage and returned as an optional.\n  When the function returns, the storage no longer contains an object\n  under the given path.\n\n  `T` is the type parameter for the object type.\n  A type argument for the parameter must be provided explicitly.\n\n  The type `T` must be a supertype of the type of the loaded object.\n  If it is not, the function returns `nil`.\n  The given type does not necessarily need to be exactly the same as the type of the loaded object.\n\n  The path must be a storage path, i.e., only the domain `storage` is allowed.\n\n- `cadence•fun copy<T: AnyStruct>(from: StoragePath): T?`\n\n  Returns a copy of a structure stored in account storage, without removing it from storage.\n\n  If no structure is stored under the given path, the function returns `nil`.\n  If there is a structure stored, it is copied.\n  The structure stays stored in storage after the function returns.\n\n  `T` is the type parameter for the structure type.\n  A type argument for the parameter must be provided explicitly.\n\n  The type `T` must be a supertype of the type of the copied structure.\n  If it is not, the function returns `nil`.\n  The given type does not necessarily need to be exactly the same as\n  the type of the copied structure.\n\n  The path must be a storage path, i.e., only the domain `storage` is allowed.\n\n```cadence\n// Declare a resource named `Counter`.\n//\nresource Counter {\n    pub var count: Int\n\n    pub init(count: Int) {\n        self.count = count\n    }\n}\n\n// In this example an authorized account is available through the constant `authAccount`.\n\n// Create a new instance of the resource type `Counter`\n// and save it in the storage of the account.\n//\n// The path `/storage/counter` is used to refer to the stored value.\n// Its identifier `counter` was chosen freely and could be something else.\n//\nauthAccount.save(<-create Counter(count: 42), to: /storage/counter)\n\n// Run-time error: Storage already contains an object under path `/storage/counter`\n//\nauthAccount.save(<-create Counter(count: 123), to: /storage/counter)\n\n// Load the `Counter` resource from storage path `/storage/counter`.\n//\n// The new constant `counter` has the type `Counter?`, i.e., it is an optional,\n// and its value is the counter resource, that was saved at the beginning\n// of the example.\n//\nlet counter <- authAccount.load<@Counter>(from: /storage/counter)\n\n// The storage is now empty, there is no longer an object stored\n// under the path `/storage/counter`.\n\n// Load the `Counter` resource again from storage path `/storage/counter`.\n//\n// The new constant `counter2` has the type `Counter?` and is `nil`,\n// as nothing is stored under the path `/storage/counter` anymore,\n// because the previous load moved the counter out of storage.\n//\nlet counter2 <- authAccount.load<@Counter>(from: /storage/counter)\n\n// Create another new instance of the resource type `Counter`\n// and save it in the storage of the account.\n//\n// The path `/storage/otherCounter` is used to refer to the stored value.\n//\nauthAccount.save(<-create Counter(count: 123), to: /storage/otherCounter)\n\n// Load the `Vault` resource from storage path `/storage/otherCounter`.\n//\n// The new constant `vault` has the type `Vault?` and its value is `nil`,\n// as there is a resource with type `Counter` stored under the path,\n// which is not a subtype of the requested type `Vault`.\n//\nlet vault <- authAccount.load<@Vault>(from: /storage/otherCounter)\n\n// The storage still stores a `Counter` resource under the path `/storage/otherCounter`.\n\n// Save the string \"Hello, World\" in storage\n// under the path `/storage/helloWorldMessage`.\n\nauthAccount.save(\"Hello, world!\", to: /storage/helloWorldMessage)\n\n// Copy the stored message from storage.\n//\n// After the copy, the storage still stores the string under the path.\n// Unlike `load`, `copy` does not remove the object from storage.\n//\nlet message = authAccount.copy<String>(from: /storage/helloWorldMessage)\n\n// Create a new instance of the resource type `Vault`\n// and save it in the storage of the account.\n//\nauthAccount.save(<-createEmptyVault(), to: /storage/vault)\n\n// Invalid: Cannot copy a resource, as this would allow arbitrary duplication.\n//\nlet vault <- authAccount.copy<@Vault>(from: /storage/vault)\n```\n\nAs it is convenient to work with objects in storage\nwithout having to move them out of storage,\nas it is necessary for resources,\nit is also possible to create references to objects in storage:\nThis is possible using the `borrow` function of an `AuthAccount`:\n\n- `cadence•fun borrow<T: &Any>(from: StoragePath): T?`\n\n  Returns a reference to an object in storage without removing it from storage.\n  If no object is stored under the given path, the function returns `nil`.\n  If there is an object stored, a reference is returned as an optional.\n\n  `T` is the type parameter for the object type.\n  A type argument for the parameter must be provided explicitly.\n  The type argument must be a reference to any type (`&Any`; `Any` is the supertype of all types).\n  It must be possible to create the given reference type `T` for the stored /  borrowed object.\n  If it is not, the function returns `nil`.\n  The given type does not necessarily need to be exactly the same as the type of the borrowed object.\n\n  The path must be a storage path, i.e., only the domain `storage` is allowed.\n\n```cadence\n// Declare a resource interface named `HasCount`, that has a field `count`\n//\nresource interface HasCount {\n    count: Int\n}\n\n// Declare a resource named `Counter` that conforms to `HasCount`\n//\nresource Counter: HasCount {\n    pub var count: Int\n\n    pub init(count: Int) {\n        self.count = count\n    }\n}\n\n// In this example an authorized account is available through the constant `authAccount`.\n\n// Create a new instance of the resource type `Counter`\n// and save it in the storage of the account.\n//\n// The path `/storage/counter` is used to refer to the stored value.\n// Its identifier `counter` was chosen freely and could be something else.\n//\nauthAccount.save(<-create Counter(count: 42), to: /storage/counter)\n\n// Create a reference to the object stored under path `/storage/counter`,\n// typed as `&Counter`.\n//\n// `counterRef` has type `&Counter?` and is a valid reference, i.e. non-`nil`,\n// because the borrow succeeded:\n//\n// There is an object stored under path `/storage/counter`\n// and it has type `Counter`, so it can be borrowed as `&Counter`\n//\nlet counterRef = authAccount.borrow<&Counter>(from: /storage/counter)\n\ncounterRef?.count // is `42`\n\n// Create a reference to the object stored under path `/storage/counter`,\n// typed as `&{HasCount}`.\n//\n// `hasCountRef` is non-`nil`, as there is an object stored under path `/storage/counter`,\n// and the stored value of type `Counter` conforms to the requested type `{HasCount}`:\n// the type `Counter` implements the restricted type's restriction `HasCount`\n\nlet hasCountRef = authAccount.borrow<&{HasCount}>(from: /storage/counter)\n\n// Create a reference to the object stored under path `/storage/counter`,\n// typed as `&{SomethingElse}`.\n//\n// `otherRef` is `nil`, as there is an object stored under path `/storage/counter`,\n// but the stored value of type `Counter` does not conform to the requested type `{Other}`:\n// the type `Counter` does not implement the restricted type's restriction `Other`\n\nlet otherRef = authAccount.borrow<&{Other}>(from: /storage/counter)\n\n// Create a reference to the object stored under path `/storage/nonExistent`,\n// typed as `&{HasCount}`.\n//\n// `nonExistentRef` is `nil`, as there is nothing stored under path `/storage/nonExistent`\n//\nlet nonExistentRef = authAccount.borrow<&{HasCount}>(from: /storage/nonExistent)\n```\n\n## Storage limit\n\nAccounts storage is limited by its storage capacity.\n\nAt the end of every transaction all accounts storage used is compared to their storage capacity.\nIf for any account its storage used is greater than its storage capacity the transaction fails.\n\nAn account's storage used and storage capacity can be checked using the `storageUsed` and `storageCapacity` fields.\nThe fields represent current values of storage which means this would be true:\n\n```cadence\nlet storageUsedBefore = authAccount.storageUsed\nauthAccount.save(<-create Counter(count: 123), to: /storage/counter)\nlet storageUsedAfter = authAccount.storageUsed\n\nlet storageUsedChanged = storageUsedBefore != storageUsedAfter // is true\n```\n\n","path":"language/accounts"},{"content":"---\ntitle: Built-in Functions\n---\n\n- `cadence•fun panic(_ message: String): Never`\n\n  Terminates the program unconditionally\n  and reports a message which explains why the unrecoverable error occurred.\n\n  ```cadence\n  let optionalAccount: Account? = // ...\n  let account = optionalAccount ?? panic(\"missing account\")\n  ```\n\n- `cadence•fun assert(_ condition: Bool, message: String)`\n\n  Terminates the program if the given condition is false,\n  and reports a message which explains how the condition is false.\n  Use this function for internal sanity checks.\n\n  The message argument is optional.\n\n- `cadence•fun unsafeRandom(): UInt64`\n\n  Returns a pseudo-random number.\n\n  NOTE: The use of this function is unsafe if not used correctly.\n\n  Follow [best practices](https://github.com/ConsenSys/smart-contract-best-practices/blob/051ec2e42a66f4641d5216063430f177f018826e/docs/recommendations.md#remember-that-on-chain-data-is-public)\n  to prevent security issues when using this function.\n","path":"language/built-in-functions"},{"content":"---\ntitle: Capability-based Access Control\n---\n\nUsers will often want to make it so that specific other users or even anyone else\ncan access certain fields and functions of a stored object.\nThis can be done by creating a capability.\n\nAs was mentioned before, access to stored objects is governed by the\ntenets of [Capability Security](https://en.wikipedia.org/wiki/Capability-based_security).\nThis means that if an account wants to be able to access another account's\nstored objects, it must have a valid capability to that object.\n\nCapabilities are identified by a path and link to a target path, not directly to an object.\nCapabilities are either public (any user can get access),\nor private (access to/from the authorized user is necessary).\n\nPublic capabilities are created using public paths, i.e. they have the domain `public`.\nAfter creation they can be obtained from both authorized accounts (`AuthAccount`)\nand public accounts (`PublicAccount`).\n\nPrivate capabilities are created using private paths, i.e. they have the domain `private`.\nAfter creation they can be obtained from authorized accounts (`AuthAccount`),\nbut not from public accounts (`PublicAccount`).\n\nOnce a capability is created and obtained, it can be borrowed to get a reference\nto the stored object.\nWhen a capability is created, a type is specified that determines as what type\nthe capability can be borrowed.\nThis allows exposing and hiding certain functionality of a stored object.\n\nCapabilities are created using the `link` function of an authorized account (`AuthAccount`):\n\n- `cadence•fun link<T: &Any>(_ newCapabilityPath: CapabilityPath, target: Path): Capability<T>?`\n\n  `newCapabilityPath` is the public or private path identifying the new capability.\n\n  `target` is any public, private, or storage path that leads to the object\n  that will provide the functionality defined by this capability.\n\n  `T` is the type parameter for the capability type.\n  A type argument for the parameter must be provided explicitly.\n\n  The type parameter defines how the capability can be borrowed,\n  i.e., how the stored value can be accessed.\n\n  The link function returns `nil` if a link for the given capability path already exists,\n  or the newly created capability if not.\n\n  It is not necessary for the target path to lead to a valid object;\n  the target path could be empty, or could lead to an object\n  which does not provide the necessary type interface:\n\n  The link function does **not** check if the target path is valid/exists at the time\n  the capability is created and does **not** check if the target value conforms to the given type.\n\n  The link is latent.\n  The target value might be stored after the link is created,\n  and the target value might be moved out after the link has been created.\n\nCapabilities can be removed using the `unlink` function of an authorized account (`AuthAccount`):\n\n- `cadence•fun unlink(_ path: CapabilityPath)`\n\n  `path` is the public or private path identifying the capability that should be removed.\n\nTo get the target path for a capability, the `getLinkTarget` function\nof an authorized account (`AuthAccount`) or public account (`PublicAccount`) can be used:\n\n- `cadence•fun getLinkTarget(_ path: CapabilityPath): Path?`\n\n  `path` is the public or private path identifying the capability.\n  The function returns the link target path,\n  if a capability exists at the given path,\n  or `nil` if it does not.\n\nExisting capabilities can be obtained by using the `getCapability` function\nof authorized accounts (`AuthAccount`) and public accounts (`PublicAccount`):\n\n- `cadence•fun getCapability<T>(_ at: CapabilityPath): Capability<T>`\n\n  For public accounts, the function returns a capability\n  if the given path is public.\n  It is not possible to obtain private capabilities from public accounts.\n  If the path is private or a storage path, the function returns `nil`.\n\n  For authorized accounts, the function returns a capability\n  if the given path is public or private.\n  If the path is a storage path, the function returns `nil`.\n\n  `T` is the type parameter that specifies how the capability can be borrowed.\n  The type argument is optional, i.e. it need not be provided.\n\nThe `getCapability` function does **not** check if the target exists.\nThe link is latent.\nThe `check` function of the capability can be used to check if the target currently exists and could be borrowed,\n\n- `cadence•fun check<T: &Any>(): Bool`\n\n  `T` is the type parameter for the reference type.\n  A type argument for the parameter must be provided explicitly.\n\n  The function returns true if the capability currently targets an object\n  that satisfies the given type, i.e. could be borrowed using the given type.\n\nFinally, the capability can be borrowed to get a reference to the stored object.\nThis can be done using the `borrow` function of the capability:\n\n- `cadence•fun borrow<T: &Any>(): T?`\n\n  The function returns a reference to the object targeted by the capability,\n  provided it can be borrowed using the given type.\n\n  `T` is the type parameter for the reference type.\n  If the function is called on a typed capability, the capability's type is used when borrowing.\n  If the capability is untyped, a type argument must be provided explicitly in the call to `borrow`.\n\n  The function returns `nil` when the targeted path is empty, i.e. nothing is stored under it,\n  and when the requested type exceeds what is allowed by the capability (or any interim capabilities).\n\n```cadence\n// Declare a resource interface named `HasCount`, that has a field `count`\n//\nresource interface HasCount {\n    count: Int\n}\n\n// Declare a resource named `Counter` that conforms to `HasCount`\n//\nresource Counter: HasCount {\n    pub var count: Int\n\n    pub init(count: Int) {\n        self.count = count\n    }\n}\n\n// In this example an authorized account is available through the constant `authAccount`.\n\n// Create a new instance of the resource type `Counter`\n// and save it in the storage of the account.\n//\n// The path `/storage/counter` is used to refer to the stored value.\n// Its identifier `counter` was chosen freely and could be something else.\n//\nauthAccount.save(<-create Counter(count: 42), to: /storage/counter)\n\n// Create a public capability that allows access to the stored counter object\n// as the type `{HasCount}`, i.e. only the functionality of reading the field\n//\nauthAccount.link<&{HasCount}>(/public/hasCount, target: /storage/counter)\n```\n\nTo get the published portion of an account, the `getAccount` function can be used.\n\nImagine that the next example is from a different account as before.\n\n```cadence\n\n// Get the public account for the address that stores the counter\n//\nlet publicAccount = getAccount(0x42)\n\n// Get a capability for the counter that is made publicly accessible\n// through the path `/public/hasCount`.\n//\n// Use the type `&{HasCount}`, a reference to some object that provides the functionality\n// of interface `HasCount`. This is the type that the capability can be borrowed as\n// (it was specified in the call to `link` above).\n// See the example below for borrowing using the type `&Counter`.\n//\n// After the call, the declared constant `countCap` has type `Capability<&{HasCount}>`,\n// a capability that results in a reference that has type `&{HasCount}` when borrowed.\n//\nlet countCap = publicAccount.getCapability<&{HasCount}>(/public/hasCount)\n\n// Borrow the capability to get a reference to the stored counter.\n//\n// This borrow succeeds, i.e. the result is not `nil`,\n// it is a valid reference, because:\n//\n// 1. Dereferencing the path chain results in a stored object\n//    (`/public/hasCount` links to `/storage/counter`,\n//    and there is an object stored under `/storage/counter`)\n//\n// 2. The stored value is a subtype of the requested type `{HasCount}`\n//    (the stored object has type `Counter` which conforms to interface `HasCount`)\n//\nlet countRef = countCap.borrow()!\n\ncountRef.count  // is `43`\n\n// Invalid: The `increment` function is not accessible for the reference,\n// because it has the type `&{HasCount}`\n//\ncountRef.increment()\n\n// Again, attempt to get a get a capability for the counter, but use the type `&Counter`.\n//\n// Getting the capability succeeds, because it is latent, but borrowing fails\n// (the result s `nil`), because the capability was created/linked using the type `&{HasCount}`:\n//\n// The resource type `Counter` implements the resource interface `HasCount`,\n// so `Counter` is a subtype of `{HasCount}`, but the capability only allows\n// borrowing using unauthorized references of `{HasCount}` (`&{HasCount}`)\n// instead of authorized references (`auth &{HasCount}`),\n// so users of the capability are not allowed to borrow using subtypes,\n// and they can't escalate the type by casting the reference either.\n//\n// This shows how parts of the functionality of stored objects\n// can be safely exposed to other code\n//\nlet counterRef = countCap.borrow()\n\n// `counterRef` is `nil`\n\n// Invalid: Cannot access the counter object in storage directly,\n// the `borrow` function is not available for public accounts\n//\nlet counterRef2 = publicAccount.borrow<&Counter>(/storage/counter)\n```\n","path":"language/capability-based-access-control"},{"content":"---\ntitle: Composite Types\n---\n\nComposite types allow composing simpler types into more complex types,\ni.e., they allow the composition of multiple values into one.\nComposite types have a name and consist of zero or more named fields,\nand zero or more functions that operate on the data.\nEach field may have a different type.\n\nComposite types can only be declared within a [contract](../contracts) and nowhere else.\n\nThere are two kinds of composite types.\nThe kinds differ in their usage and the behaviour\nwhen a value is used as the initial value for a constant or variable,\nwhen the value is assigned to a variable,\nwhen the value is passed as an argument to a function,\nand when the value is returned from a function:\n\n- [**Structures**](#structures) are **copied**, they are value types.\n\n    Structures are useful when copies with independent state are desired.\n\n- [**Resources**](#resources) are **moved**, they are linear types and **must** be used **exactly once**.\n\n    Resources are useful when it is desired to model ownership\n    (a value exists exactly in one location and it should not be lost).\n\n    Certain constructs in a blockchain represent assets of real, tangible value,\n    as much as a house or car or bank account.\n    We have to worry about literal loss and theft,\n    perhaps even on the scale of millions of dollars.\n\n    Structures are not an ideal way to represent this ownership because they are copied.\n    This would mean that there could be a risk of having multiple copies\n    of certain assets floating around,\n    which breaks the scarcity requirements needed for these assets to have real value.\n\n    A structure is much more useful for representing information\n    that can be grouped together in a logical way,\n    but doesn't have value or a need to be able to be owned or transferred.\n\n    A structure could for example be used to contain the information associated\n    with a division of a company,\n    but a resource would be used to represent the assets that have been allocated\n    to that organization for spending.\n\nNesting of resources is only allowed within other resource types,\nor in data structures like arrays and dictionaries,\nbut not in structures, as that would allow resources to be copied.\n\n## Composite Type Declaration and Creation\n\nStructures are declared using the `struct` keyword\nand resources are declared using the `resource` keyword.\nThe keyword is followed by the name.\n\n```cadence\npub struct SomeStruct {\n    // ...\n}\n\npub resource SomeResource {\n    // ...\n}\n```\n\nStructures and resources are types.\n\nStructures are created (instantiated) by calling the type like a function.\n\n```cadence\n// instantiate a new struct object and assign it to a constant\nlet a = SomeStruct()\n```\n\nThe constructor function may require parameters if the [initializer](#composite-type-fields)\nof the composite type requires them.\n\nComposite types can only be declared within [contracts](../contracts)\nand not locally in functions.\nThey can also not be nested.\n\nResource must be created (instantiated) by using the `create` keyword\nand calling the type like a function.\n\nResources can only be created in functions and types\nthat are declared in the same contract in which the resource is declared.\n\n```cadence\n// instantiate a new resource object and assign it to a constant\nlet b <- create SomeResource()\n```\n\n## Composite Type Fields\n\nFields are declared like variables and constants.\nHowever, the initial values for fields are set in the initializer,\n**not** in the field declaration.\nAll fields **must** be initialized in the initializer, exactly once.\n\nHaving to provide initial values in the initializer might seem restrictive,\nbut this ensures that all fields are always initialized in one location, the initializer,\nand the initialization order is clear.\n\nThe initialization of all fields is checked statically\nand it is invalid to not initialize all fields in the initializer.\nAlso, it is statically checked that a field is definitely initialized before it is used.\n\nThe initializer's main purpose is to initialize fields, though it may also contain other code.\nJust like a function, it may declare parameters and may contain arbitrary code.\nHowever, it has no return type, i.e., it is always `Void`.\n\nThe initializer is declared using the `init` keyword.\n\nThe initializer always follows any fields.\n\nThere are three kinds of fields:\n\n- **Constant fields** are also stored in the composite value,\n    but after they have been initialized with a value\n    they **cannot** have new values assigned to them afterwards.\n    A constant field must be initialized exactly once.\n\n    Constant fields are declared using the `let` keyword.\n\n- **Variable fields** are stored in the composite value\n    and can have new values assigned to them.\n\n    Variable fields are declared using the `var` keyword.\n\n- **Synthetic fields** are **not stored** in the composite value,\n    i.e. they are derived/computed from other values.\n    They can have new values assigned to them.\n\n    Synthetic fields are declared using the `synthetic` keyword.\n\n    Synthetic fields must have a getter and a setter.\n    Getters and setters are explained in the\n    [next section](#composite-type-field-getters-and-setters).\n    Synthetic fields are explained in a [separate section](#synthetic-composite-type-fields).\n\n| Field Kind           | Stored in memory | Assignable         | Keyword     |\n|----------------------|------------------|--------------------|-------------|\n| **Variable field**   | Yes              | Yes                | `var`       |\n| **Constant field**   | Yes              | **No**             | `let`       |\n| **Synthetic field**  | **No**           | Yes                | `synthetic` |\n\nIn initializers, the special constant `self` refers to the composite value\nthat is to be initialized.\n\nField types must be storable. Non-storable types are:\n\n- Functions\n- [Accounts (`AuthAccount` / `PublicAccount`)](../accounts)\n- [Transactions](../transactions)\n- [References](../references): References are ephemeral.\n  Consider [storing a capability and borrowing it](../capability-based-access-control) when needed instead.\n\nFields can be read (if they are constant or variable) and set (if they are variable),\nusing the access syntax: the composite value is followed by a dot (`.`)\nand the name of the field.\n\n```cadence\n// Declare a structure named `Token`, which has a constant field\n// named `id` and a variable field named `balance`.\n//\n// Both fields are initialized through the initializer.\n//\n// The public access modifier `pub` is used in this example to allow\n// the fields to be read in outer scopes. Fields can also be declared\n// private so they cannot be accessed in outer scopes.\n// Access control will be explained in a later section.\n//\npub struct Token {\n    pub let id: Int\n    pub var balance: Int\n\n    init(id: Int, balance: Int) {\n        self.id = id\n        self.balance = balance\n    }\n}\n```\n\nNote that it is invalid to provide the initial value for a field in the field declaration.\n\n```cadence\npub struct StructureWithConstantField {\n    // Invalid: It is invalid to provide an initial value in the field declaration.\n    // The field must be initialized by setting the initial value in the initializer.\n    //\n    pub let id: Int = 1\n}\n```\n\nThe field access syntax must be used to access fields –  fields are not available as variables.\n\n```cadence\npub struct Token {\n    pub let id: Int\n\n    init(initialID: Int) {\n        // Invalid: There is no variable with the name `id` available.\n        // The field `id` must be initialized by setting `self.id`.\n        //\n        id = initialID\n    }\n}\n```\n\nThe initializer is **not** automatically derived from the fields, it must be explicitly declared.\n\n```cadence\npub struct Token {\n    pub let id: Int\n\n    // Invalid: Missing initializer initializing field `id`.\n}\n```\n\nA composite value can be created by calling the constructor and providing\nthe field values as arguments.\n\nThe value's fields can be accessed on the object after it is created.\n\n```cadence\nlet token = Token(id: 42, balance: 1_000_00)\n\ntoken.id  // is `42`\ntoken.balance  // is `1_000_000`\n\ntoken.balance = 1\n// `token.balance` is `1`\n\n// Invalid: assignment to constant field\n//\ntoken.id = 23\n```\n\n## Resource Owner\n\nResources have the implicit field `let owner: PublicAccount?`.\nIf the resource is currently [stored in an account](../accounts#account-storage),\nthen the field contains the publicly accessible portion of the account.\nOtherwise the field is `nil`.\n\nThe field's value changes when the resource is moved from outside account storage\ninto account storage, when it is moved from the storage of one account\nto the storage of another account, and when it is moved out of account storage.\n\n## Composite Data Initializer Overloading\n\n<Callout type=\"info\">\n\n🚧 Status: Initializer overloading is not implemented yet.\n\n</Callout>\n\nInitializers support overloading.\nThis allows for example providing default values for certain parameters.\n\n```cadence\n// Declare a structure named `Token`, which has a constant field\n// named `id` and a variable field named `balance`.\n//\n// The first initializer allows initializing both fields with a given value.\n//\n// A second initializer is provided for convenience to initialize the `id` field\n// with a given value, and the `balance` field with the default value `0`.\n//\npub struct Token {\n    let id: Int\n    var balance: Int\n\n    init(id: Int, balance: Int) {\n        self.id = id\n        self.balance = balance\n    }\n\n    init(id: Int) {\n        self.id = id\n        self.balance = 0\n    }\n}\n```\n\n## Composite Type Field Getters and Setters\n\n<Callout type=\"info\">\n\n🚧 Status: Field getters and setters are not implemented yet.\n\n</Callout>\n\nFields may have an optional getter and an optional setter.\nGetters are functions that are called when a field is read,\nand setters are functions that are called when a field is written.\nOnly certain assignments are allowed in getters and setters.\n\nGetters and setters are enclosed in opening and closing braces, after the field's type.\n\nGetters are declared using the `get` keyword.\nGetters have no parameters and their return type is implicitly the type of the field.\n\n```cadence\npub struct GetterExample {\n\n    // Declare a variable field named `balance` with a getter\n    // which ensures the read value is always non-negative.\n    //\n    pub var balance: Int {\n        get {\n           if self.balance < 0 {\n               return 0\n           }\n\n           return self.balance\n        }\n    }\n\n    init(balance: Int) {\n        self.balance = balance\n    }\n}\n\nlet example = GetterExample(balance: 10)\n// `example.balance` is `10`\n\nexample.balance = -50\n// The stored value of the field `example` is `-50` internally,\n// though `example.balance` is `0` because the getter for `balance` returns `0` instead.\n```\n\nSetters are declared using the `set` keyword,\nfollowed by the name for the new value enclosed in parentheses.\nThe parameter has implicitly the type of the field.\nAnother type cannot be specified. Setters have no return type.\n\nThe types of values assigned to setters must always match the field's type.\n\n```cadence\npub struct SetterExample {\n\n    // Declare a variable field named `balance` with a setter\n    // which requires written values to be positive.\n    //\n    pub var balance: Int {\n        set(newBalance) {\n            pre {\n                newBalance >= 0\n            }\n            self.balance = newBalance\n        }\n    }\n\n    init(balance: Int) {\n        self.balance = balance\n    }\n}\n\nlet example = SetterExample(balance: 10)\n// `example.balance` is `10`\n\n// Run-time error: The precondition of the setter for the field `balance` fails,\n// the program aborts.\n//\nexample.balance = -50\n```\n\n## Synthetic Composite Type Fields\n\n<Callout type=\"info\">\n\n🚧 Status: Synthetic fields are not implemented yet.\n\n</Callout>\n\nFields which are not stored in the composite value are *synthetic*,\ni.e., the field value is computed.\nSynthetic can be either read-only, or readable and writable.\n\nSynthetic fields are declared using the `synthetic` keyword.\n\nSynthetic fields are read-only when only a getter is provided.\n\n```cadence\nstruct Rectangle {\n    pub var width: Int\n    pub var height: Int\n\n    // Declare a synthetic field named `area`,\n    // which computes the area based on the `width` and `height` fields.\n    //\n    pub synthetic area: Int {\n        get {\n            return width * height\n        }\n    }\n\n    // Declare an initializer which accepts width and height.\n    // As `area` is synthetic and there is only a getter provided for it,\n    // the `area` field cannot be assigned a value.\n    //\n    init(width: Int, height: Int) {\n        self.width = width\n        self.height = height\n    }\n}\n```\n\nSynthetic fields are readable and writable when both a getter and a setter is declared.\n\n```cadence\n// Declare a struct named `GoalTracker` which stores a number\n// of target goals, a number of completed goals,\n// and has a synthetic field to provide the left number of goals.\n//\n// NOTE: the tracker only implements some functionality to demonstrate\n// synthetic fields, it is incomplete (e.g. assignments to `goal` are not handled properly).\n//\npub struct GoalTracker {\n\n    pub var goal: Int\n    pub var completed: Int\n\n    // Declare a synthetic field which is both readable and writable.\n    //\n    // When the field is read from (in the getter), the number\n    // of left goals is computed from the target number of goals\n    // and the completed number of goals.\n    //\n    // When the field is written to (in the setter), the number\n    // of completed goals is updated, based on the number\n    // of target goals and the new remaining number of goals.\n    //\n    pub synthetic left: Int {\n        get {\n            return self.goal - self.completed\n        }\n\n        set(newLeft) {\n            self.completed = self.goal - newLeft\n        }\n    }\n\n    init(goal: Int, completed: Int) {\n        self.goal = goal\n        self.completed = completed\n    }\n}\n\nlet tracker = GoalTracker(goal: 10, completed: 0)\n// `tracker.goal` is `10`\n// `tracker.completed` is `0`\n// `tracker.left` is `10`\n\ntracker.completed = 1\n// `tracker.left` is `9`\n\ntracker.left = 8\n// `tracker.completed` is `2`\n```\n\nIt is invalid to declare a synthetic field with only a setter.\n\n## Composite Type Functions\n\n<Callout type=\"info\">\n\n🚧 Status: Function overloading is not implemented yet.\n\n</Callout>\n\nComposite types may contain functions.\nJust like in the initializer, the special constant `self` refers to the composite value\nthat the function is called on.\n\n```cadence\n// Declare a structure named \"Rectangle\", which represents a rectangle\n// and has variable fields for the width and height.\n//\npub struct Rectangle {\n    pub var width: Int\n    pub var height: Int\n\n    init(width: Int, height: Int) {\n        self.width = width\n        self.height = height\n    }\n\n    // Declare a function named \"scale\", which scales\n    // the rectangle by the given factor.\n    //\n    pub fun scale(factor: Int) {\n        self.width = self.width * factor\n        self.height = self.height * factor\n    }\n}\n\nlet rectangle = Rectangle(width: 2, height: 3)\nrectangle.scale(factor: 4)\n// `rectangle.width` is `8`\n// `rectangle.height` is `12`\n```\n\nFunctions support overloading.\n\n```cadence\n// Declare a structure named \"Rectangle\", which represents a rectangle\n// and has variable fields for the width and height.\n//\npub struct Rectangle {\n    pub var width: Int\n    pub var height: Int\n\n    init(width: Int, height: Int) {\n        self.width = width\n        self.height = height\n    }\n\n    // Declare a function named \"scale\", which independently scales\n    // the width by a given factor and the height by a given factor.\n    //\n    pub fun scale(widthFactor: Int, heightFactor: Int) {\n        self.width = self.width * widthFactor\n        self.height = self.height * heightFactor\n    }\n\n    // Declare another function also named \"scale\", which scales\n    // both width and height by a given factor.\n    // The function calls the `scale` function declared above.\n    //\n    pub fun scale(factor: Int) {\n        self.scale(\n            widthFactor: factor,\n            heightFactor: factor\n        )\n    }\n}\n```\n\n## Composite Type Subtyping\n\nTwo composite types are compatible if and only if they refer to the same declaration by name,\ni.e., nominal typing applies instead of structural typing.\n\nEven if two composite types declare the same fields and functions,\nthe types are only compatible if their names match.\n\n```cadence\n// Declare a structure named `A` which has a function `test`\n// which has type `((): Void)`.\n//\nstruct A {\n    fun test() {}\n}\n\n// Declare a structure named `B` which has a function `test`\n// which has type `((): Void)`.\n//\nstruct B {\n    fun test() {}\n}\n\n// Declare a variable named which accepts values of type `A`.\n//\nvar something: A = A()\n\n// Invalid: Assign a value of type `B` to the variable.\n// Even though types `A` and `B` have the same declarations,\n// a function with the same name and type, the types' names differ,\n// so they are not compatible.\n//\nsomething = B()\n\n// Valid: Reassign a new value of type `A`.\n//\nsomething = A()\n```\n\n## Composite Type Behaviour\n\n### Structures\n\nStructures are **copied** when\nused as an initial value for constant or variable,\nwhen assigned to a different variable,\nwhen passed as an argument to a function,\nand when returned from a function.\n\nAccessing a field or calling a function of a structure does not copy it.\n\n```cadence\n// Declare a structure named `SomeStruct`, with a variable integer field.\n//\npub struct SomeStruct {\n    pub var value: Int\n\n    init(value: Int) {\n        self.value = value\n    }\n\n    fun increment() {\n        self.value = self.value + 1\n    }\n}\n\n// Declare a constant with value of structure type `SomeStruct`.\n//\nlet a = SomeStruct(value: 0)\n\n// *Copy* the structure value into a new constant.\n//\nlet b = a\n\nb.value = 1\n// NOTE: `b.value` is 1, `a.value` is *`0`*\n\nb.increment()\n// `b.value` is 2, `a.value` is `0`\n```\n\n### Accessing Fields and Functions of Composite Types Using Optional Chaining\n\nIf a composite type with fields and functions is wrapped in an optional,\noptional chaining can be used to get those values or call the function without\nhaving to get the value of the optional first.\n\nOptional chaining is used by adding a `?`\nbefore the `.` access operator for fields or\nfunctions of an optional composite type.\n\nWhen getting a field value or\ncalling a function with a return value, the access returns\nthe value as an optional.\nIf the object doesn't exist, the value will always be `nil`\n\nWhen calling a function on an optional like this, if the object doesn't exist,\nnothing will happen and the execution will continue.\n\nIt is still invalid to access an undeclared field\nof an optional composite type.\n\n```cadence\n// Declare a struct with a field and method.\npub struct Value {\n    pub var number: Int\n\n    init() {\n        self.number = 2\n    }\n\n    pub fun set(new: Int) {\n        self.number = new\n    }\n\n    pub fun setAndReturn(new: Int): Int {\n        self.number = new\n        return new\n    }\n}\n\n// Create a new instance of the struct as an optional\nlet value: Value? = Value()\n// Create another optional with the same type, but nil\nlet noValue: Value? = nil\n\n// Access the `number` field using optional chaining\nlet twoOpt = value?.number\n// Because `value` is an optional, `twoOpt` has type `Int?`\nlet two = zeroOpt ?? 0\n// `two` is `2`\n\n// Try to access the `number` field of `noValue`, which has type `Value?`\n// This still returns an `Int?`\nlet nilValue = noValue?.number\n// This time, since `noValue` is `nil`, `nilValue` will also be `nil`\n\n// Call the `set` function of the struct\n// whether or not the object exists, this will not fail\nvalue?.set(new: 4)\nnoValue?.set(new: 4)\n\n// Call the `setAndReturn` function, which returns an `Int`\n// Because `value` is an optional, the return value is type `Int?`\nlet sixOpt = value?.setAndReturn(new: 6)\nlet six = sixOpt ?? 0\n// `six` is `6`\n```\n\nThis is also possible by using the force-unwrap operator (`!`).\n\nForced-Optional chaining is used by adding a `!`\nbefore the `.` access operator for fields or\nfunctions of an optional composite type.\n\nWhen getting a field value or calling a function with a return value,\nthe access returns the value.\nIf the object doesn't exist, the execution will panic and revert.\n\nIt is still invalid to access an undeclared field\nof an optional composite type.\n\n```cadence\n// Declare a struct with a field and method.\npub struct Value {\n    pub var number: Int\n\n    init() {\n        self.number = 2\n    }\n\n    pub fun set(new: Int) {\n        self.number = new\n    }\n\n    pub fun setAndReturn(new: Int): Int {\n        self.number = new\n        return new\n    }\n}\n\n// Create a new instance of the struct as an optional\nlet value: Value? = Value()\n// Create another optional with the same type, but nil\nlet noValue: Value? = nil\n\n// Access the `number` field using force-optional chaining\nlet two = value!.number\n// `two` is `2`\n\n// Try to access the `number` field of `noValue`, which has type `Value?`\n// Run-time error: This time, since `noValue` is `nil`,\n// the program execution will revert\nlet number = noValue!.number\n\n// Call the `set` function of the struct\n\n// This succeeds and sets the value to 4\nvalue!.set(new: 4)\n\n// Run-time error: Since `noValue` is nil, the value is not set\n// and the program execution reverts.\nnoValue!.set(new: 4)\n\n// Call the `setAndReturn` function, which returns an `Int`\n// Because we use force-unwrap before calling the function,\n// the return value is type `Int`\nlet six = value!.setAndReturn(new: 6)\n// `six` is `6`\n```\n\n### Resources\n\nResources are types that can only exist in **one** location at a time\nand **must** be used **exactly once**.\n\nResources **must** be created (instantiated) by using the `create` keyword.\n\nAt the end of a function which has resources (variables, constants, parameters) in scope,\nthe resources **must** be either **moved** or **destroyed**.\n\nThey are **moved** when used as an initial value for a constant or variable,\nwhen assigned to a different variable,\nwhen passed as an argument to a function,\nand when returned from a function.\n\nResources can be explicitly **destroyed** using the `destroy` keyword.\n\nAccessing a field or calling a function of a resource does not move or destroy it.\n\nWhen the resource is moved, the constant or variable\nthat referred to the resource before the move becomes **invalid**.\nAn **invalid** resource cannot be used again.\n\nTo make the usage and behaviour of resource types explicit,\nthe prefix `@` must be used in type annotations\nof variable or constant declarations, parameters, and return types.\n\nTo make moves of resources explicit, the move operator `<-` must be used\nwhen the resource is the initial value of a constant or variable,\nwhen it is moved to a different variable,\nwhen it is moved to a function as an argument,\nand when it is returned from a function.\n\n```cadence\n// Declare a resource named `SomeResource`, with a variable integer field.\n//\npub resource SomeResource {\n    pub var value: Int\n\n    init(value: Int) {\n        self.value = value\n    }\n}\n\n// Declare a constant with value of resource type `SomeResource`.\n//\nlet a: @SomeResource <- create SomeResource(value: 0)\n\n// *Move* the resource value to a new constant.\n//\nlet b <- a\n\n// Invalid: Cannot use constant `a` anymore as the resource that it referred to\n// was moved to constant `b`.\n//\na.value\n\n// Constant `b` owns the resource.\n//\nb.value // equals 0\n\n// Declare a function which accepts a resource.\n//\n// The parameter has a resource type, so the type annotation must be prefixed with `@`.\n//\npub fun use(resource: @SomeResource) {\n    // ...\n}\n\n// Call function `use` and move the resource into it.\n//\nuse(resource: <-b)\n\n// Invalid: Cannot use constant `b` anymore as the resource\n// it referred to was moved into function `use`.\n//\nb.value\n```\n\nA resource object cannot go out of scope and be dynamically lost.\nThe program must either explicitly destroy it or move it to another context.\n\n```cadence\n{\n    // Declare another, unrelated value of resource type `SomeResource`.\n    //\n    let c <- create SomeResource(value: 10)\n\n    // Invalid: `c` is not used before the end of the scope, but must be.\n    // It cannot be lost.\n}\n```\n\n```cadence\n// Declare another, unrelated value of resource type `SomeResource`.\n//\nlet d <- create SomeResource(value: 20)\n\n// Destroy the resource referred to by constant `d`.\n//\ndestroy d\n\n// Invalid: Cannot use constant `d` anymore as the resource\n// it referred to was destroyed.\n//\nd.value\n```\n\nTo make it explicit that the type is a resource type\nand must follow the rules associated with resources,\nit must be prefixed with `@` in all type annotations,\ne.g. for variable declarations, parameters, or return types.\n\n```cadence\n// Declare a constant with an explicit type annotation.\n//\n// The constant has a resource type, so the type annotation must be prefixed with `@`.\n//\nlet someResource: @SomeResource <- create SomeResource(value: 5)\n\n// Declare a function which consumes a resource and destroys it.\n//\n// The parameter has a resource type, so the type annotation must be prefixed with `@`.\n//\npub fun use(resource: @SomeResource) {\n    destroy resource\n}\n\n// Declare a function which returns a resource.\n//\n// The return type is a resource type, so the type annotation must be prefixed with `@`.\n// The return statement must also use the `<-` operator to make it explicit the resource is moved.\n//\npub fun get(): @SomeResource {\n    let newResource <- create SomeResource()\n    return <-newResource\n}\n```\n\nResources **must** be used exactly once.\n\n```cadence\n// Declare a function which consumes a resource but does not use it.\n// This function is invalid, because it would cause a loss of the resource.\n//\npub fun forgetToUse(resource: @SomeResource) {\n    // Invalid: The resource parameter `resource` is not used, but must be.\n}\n```\n\n```cadence\n// Declare a constant named `res` which has the resource type `SomeResource`.\nlet res <- create SomeResource()\n\n// Call the function `use` and move the resource `res` into it.\nuse(resource: <-res)\n\n// Invalid: The resource constant `res` cannot be used again,\n// as it was moved in the previous function call.\n//\nuse(resource: <-res)\n\n// Invalid: The resource constant `res` cannot be used again,\n// as it was moved in the previous function call.\n//\nres.value\n```\n\n```cadence\n// Declare a function which has a resource parameter.\n// This function is invalid, because it does not always use the resource parameter,\n// which would cause a loss of the resource.\n//\npub fun sometimesDestroy(resource: @SomeResource, destroy: Bool) {\n    if destroyResource {\n        destroy resource\n    }\n    // Invalid: The resource parameter `resource` is not always used, but must be.\n    // The destroy statement is not always executed, so at the end of this function\n    // it might have been destroyed or not.\n}\n```\n\n```cadence\n// Declare a function which has a resource parameter.\n// This function is valid, as it always uses the resource parameter,\n// and does not cause a loss of the resource.\n//\npub fun alwaysUse(resource: @SomeResource, destroyResource: Bool) {\n    if destroyResource {\n        destroy resource\n    } else {\n        use(resource: <-resource)\n    }\n    // At the end of the function the resource parameter was definitely used:\n    // It was either destroyed or moved in the call of function `use`.\n}\n```\n\n```cadence\n// Declare a function which has a resource parameter.\n// This function is invalid, because it does not always use the resource parameter,\n// which would cause a loss of the resource.\n//\npub fun returnBeforeDestroy(move: Bool) {\n    let res <- create SomeResource(value: 1)\n    if move {\n        use(resource: <-res)\n        return\n    } else {\n        // Invalid: When this function returns here, the resource variable\n        // `res` was not used, but must be.\n        return\n    }\n    // Invalid: the resource variable `res` was potentially moved in the\n    // previous if-statement, and both branches definitely return,\n    // so this statement is unreachable.\n    destroy res\n}\n```\n\n### Resource Variables\n\nResource variables cannot be assigned to,\nas that would lead to the loss of the variable's current resource value.\n\nInstead, use a swap statement (`<->`) or shift statement (`<- target <-`)\nto replace the resource variable with another resource.\n\n```cadence\npub resource R {}\n\nvar x <- create R()\nvar y <- create R()\n\n// Invalid: Cannot assign to resource variable `x`,\n// as its current resource would be lost\n//\nx <- y\n\n// Instead, use a swap statement.\n//\nvar replacement <- create R()\nx <-> replacement\n// `x` is the new resource.\n// `replacement` is the old resource.\n\n// Or use the shift statement (`<- target <-`)\n// This statement moves the resource out of `x` and into `oldX`,\n// and at the same time assigns `x` with the new value on the right-hand side.\nlet oldX <- x <- create R()\n// oldX still needs to be explicitly handled after this statement\ndestroy oldX\n```\n\n### Resource Destructors\n\nResource may have a destructor, which is executed when the resource is destroyed.\nDestructors have no parameters and no return value and are declared using the `destroy` name.\nA resource may have only one destructor.\n\n```cadence\nvar destructorCalled = false\n\npub resource Resource {\n\n    // Declare a destructor for the resource, which is executed\n    // when the resource is destroyed.\n    //\n    destroy() {\n        destructorCalled = true\n    }\n}\n\nlet res <- create Resource()\ndestroy res\n// `destructorCalled` is `true`\n```\n\n### Nested Resources\n\nFields in composite types behave differently when they have a resource type.\n\nIf a resource type has fields that have a resource type,\nit **must** declare a destructor,\nwhich **must** invalidate all resource fields, i.e. move or destroy them.\n\n```cadence\npub resource Child {\n    let name: String\n\n    init(name: String)\n        self.name = name\n    }\n}\n\n// Declare a resource with a resource field named `child`.\n// The resource *must* declare a destructor\n// and the destructor *must* invalidate the resource field.\n//\npub resource Parent {\n    let name: String\n    var child: @Child\n\n    init(name: String, child: @Child) {\n        self.name = name\n        self.child <- child\n    }\n\n    // Declare a destructor which invalidates the resource field\n    // `child` by destroying it.\n    //\n    destroy() {\n        destroy self.child\n    }\n}\n```\n\nAccessing a field or calling function on a resource field is valid,\nhowever moving a resource out of a variable resource field is **not** allowed.\nInstead, use a swap statement to replace the resource with another resource.\n\n```cadence\nlet child <- create Child(name: \"Child 1\")\nlet parent <- create Parent(name: \"Parent\", child: <-child)\n\nchild.name  // is \"Child 1\"\nparent.child.name  // is \"Child 1\"\n\n// Invalid: Cannot move resource out of variable resource field.\nlet childAgain <- parent.child\n\n// Instead, use a swap statement.\n//\nvar otherChild <- create Child(name: \"Child 2\")\nparent.child <-> otherChild\n// `parent.child` is the second child, Child 2.\n// `otherChild` is the first child, Child 1.\n```\n\n### Resources in Closures\n\nResources can not be captured in closures, as that could potentially result in duplications.\n\n```cadence\nresource R {}\n\n// Invalid: Declare a function which returns a closure which refers to\n// the resource parameter `resource`. Each call to the returned function\n// would return the resource, which should not be possible.\n//\nfun makeCloner(resource: @R): ((): @R) {\n    return fun (): @R {\n        return <-resource\n    }\n}\n\nlet test = makeCloner(resource: <-create R())\n```\n\n### Resources in Arrays and Dictionaries\n\nArrays and dictionaries behave differently when they contain resources:\nIt is **not** allowed to index into an array to read an element at a certain index or assign to it,\nor index into a dictionary to read a value for a certain key or set a value for the key.\n\nInstead, use a swap statement (`<->`) or shift statement (`<- target <-`)\nto replace the accessed resource with another resource.\n\n```cadence\nresource R {}\n\n// Declare a constant for an array of resources.\n// Create two resources and move them into the array.\n// `resources` has type `@[R]`\n//\nlet resources <- [\n    <-create R(),\n    <-create R()\n]\n\n// Invalid: Reading an element from a resource array is not allowed.\n//\nlet firstResource <- resources[0]\n\n// Invalid: Setting an element in a resource array is not allowed,\n// as it would result in the loss of the current value.\n//\nresources[0] <- create R()\n\n// Instead, when attempting to either read an element or update an element\n// in a resource array, use a swap statement with a variable to replace\n// the accessed element.\n//\nvar res <- create R()\nresources[0] <-> res\n// `resources[0]` now contains the new resource.\n// `res` now contains the old resource.\n\n// Use the shift statement to move the new resource into\n// the array at the same time that the old resource is being moved out\nlet oldRes <- resources[0] <- create R()\n// The old object still needs to be handled\ndestroy oldRes\n```\n\nThe same applies to dictionaries.\n\n```cadence\n// Declare a constant for a dictionary of resources.\n// Create two resources and move them into the dictionary.\n// `resources` has type `@{String: R}`\n//\nlet resources <- {\n    \"r1\": <-create R(),\n    \"r2\": <-create R()\n}\n\n// Invalid: Reading an element from a resource dictionary is not allowed.\n// It's not obvious that an access like this would have to remove\n// the key from the dictionary.\n//\nlet firstResource <- resources[\"r1\"]\n\n// Instead, make the removal explicit by using the `remove` function.\nlet firstResource <- resources.remove(key: \"r1\")\n\n// Invalid: Setting an element in a resource dictionary is not allowed,\n// as it would result in the loss of the current value.\n//\nresources[\"r1\"] <- create R()\n\n// Instead, when attempting to either read an element or update an element\n// in a resource dictionary, use a swap statement with a variable to replace\n// the accessed element.\n//\nvar res <- create R()\nresources[\"r1\"] <-> res\n// `resources[\"r1\"]` now contains the new resource.\n// `res` now contains the old resource.\n\n// Use the shift statement to move the new resource into\n// the dictionary at the same time that the old resource is being moved out\nlet oldRes <- resources[\"r2\"] <- create R()\n// The old object still needs to be handled\ndestroy oldRes\n```\n\nResources cannot be moved into arrays and dictionaries multiple times,\nas that would cause a duplication.\n\n```cadence\nlet resource <- create R()\n\n// Invalid: The resource variable `resource` can only be moved into the array once.\n//\nlet resources <- [\n    <-resource,\n    <-resource\n]\n```\n\n```cadence\nlet resource <- create R()\n\n// Invalid: The resource variable `resource` can only be moved into the dictionary once.\nlet resources <- {\n    \"res1\": <-resource,\n    \"res2\": <-resource\n}\n```\n\nResource arrays and dictionaries can be destroyed.\n\n```cadence\nlet resources <- [\n    <-create R(),\n    <-create R()\n]\ndestroy resources\n```\n\n```cadence\nlet resources <- {\n    \"r1\": <-create R(),\n    \"r2\": <-create R()\n}\ndestroy resources\n```\n\nThe variable array functions like `append`, `insert`, and `remove`\nbehave like for non-resource arrays.\nNote however, that the result of the `remove` functions must be used.\n\n```cadence\nlet resources <- [<-create R()]\n// `resources.length` is `1`\n\nresources.append(<-create R())\n// `resources.length` is `2`\n\nlet first <- resource.remove(at: 0)\n// `resources.length` is `1`\ndestroy first\n\nresources.insert(at: 0, <-create R())\n// `resources.length` is `2`\n\n// Invalid: The statement ignores the result of the call to `remove`,\n// which would result in a loss.\nresource.remove(at: 0)\n\ndestroy resources\n```\n\nThe variable array function `contains` is not available, as it is impossible:\nIf the resource can be passed to the `contains` function,\nit is by definition not in the array.\n\nThe variable array function `concat` is not available,\nas it would result in the duplication of resources.\n\nThe dictionary functions like `insert` and `remove`\nbehave like for non-resource dictionaries.\nNote however, that the result of these functions must be used.\n\n```cadence\nlet resources <- {\"r1\": <-create R()}\n// `resources.length` is `1`\n\nlet first <- resource.remove(key: \"r1\")\n// `resources.length` is `0`\ndestroy first\n\nlet old <- resources.insert(key: \"r1\", <-create R())\n// `old` is nil, as there was no value for the key \"r1\"\n// `resources.length` is `1`\n\nlet old2 <- resources.insert(key: \"r1\", <-create R())\n// `old2` is the old value for the key \"r1\"\n// `resources.length` is `2`\n\ndestroy old\ndestroy old2\ndestroy resources\n```\n\n### Resource Identifier\n\nResources have an implicit unique identifier associated with them,\nimplemented by a predeclared public field `let uuid: UInt64` on each resource.\n\nThis identifier will be automatically set when the resource is created, before the resource's initializer is called\n(i.e. the identifier can be used in the initializer),\nand will be unique even after the resource is destroyed,\ni.e. no two resources will ever have the same identifier.\n\n```cadence\n// Declare a resource without any fields.\nresource R {}\n\n// Create two resources\nlet r1 <- create R()\nlet r2 <- create R()\n\n// Get each resource's unique identifier\nlet id1 = r1.uuid\nlet id2 = r2.uuid\n\n// Destroy the first resource\ndestroy r1\n\n// Create a third resource\nlet r3 <- create R()\n\nlet id3 = r3.uuid\n\nid1 != id2  // true\nid2 != id3  // true\nid3 != id1  // true\n```\n\n<Callout type=\"warning\">\nThe details of how the identifiers are generated is an implementation detail.\n\nDo not rely on or assume any particular behaviour in Cadence programs.\n</Callout>\n\n## Unbound References / Nulls\n\nThere is **no** support for `null`.\n\n## Inheritance and Abstract Types\n\nThere is **no** support for inheritance.\nInheritance is a feature common in other programming languages,\nthat allows including the fields and functions of one type in another type.\n\nInstead, follow the \"composition over inheritance\" principle,\nthe idea of composing functionality from multiple individual parts,\nrather than building an inheritance tree.\n\nFurthermore, there is also **no** support for abstract types.\nAn abstract type is a feature common in other programming languages,\nthat prevents creating values of the type and only\nallows the creation of values of a subtype.\nIn addition, abstract types may declare functions,\nbut omit the implementation of them\nand instead require subtypes to implement them.\n\nInstead, consider using [interfaces](../interfaces).\n","path":"language/composite-types-x"},{"content":"---\ntitle: Constants and Variable Declarations\n---\n\nConstants and variables are declarations that bind\na value and [type](../type-safety) to an identifier.\nConstants are initialized with a value and cannot be reassigned afterwards.\nVariables are initialized with a value and can be reassigned later.\nDeclarations can be created in any scope, including the global scope.\n\nConstant means that the *identifier's* association is constant,\nnot the *value* itself –\nthe value may still be changed if is mutable.\n\nConstants are declared using the `let` keyword. Variables are declared\nusing the `var` keyword.\nThe keywords are followed by the identifier,\nan optional [type annotation](../type-annotations), an equals sign `=`,\nand the initial value.\n\n```cadence\n// Declare a constant named `a`.\n//\nlet a = 1\n\n// Invalid: re-assigning to a constant.\n//\na = 2\n\n// Declare a variable named `b`.\n//\nvar b = 3\n\n// Assign a new value to the variable named `b`.\n//\nb = 4\n```\n\nVariables and constants **must** be initialized.\n\n```cadence\n// Invalid: the constant has no initial value.\n//\nlet a\n```\n\nThe names of the variable or constant\ndeclarations in each scope must be unique.\nDeclaring another variable or constant with a name that is already\ndeclared in the current scope is invalid, regardless of kind or type.\n\n```cadence\n// Declare a constant named `a`.\n//\nlet a = 1\n\n// Invalid: cannot re-declare a constant with name `a`,\n// as it is already used in this scope.\n//\nlet a = 2\n\n// Declare a variable named `b`.\n//\nvar b = 3\n\n// Invalid: cannot re-declare a variable with name `b`,\n// as it is already used in this scope.\n//\nvar b = 4\n\n// Invalid: cannot declare a variable with the name `a`,\n// as it is already used in this scope,\n// and it is declared as a constant.\n//\nvar a = 5\n```\n\nHowever, variables can be redeclared in sub-scopes.\n\n```cadence\n// Declare a constant named `a`.\n//\nlet a = 1\n\nif true {\n    // Declare a constant with the same name `a`.\n    // This is valid because it is in a sub-scope.\n    // This variable is not visible to the outer scope.\n\n    let a = 2\n}\n\n// `a` is `1`\n```\n\nA variable cannot be used as its own initial value.\n\n```cadence\n// Invalid: Use of variable in its own initial value.\nlet a = a\n```\n","path":"language/constants-and-variables"},{"content":"---\ntitle: Contracts\n---\n\nA contract in Cadence is a collection of type definitions\nof interfaces, structs, resources, data (its state), and code (its functions)\nthat lives in the contract storage area of an account in Flow.\n\nContracts are where all composite types like structs, resources,\nevents, and interfaces for these types in Cadence have to be defined.\nTherefore, an object of one of these types cannot exist\nwithout having been defined in a deployed Cadence contract.\n\nContracts can be created, updated, and removed using the `contracts`\nobject of [authorized accounts](../accounts).\nThis functionality is covered in the [next section](#deploying,-updating,-and-removing-contracts)\n\nContracts are types.\nThey are similar to composite types, but are stored differently than\nstructs or resources and cannot be used as values, copied, or moved\nlike resources or structs.\n\nContracts stay in an account's contract storage area\nand can only be added, updated, or removed by the account owner with special commands.\n\nContracts are declared using the `contract` keyword. The keyword is followed\nby the name of the contract.\n\n```cadence\npub contract SomeContract {\n    // ...\n}\n```\n\nContracts cannot be nested in each other.\n\n```cadence\npub contract Invalid {\n\n    // Invalid: Contracts cannot be nested in any other type.\n    //\n    pub contract Nested {\n        // ...\n    }\n}\n```\n\nOne of the simplest forms of a contract would just be one with a state field,\na function, and an `init` function that initializes the field:\n\n```cadence\npub contract HelloWorld {\n\n    // Declare a stored state field in HelloWorld\n    //\n    pub let greeting: String\n\n    // Declare a function that can be called by anyone\n    // who imports the contract\n    //\n    pub fun hello(): String {\n        return self.greeting\n    }\n\n    init() {\n        self.greeting = \"Hello World!\"\n    }\n}\n```\n\nThis contract could be deployed to an account and live permanently\nin the contract storage.  Transactions and other contracts\ncan interact with contracts by importing them at the beginning\nof a transaction or contract definition.\n\nAnyone could call the above contract's `hello` function by importing\nthe contract from the account it was deployed to and using the imported\nobject to call the hello function.\n\n```cadence\nimport HelloWorld from 0x42\n\n// Invalid: The contract does not know where hello comes from\n//\nlog(hello())        // Error\n\n// Valid: Using the imported contract object to call the hello\n// function\n//\nlog(HelloWorld.hello())    // prints \"Hello World!\"\n\n// Valid: Using the imported contract object to read the greeting\n// field.\nlog(HelloWorld.greeting)   // prints \"Hello World!\"\n\n// Invalid: Cannot call the init function after the contract has been created.\n//\nHelloWorld.init()    // Error\n```\n\nThere can be any number of contracts per account\nand they can include an arbitrary amount of data.\nThis means that a contract can have any number of fields, functions, and type definitions,\nbut they have to be in the contract and not another top-level definition.\n\n```cadence\n// Invalid: Top-level declarations are restricted to only be contracts\n//          or contract interfaces. Therefore, all of these would be invalid\n//          if they were deployed to the account contract storage and\n//          the deployment would be rejected.\n//\npub resource Vault {}\npub struct Hat {}\npub fun helloWorld(): String {}\nlet num: Int\n```\n\nAnother important feature of contracts is that instances of resources and events\nthat are declared in contracts can only be created/emitted within functions or types\nthat are declared in the same contract.\n\nIt is not possible create instances of resources and events outside the contract.\n\nThe contract below defines a resource interface `Receiver` and a resource `Vault`\nthat implements that interface.  The way this example is written,\nthere is no way to create this resource, so it would not be usable.\n\n```cadence\n// Valid\npub contract FungibleToken {\n\n    pub resource interface Receiver {\n\n        pub balance: Int\n\n        pub fun deposit(from: @Receiver) {\n            pre {\n                from.balance > 0:\n                    \"Deposit balance needs to be positive!\"\n            }\n            post {\n                self.balance == before(self.balance) + before(from.balance):\n                    \"Incorrect amount removed\"\n            }\n        }\n    }\n\n    pub resource Vault: Receiver {\n\n        // keeps track of the total balance of the accounts tokens\n        pub var balance: Int\n\n        init(balance: Int) {\n            self.balance = balance\n        }\n\n        // withdraw subtracts amount from the vaults balance and\n        // returns a vault object with the subtracted balance\n        pub fun withdraw(amount: Int): @Vault {\n            self.balance = self.balance - amount\n            return <-create Vault(balance: amount)\n        }\n\n        // deposit takes a vault object as a parameter and adds\n        // its balance to the balance of the Account's vault, then\n        // destroys the sent vault because its balance has been consumed\n        pub fun deposit(from: @Receiver) {\n            self.balance = self.balance + from.balance\n            destroy from\n        }\n    }\n}\n```\n\nIf a user tried to run a transaction that created an instance of the `Vault` type,\nthe type checker would not allow it because only code in the `FungibleToken`\ncontract can create new `Vault`s.\n\n```cadence\nimport FungibleToken from 0x42\n\n// Invalid: Cannot create an instance of the `Vault` type outside\n// of the contract that defines `Vault`\n//\nlet newVault <- create FungibleToken.Vault(balance: 10)\n```\n\nThe contract would have to either define a function that creates new\n`Vault` instances or use its `init` function to create an instance and\nstore it in the owner's account storage.\n\nThis brings up another key feature of contracts in Cadence.  Contracts\ncan interact with its account's `storage` and `published` objects to store\nresources, structs, and references.\nThey do so by using the special `self.account` object that is only accessible within the contract.\n\nImagine that these were declared in the above `FungibleToken` contract.\n\n```cadence\n\n    pub fun createVault(initialBalance: Int): @Vault {\n        return <-create Vault(balance: initialBalance)\n    }\n\n    init(balance: Int) {\n        let vault <- create Vault(balance: 1000)\n        self.account.save(<-vault, to: /storage/initialVault)\n    }\n```\n\nNow, any account could call the `createVault` function declared in the contract\nto create a `Vault` object.\nOr the owner could call the `withdraw` function on their own `Vault` to send new vaults to others.\n\n```cadence\nimport FungibleToken from 0x42\n\n// Valid: Create an instance of the `Vault` type by calling the contract's\n// `createVault` function.\n//\nlet newVault <- create FungibleToken.createVault(initialBalance: 10)\n```\n\nContracts have the implicit field `let account: Account`,\nwhich is the account in which the contract is deployed too.\nThis gives the contract the ability to e.g. read and write to the account's storage.\n\n## Deploying, Updating, and Removing Contracts\n\nIn order for a contract to be used in Cadence, it needs to be deployed to an account.\nThe deployed contracts of an account can be accessed through the `contracts` object.\n\n### Deployed Contracts\n\nAccounts store \"deployed contracts\", that is, the code of the contract:\n\n```cadence\nstruct DeployedContract {\n    let name: String\n    let code: [UInt8]\n}\n```\n\nNote that this is not the contract instance that can be acquired by importing it.\n\n### Deploying a New Contract\n\nA new contract can be deployed to an account using the `add` function:\n\n  ```cadence\n  fun add(\n      name: String,\n      code: [UInt8],\n      ... contractInitializerArguments\n  ): DeployedContract\n  ```\n\n  Adds the given contract to the account.\n\n  The `code` parameter is the UTF-8 encoded representation of the source code.\n  The code must contain exactly one contract or contract interface,\n  which must have the same name as the `name` parameter.\n\n  All additional arguments that are given are passed further to the initializer\n  of the contract that is being deployed.\n\n  Fails if a contract/contract interface with the given name already exists in the account,\n  if the given code does not declare exactly one contract or contract interface,\n  or if the given name does not match the name of the contract/contract interface declaration in the code.\n\n  Returns the [deployed contract](#deployed-contracts).\n\nFor example, assuming the following contract code should be deployed:\n\n```cadence\npub contract Test {\n    pub let message: String\n\n    init(message: String) {\n        self.message = message\n    }\n}\n```\n\nThe contract can be deployed as follows:\n\n```cadence\n// Decode the hex-encoded source code into a byte array\n// using the built-in function `decodeHex`.\n//\n// (The ellipsis ... indicates the remainder of the string)\n//\nlet code = \"70756220636f6e...\".decodeHex()\n\n// `code` has type `[UInt8]`\n\nlet signer: Account = ...\nsigner.contracts.add(\n    name: \"Test\",\n    code: code,\n    message: \"I'm a new contract in an existing account\"\n)\n```\n\n### Updating a Deployed Contract\n\n> 🚧 Status: Updating contracts is **experimental**.\n>\n> This function only works for updates of function bodies, conditions, access modifiers, and comments.\n>\n> This function does **not** support other changes, e.g. changes of function signatures (parameters, return type);\n> adding, removing, or updating the name or type of fields; updating type declarations, etc.\n\nA deployed contract can be updated using the `update__experimental` function:\n\n  ```cadence\n  fun update__experimental(name: String, code: [UInt8]): DeployedContract\n  ```\n\n  Updates the code for the contract/contract interface in the account.\n\n  The `code` parameter is the UTF-8 encoded representation of the source code.\n  The code must contain exactly one contract or contract interface,\n  which must have the same name as the `name` parameter.\n\n  Does **not** run the initializer of the contract/contract interface again.\n  The contract instance in the world state stays as is.\n\n  Fails if no contract/contract interface with the given name exists in the account,\n  if the given code does not declare exactly one contract or contract interface,\n  or if the given name does not match the name of the contract/contract interface declaration in the code.\n\n  Returns the [deployed contract](#deployed-contracts) for the updated contract.\n\nFor example, assuming that a contract named `Test` is already deployed to the account\nand it should be updated with the following contract code:\n\n```cadence\npub contract Test {\n    pub let message: String\n\n    init(message: String) {\n        self.message = message\n    }\n}\n```\n\nThe contract can be updated as follows:\n\n```cadence\n// Decode the hex-encoded source code into a byte array\n// using the built-in function `decodeHex`.\n//\n// (The ellipsis ... indicates the remainder of the string)\n//\nlet code = \"70756220636f6e...\".decodeHex()\n\n// `code` has type `[UInt8]`\n\nlet signer: Account = ...\nsigner.contracts.update__experimental(name: \"Test\", code: code)\n```\n\n### Getting a Deployed Contract\n\nA deployed contract can be get from an account using the `get` function:\n\n  ```cadence\n  fun get(name: String): DeployedContract?\n  ```\n\n  Returns the [deployed contract](#deployed-contracts) for the contract/contract interface with the given name in the account, if any.\n\n  Returns `nil` if no contract/contract interface with the given name exists in the account.\n\nFor example, assuming that a contract named `Test` is deployed to an account, the contract can be retrieved as follows:\n\n```cadence\nlet signer: Account = ...\nlet contract = signer.contracts.get(name: \"Test\")\n```\n\n### Removing a Deployed Contract\n\nA deployed contract can be removed from an account using the `remove` function:\n\n  ```cadence\n  fun remove(name: String): DeployedContract?\n  ```\n\n  Removes the contract/contract interface from the account which has the given name, if any.\n\n  Returns the removed [deployed contract](#deployed-contracts), if any.\n\n  Returns `nil` if no contract/contract interface with the given name exist in the account.\n\nFor example, assuming that a contract named `Test` is deployed to an account, the contract can be removed as follows:\n\n```cadence\nlet signer: Account = ...\nlet contract = signer.contracts.remove(name: \"Test\")\n```\n\n## Contract Interfaces\n\nLike composite types, contracts can have interfaces that specify rules\nabout their behavior, their types, and the behavior of their types.\n\nContract interfaces have to be declared globally.  Declarations\ncannot be nested in other types.\n\nIf a contract interface declares a concrete type, implementations of it\nmust also declare the same concrete type conforming to the type requirement.\n\nIf a contract interface declares an interface type, the implementing contract\ndoes not have to also define that interface.  They can refer to that nested\ninterface by saying `{ContractInterfaceName}.{NestedInterfaceName}`\n\n```cadence\n// Declare a contract interface that declares an interface and a resource\n// that needs to implement that interface in the contract implementation.\n//\npub contract interface InterfaceExample {\n\n    // Implementations do not need to declare this\n    // They refer to it as InterfaceExample.NestedInterface\n    //\n    pub resource interface NestedInterface {}\n\n    // Implementations must declare this type\n    //\n    pub resource Composite: NestedInterface {}\n}\n\npub contract ExampleContract: InterfaceExample {\n\n    // The contract doesn't need to redeclare the `NestedInterface` interface\n    // because it is already declared in the contract interface\n\n    // The resource has to refer to the resource interface using the name\n    // of the contract interface to access it\n    //\n    pub resource Composite: InterfaceExample.NestedInterface {\n    }\n}\n```\n","path":"language/contracts"},{"content":"---\ntitle: Control Flow\n---\n\nControl flow statements control the flow of execution in a function.\n\n## Conditional branching: if-statement\n\nIf-statements allow a certain piece of code to be executed only when a given condition is true.\n\nThe if-statement starts with the `if` keyword, followed by the condition,\nand the code that should be executed if the condition is true\ninside opening and closing braces.\nThe condition expression must be boolean.\nThe braces are required and not optional.\nParentheses around the condition are optional.\n\n```cadence\nlet a = 0\nvar b = 0\n\nif a == 0 {\n   b = 1\n}\n\n// Parentheses can be used around the condition, but are not required.\nif (a != 0) {\n   b = 2\n}\n\n// `b` is `1`\n```\n\nAn additional, optional else-clause can be added to execute another piece of code\nwhen the condition is false.\nThe else-clause is introduced by the `else` keyword followed by braces\nthat contain the code that should be executed.\n\n```cadence\nlet a = 0\nvar b = 0\n\nif a == 1 {\n   b = 1\n} else {\n   b = 2\n}\n\n// `b` is `2`\n```\n\nThe else-clause can contain another if-statement, i.e., if-statements can be chained together.\nIn this case the braces can be omitted.\n\n```cadence\nlet a = 0\nvar b = 0\n\nif a == 1 {\n   b = 1\n} else if a == 2 {\n   b = 2\n} else {\n   b = 3\n}\n\n// `b` is `3`\n\nif a == 1 {\n   b = 1\n} else {\n    if a == 0 {\n        b = 2\n    }\n}\n\n// `b` is `2`\n```\n\n## Optional Binding\n\nOptional binding allows getting the value inside an optional.\nIt is a variant of the if-statement.\n\nIf the optional contains a value, the first branch is executed\nand a temporary constant or variable is declared and set to the value contained in the optional;\notherwise, the else branch (if any) is executed.\n\nOptional bindings are declared using the `if` keyword like an if-statement,\nbut instead of the boolean test value, it is followed by the `let` or `var` keywords,\nto either introduce a constant or variable, followed by a name,\nthe equal sign (`=`), and the optional value.\n\n```cadence\nlet maybeNumber: Int? = 1\n\nif let number = maybeNumber {\n    // This branch is executed as `maybeNumber` is not `nil`.\n    // The constant `number` is `1` and has type `Int`.\n} else {\n    // This branch is *not* executed as `maybeNumber` is not `nil`\n}\n```\n\n```cadence\nlet noNumber: Int? = nil\n\nif let number = noNumber {\n    // This branch is *not* executed as `noNumber` is `nil`.\n} else {\n    // This branch is executed as `noNumber` is `nil`.\n    // The constant `number` is *not* available.\n}\n```\n\n## Switch\n\nSwitch-statements compare a value against several possible values of the same type, in order.\nWhen an equal value is found, the associated block of code is executed.\n\nThe switch-statement starts with the `switch` keyword, followed by the tested value,\nfollowed by the cases inside opening and closing braces.\nThe test expression must be equatable.\nThe braces are required and not optional.\n\nEach case is a separate branch of code execution\nand starts with the `case` keyword,\nfollowed by a possible value, a colon (`:`),\nand the block of code that should be executed\nif the case's value is equal to the tested value.\n\nThe block of code associated with a switch case\n[does not implicitly fall through](#no-implicit-fallthrough),\nand must contain at least one statement.\nEmpty blocks are invalid.\n\nAn optional default case may be given by using the `default` keyword.\nThe block of code of the default case is executed\nwhen none of the previous case tests succeeded.\nIt must always appear last.\n\n```cadence\nfun word(_ n: Int): String {\n    // Test the value of the parameter `n`\n    switch n {\n    case 1:\n        // If the value of variable `n` is equal to `1`,\n        // then return the string \"one\"\n        return \"one\"\n    case 2:\n        // If the value of variable `n` is equal to `2`,\n        // then return the string \"two\"\n        return \"two\"\n    default:\n        // If the value of variable `n` is neither equal to `1` nor to `2`,\n        // then return the string \"other\"\n        return \"other\"\n    }\n}\n\nword(1)  // returns \"one\"\nword(2)  // returns \"two\"\nword(3)  // returns \"other\"\nword(4)  // returns \"other\"\n```\n\n### Duplicate cases\n\nCases are tested in order, so if a case is duplicated,\nthe block of code associated with the first case that succeeds is executed.\n\n```cadence\nfun test(_ n: Int): String {\n    // Test the value of the parameter `n`\n    switch n {\n    case 1:\n        // If the value of variable `n` is equal to `1`,\n        // then return the string \"one\"\n        return \"one\"\n    case 1:\n        // If the value of variable `n` is equal to `1`,\n        // then return the string \"also one\".\n        // This is a duplicate case for the one above.\n        return \"also one\"\n    default:\n        // If the value of variable `n` is neither equal to `1` nor to `2`,\n        // then return the string \"other\"\n        return \"other\"\n    }\n}\n\nword(1) // returns \"one\", not \"also one\"\n```\n\n### `break`\n\nThe block of code associated with a switch case may contain a `break` statement.\nIt ends the execution of the switch statement immediately\nand transfers control to the code after the switch statement\n\n### No Implicit Fallthrough\n\nUnlike switch statements in some other languages,\nswitch statements in Cadence do not \"fall through\":\nexecution of the switch statement finishes as soon as the block of code\nassociated with the first matching case is completed.\nNo explicit `break` statement is required.\n\nThis makes the switch statement safer and easier to use,\navoiding the accidental execution of more than one switch case.\n\nSome other languages implicitly fall through\nto the block of code associated with the next case,\nso it is common to write cases with an empty block\nto handle multiple values in the same way.\n\nTo prevent developers from writing switch statements\nthat assume this behaviour, blocks must have at least one statement.\nEmpty blocks are invalid.\n\n```cadence\nfun words(_ n: Int): [String] {\n    // Declare a variable named `result`, an array of strings,\n    // which stores the result\n    let result: [String] = []\n\n    // Test the value of the parameter `n`\n    switch n {\n    case 1:\n        // If the value of variable `n` is equal to `1`,\n        // then append the string \"one\" to the result array\n        result.append(\"one\")\n    case 2:\n        // If the value of variable `n` is equal to `2`,\n        // then append the string \"two\" to the result array\n        result.append(\"two\")\n    default:\n        // If the value of variable `n` is neither equal to `1` nor to `2`,\n        // then append the string \"other\" to the result array\n        result.append(\"other\")\n    }\n    return result\n}\n\nwords(1)  // returns `[\"one\"]`\nwords(2)  // returns `[\"two\"]`\nwords(3)  // returns `[\"other\"]`\nwords(4)  // returns `[\"other\"]`\n```\n\n## Looping\n\n### while-statement\n\nWhile-statements allow a certain piece of code to be executed repeatedly,\nas long as a condition remains true.\n\nThe while-statement starts with the `while` keyword, followed by the condition,\nand the code that should be repeatedly\nexecuted if the condition is true inside opening and closing braces.\nThe condition must be boolean and the braces are required.\n\nThe while-statement will first evaluate the condition.\nIf it is true, the piece of code is executed and the evaluation of the condition is repeated.\nIf the condition is false, the piece of code is not executed\nand the execution of the whole while-statement is finished.\nThus, the piece of code is executed zero or more times.\n\n```cadence\nvar a = 0\nwhile a < 5 {\n    a = a + 1\n}\n\n// `a` is `5`\n```\n\n### For-in statement\n\nFor-in statements allow a certain piece of code to be executed repeatedly for\neach element in an array.\n\nThe for-in statement starts with the `for` keyword, followed by the name of\nthe element that is used in each iteration of the loop,\nfollowed by the `in` keyword, and then followed by the array\nthat is being iterated through in the loop.\n\nThen, the code that should be repeatedly executed in each iteration of the loop\nis enclosed in curly braces.\n\nIf there are no elements in the data structure, the code in the loop will not\nbe executed at all. Otherwise, the code will execute as many times\nas there are elements in the array.\n\n```cadence\nlet array = [\"Hello\", \"World\", \"Foo\", \"Bar\"]\n\nfor element in array {\n    log(element)\n}\n\n// The loop would log:\n// \"Hello\"\n// \"World\"\n// \"Foo\"\n// \"Bar\"\n```\n\nTo iterate over a dictionary's entries (keys and values), \nuse a for-in loop over the dictionary's keys and get the value for each key:\n\n```cadence\nlet dictionary = {\"one\": 1, \"two\": 2}\nfor key in dictionary.keys {\n    let value = dictionary[key]!\n    log(key)\n    log(value)\n}\n\n// The loop would log:\n// \"one\"\n// 1\n// \"two\"\n// 2\n```\n\n### `continue` and `break`\n\nIn for-loops and while-loops, the `continue` statement can be used to stop\nthe current iteration of a loop and start the next iteration.\n\n```cadence\nvar i = 0\nvar x = 0\nwhile i < 10 {\n    i = i + 1\n    if i < 3 {\n        continue\n    }\n    x = x + 1\n}\n// `x` is `8`\n\n\nlet array = [2, 2, 3]\nvar sum = 0\nfor element in array {\n    if element == 2 {\n        continue\n    }\n    sum = sum + element\n}\n\n// `sum` is `3`\n\n```\n\nThe `break` statement can be used to stop the execution\nof a for-loop or a while-loop.\n\n```cadence\nvar x = 0\nwhile x < 10 {\n    x = x + 1\n    if x == 5 {\n        break\n    }\n}\n// `x` is `5`\n\n\nlet array = [1, 2, 3]\nvar sum = 0\nfor element in array {\n    if element == 2 {\n        break\n    }\n    sum = sum + element\n}\n\n// `sum` is `1`\n```\n\n## Immediate function return: return-statement\n\nThe return-statement causes a function to return immediately,\ni.e., any code after the return-statement is not executed.\nThe return-statement starts with the `return` keyword\nand is followed by an optional expression that should be the return value of the function call.\n\n<!--\nTODO: examples\n\n- in function\n- in while\n- in if\n-->\n","path":"language/control-flow"},{"content":"---\ntitle: Crypto\n---\n\nThe built-in contract `Crypto` can be used to perform cryptographic operations.\nThe contract can be imported using `import Crypto`.\n\nFor example, to verify two signatures with equal weights for some signed data:\n\n```cadence\nimport Crypto\n\npub fun test main() {\n    let keyList = Crypto.KeyList()\n\n    let publicKeyA = Crypto.PublicKey(\n        publicKey:\n            \"db04940e18ec414664ccfd31d5d2d4ece3985acb8cb17a2025b2f1673427267968e52e2bbf3599059649d4b2cce98fdb8a3048e68abf5abe3e710129e90696ca\".decodeHex(),\n        signatureAlgorithm: Crypto.ECDSA_P256\n    )\n    keyList.add(\n        publicKeyA,\n        hashAlgorithm: Crypto.SHA3_256,\n        weight: 0.5\n    )\n\n    let publicKeyB = Crypto.PublicKey(\n        publicKey:\n            \"df9609ee588dd4a6f7789df8d56f03f545d4516f0c99b200d73b9a3afafc14de5d21a4fc7a2a2015719dc95c9e756cfa44f2a445151aaf42479e7120d83df956\".decodeHex(),\n        signatureAlgorithm: Crypto.ECDSA_P256\n    )\n    keyList.add(\n        publicKeyB,\n        hashAlgorithm: Crypto.SHA3_256,\n        weight: 0.5\n    )\n\n    let signatureSet = [\n        Crypto.KeyListSignature(\n            keyIndex: 0,\n            signature:\n                \"8870a8cbe6f44932ba59e0d15a706214cc4ad2538deb12c0cf718d86f32c47765462a92ce2da15d4a29eb4e2b6fa05d08c7db5d5b2a2cd8c2cb98ded73da31f6\".decodeHex()\n        ),\n        Crypto.KeyListSignature(\n            keyIndex: 1,\n            signature:\n                \"bbdc5591c3f937a730d4f6c0a6fde61a0a6ceaa531ccb367c3559335ab9734f4f2b9da8adbe371f1f7da913b5a3fdd96a871e04f078928ca89a83d841c72fadf\".decodeHex()\n        )\n    ]\n\n    // \"foo\", encoded as UTF-8, in hex representation\n    let signedData = \"666f6f\".decodeHex()\n\n    let isValid = keyList.isValid(\n        signatureSet: signatureSet,\n        signedData: signedData\n    )\n}\n```\n\nThe API of the Crypto contract is:\n\n```cadence\npub contract Crypto {\n\n    pub struct SignatureAlgorithm {\n        pub let name: String\n    }\n\n    /// ECDSA_P256 is Elliptic Curve Digital Signature Algorithm (ECDSA) on the NIST P-256 curve\n    pub let ECDSA_P256: SignatureAlgorithm\n\n    /// ECDSA_Secp256k1 is Elliptic Curve Digital Signature Algorithm (ECDSA) on the secp256k1 curve\n    pub let ECDSA_Secp256k1: SignatureAlgorithm\n\n    pub struct HashAlgorithm {\n        pub let name: String\n    }\n\n    /// SHA2_256 is Secure Hashing Algorithm 2 (SHA-2) with a 256-bit digest\n    pub let SHA2_256: HashAlgorithm\n\n    /// SHA3_256 is Secure Hashing Algorithm 3 (SHA-3) with a 256-bit digest\n    pub let SHA3_256: HashAlgorithm\n\n    pub struct PublicKey {\n        pub let publicKey: [UInt8]\n        pub let signatureAlgorithm: SignatureAlgorithm\n\n        init(publicKey: [UInt8], signatureAlgorithm: SignatureAlgorithm)\n    }\n\n    pub struct KeyListEntry {\n        pub let keyIndex: Int\n        pub let publicKey: PublicKey\n        pub let hashAlgorithm: HashAlgorithm\n        pub let weight: UFix64\n        pub let isRevoked: Bool\n\n        init(\n            keyIndex: Int,\n            publicKey: PublicKey,\n            hashAlgorithm: HashAlgorithm,\n            weight: UFix64,\n            isRevoked: Bool\n        )\n    }\n\n    pub struct KeyList {\n\n        init()\n\n        /// Adds a new key with the given weight\n        pub fun add(\n            _ publicKey: PublicKey,\n            hashAlgorithm: HashAlgorithm,\n            weight: UFix64\n        )\n\n        /// Returns the key at the given index, if it exists.\n        /// Revoked keys are always returned, but they have `isRevoked` field set to true\n        pub fun get(keyIndex: Int): KeyListEntry?\n\n        /// Marks the key at the given index revoked, but does not delete it\n        pub fun revoke(keyIndex: Int)\n\n        /// Returns true if the given signatures are valid for the given signed data\n        pub fun isValid(\n            signatureSet: [KeyListSignature],\n            signedData: [UInt8]\n        ): Bool\n    }\n\n    pub struct KeyListSignature {\n        pub let keyIndex: Int\n        pub let signature: [UInt8]\n\n        pub init(keyIndex: Int, signature: [UInt8])\n    }\n}\n```\n","path":"language/crypto"},{"content":"---\ntitle: Enumerations\n---\n\nEnumerations are sets of symbolic names bound to unique, constant values,\nwhich can be compared by identity.\n\n## Enum Declaration\n\nEnums are declared using the `enum` keyword,\nfollowed by the name of the enum, the raw type after a colon,\nand the requirements, which must be enclosed in opening and closing braces.\n\nThe raw type must be an integer subtype, e.g. `UInt8` or `Int128`.\n\nEnum cases are declared using the `case` keyword,\nfollowed by the name of the enum case.\n\nEnum cases must be unique.\nEach enum case has a raw value, the index of the case in all cases.\n\nThe raw value of an enum case can be accessed through the `rawValue` field.\n\nThe enum cases can be accessed by using the name as a field on the enum,\nor by using the enum constructor,\nwhich requires providing the raw value as an argument.\nThe enum constructor returns the enum case with the given raw value,\nif any, or `nil` if no such case exists.\n\nEnum cases can be compared using the equality operators `==` and `!=`.\n\n```cadence\n// Declare an enum named `Color` which has the raw value type `UInt8`,\n// and declare three enum cases: `red`, `green`, and `blue`\n//\npub enum Color: UInt8 {\n    pub case red\n    pub case green\n    pub case blue\n}\n// Declare a variable which has the enum type `Color` and initialize\n// it to the enum case `blue` of the enum\nlet blue: Color = Color.blue\n// Get the raw value of the enum case `blue`.\n// As it is the third case, so it has index 2\n//\nblue.rawValue // is `2`\n// Get the `green` enum case of the enum `Color` by using the enum\n// constructor and providing the raw value of the enum case `green`, 1,\n// as the enum case `green` is the second case, so it has index 1\n//\nlet green: Color? = Color(rawValue: 1)  // is `Color.green`\n// Get the enum case of the enum `Color` that has the raw value 5.\n// As there are only three cases, the maximum raw value / index is 2.\n//\nlet nothing = Color(rawValue: 5)  // is `nil`\n// Enum cases can be compared\nColor.red == Color.red  // is `true`\nColor(rawValue: 1) == Color.green  // is `true`\n// Different enum cases are not the same\nColor.red != Color.blue  // is `true`\n```\n","path":"language/enumerations"},{"content":"---\ntitle: Environment Information\n---\n\n## Transaction Information\n\nTo get the addresses of the signers of a transaction,\nuse the `address` field of each signing `AuthAccount`\nthat is passed to the transaction's `prepare` phase.\n\nThere is currently no API that allows getting other transaction information.\nPlease let us know if your use-case demands it by request this feature in an issue.\n\n## Block Information\n\nTo get information about a block, the functions `getCurrentBlock` and `getBlock` can be used:\n\n- `cadence•fun getCurrentBlock(): Block`\n\n  Returns the current block, i.e. the block which contains the currently executed transaction.\n\n- `cadence•fun getBlock(at height: UInt64): Block?`\n\n  Returns the block at the given height.\n  If the given block does not exist the function returns `nil`.\n\nThe `Block` type contains the identifier, height, and timestamp:\n\n```cadence\npub struct Block {\n    /// The ID of the block.\n    ///\n    /// It is essentially the hash of the block.\n    ///\n    pub let id: [UInt8; 32]\n\n    /// The height of the block.\n    ///\n    /// If the blockchain is viewed as a tree with the genesis block at the root,\n    // the height of a node is the number of edges between the node and the genesis block\n    ///\n    pub let height: UInt64\n\n    /// The view of the block.\n    ///\n    /// It is a detail of the consensus algorithm. It is a monotonically increasing integer\n    /// and counts rounds in the consensus algorithm. Since not all rounds result in a finalized block,\n    /// the view number is strictly greater than or equal to the block height\n    ///\n    pub let view: UInt64\n\n    /// The timestamp of the block.\n    ///\n    /// It is the local clock time of the block proposer when it generates the block\n    ///\n    pub let timestamp: UFix64\n}\n```\n\n","path":"language/environment-information"},{"content":"---\ntitle: Events\n---\n\nEvents are special values that can be emitted during the execution of a program.\n\nAn event type can be declared with the `event` keyword.\n\n```cadence\nevent FooEvent(x: Int, y: Int)\n```\n\nThe syntax of an event declaration is similar to that of\na [function declaration](../functions#function-declarations);\nevents contain named parameters, each of which has an optional argument label.\n\nEvent parameters may only have a valid event parameter type.\nValid types are boolean, string, integer, arrays and dictionaries of these types,\nand structures where all fields have a valid event parameter type.\nResource types are not allowed, because when a resource is used as an argument, it is moved.\n\nEvents can only be declared within a [contract](../contracts) body.\nEvents cannot be declared globally or within resource or struct types.\n\n```cadence\n// Invalid: An event cannot be declared globally\n//\nevent GlobalEvent(field: Int)\n\npub contract Events {\n    // Event with explicit argument labels\n    //\n    event BarEvent(labelA fieldA: Int, labelB fieldB: Int)\n\n    // Invalid: A resource type is not allowed to be used\n    // because it would be moved and lost\n    //\n    event ResourceEvent(resourceField: @Vault)\n}\n\n```\n\n### Emitting events\n\nTo emit an event from a program, use the `emit` statement:\n\n```cadence\npub contract Events {\n    event FooEvent(x: Int, y: Int)\n\n    // Event with argument labels\n    event BarEvent(labelA fieldA: Int, labelB fieldB: Int)\n\n    fun events() {\n        emit FooEvent(x: 1, y: 2)\n\n        // Emit event with explicit argument labels\n        // Note that the emitted event will only contain the field names,\n        // not the argument labels used at the invocation site.\n        emit BarEvent(labelA: 1, labelB: 2)\n    }\n}\n```\n\nEmitting events has the following restrictions:\n\n- Events can only be invoked in an `emit` statement.\n\n  This means events cannot be assigned to variables or used as function parameters.\n\n- Events can only be emitted from the location in which they are declared.\n","path":"language/events"},{"content":"---\ntitle: Functions\n---\n\nFunctions are sequences of statements that perform a specific task.\nFunctions have parameters (inputs) and an optional return value (output).\nFunctions are typed: the function type consists of the parameter types and the return type.\n\nFunctions are values, i.e., they can be assigned to constants and variables,\nand can be passed as arguments to other functions.\nThis behavior is often called \"first-class functions\".\n\n## Function Declarations\n\nFunctions can be declared by using the `fun` keyword, followed by the name of the declaration,\n the parameters, the optional return type,\n and the code that should be executed when the function is called.\n\nThe parameters need to be enclosed in parentheses.\nThe return type, if any, is separated from the parameters by a colon (`:`).\nThe function code needs to be enclosed in opening and closing braces.\n\nEach parameter must have a name, which is the name that the argument value\nwill be available as within the function.\n\nAn additional argument label can be provided to require function calls to use the label\nto provide an argument value for the parameter.\n\nArgument labels make code more explicit and readable.\nFor example, they avoid confusion about the order of arguments\nwhen there are multiple arguments that have the same type.\n\nArgument labels should be named so they make sense from the perspective of the function call.\n\nArgument labels precede the parameter name.\nThe special argument label `_` indicates\nthat a function call can omit the argument label.\nIf no argument label is declared in the function declaration,\nthe parameter name is the argument label of the function declaration,\nand function calls must use the parameter name as the argument label.\n\nEach parameter needs to have a type annotation,\nwhich follows the parameter name after a colon.\n\nFunction calls may provide arguments for parameters\nwhich are subtypes of the parameter types.\n\nThere is **no** support for optional parameters,\ni.e. default values for parameters,\nand variadic functions,\ni.e. functions that take an arbitrary amount of arguments.\n\n```cadence\n// Declare a function named `double`, which multiples a number by two.\n//\n// The special argument label _ is specified for the parameter,\n// so no argument label has to be provided in a function call.\n//\nfun double(_ x: Int): Int {\n    return x * 2\n}\n\n// Call the function named `double` with the value 4 for the first parameter.\n//\n// The argument label can be omitted in the function call as the declaration\n// specifies the special argument label _ for the parameter.\n//\ndouble(2)  // is `4`\n```\n\nIt is possible to require argument labels for some parameters,\nand not require argument labels for other parameters.\n\n```cadence\n// Declare a function named `clamp`. The function takes an integer value,\n// the lower limit, and the upper limit. It returns an integer between\n// the lower and upper limit.\n//\n// For the first parameter the special argument label _ is used,\n// so no argument label has to be given for it in a function call.\n//\n// For the second and third parameter no argument label is given,\n// so the parameter names are the argument labels, i.e., the parameter names\n// have to be given as argument labels in a function call.\n//\nfun clamp(_ value: Int, min: Int, max: Int): Int {\n    if value > max {\n        return max\n    }\n\n    if value < min {\n        return min\n    }\n\n    return value\n}\n\n// Declare a constant which has the result of a call to the function\n// named `clamp` as its initial value.\n//\n// For the first argument no label is given, as it is not required by\n// the function declaration (the special argument label `_` is specified).\n//\n// For the second and this argument the labels must be provided,\n// as the function declaration does not specify the special argument label `_`\n// for these two parameters.\n//\n// As the function declaration also does not specify argument labels\n// for these parameters, the parameter names must be used as argument labels.\n//\nlet clamped = clamp(123, min: 0, max: 100)\n// `clamped` is `100`\n```\n\n```cadence\n// Declare a function named `send`, which transfers an amount\n// from one account to another.\n//\n// The implementation is omitted for brevity.\n//\n// The first two parameters of the function have the same type, so there is\n// a potential that a function call accidentally provides arguments in\n// the wrong order.\n//\n// While the parameter names `senderAddress` and `receiverAddress`\n// are descriptive inside the function, they might be too verbose\n// to require them as argument labels in function calls.\n//\n// For this reason the shorter argument labels `from` and `to` are specified,\n// which still convey the meaning of the two parameters without being overly\n// verbose.\n//\n// The name of the third parameter, `amount`, is both meaningful inside\n// the function and also in a function call, so no argument label is given,\n// and the parameter name is required as the argument label in a function call.\n//\nfun send(from senderAddress: Address, to receivingAddress: Address, amount: Int) {\n    // The function code is omitted for brevity.\n    // ...\n}\n\n// Declare a constant which refers to the sending account's address.\n//\n// The initial value is omitted for brevity.\n//\nlet sender: Address = // ...\n\n// Declare a constant which refers to the receiving account's address.\n//\n// The initial value is omitted for brevity.\n//\nlet receiver: Address = // ...\n\n// Call the function named `send`.\n//\n// The function declaration requires argument labels for all parameters,\n// so they need to be provided in the function call.\n//\n// This avoids ambiguity. For example, in some languages (like C) it is\n// a convention to order the parameters so that the receiver occurs first,\n// followed by the sender. In other languages, it is common to have\n// the sender be the first parameter, followed by the receiver.\n//\n// Here, the order is clear – send an amount from an account to another account.\n//\nsend(from: sender, to: receiver, amount: 100)\n```\n\nThe order of the arguments in a function call must\nmatch the order of the parameters in the function declaration.\n\n```cadence\n// Declare a function named `test`, which accepts two parameters, named `first` and `second`\n//\nfun test(first: Int, second: Int) {\n    // ...\n}\n\n// Invalid: the arguments are provided in the wrong order,\n// even though the argument labels are provided correctly.\n//\ntest(second: 1, first: 2)\n```\n\nFunctions can be nested,\ni.e., the code of a function may declare further functions.\n\n```cadence\n// Declare a function which multiplies a number by two, and adds one.\n//\nfun doubleAndAddOne(_ x: Int): Int {\n\n    // Declare a nested function which multiplies a number by two.\n    //\n    fun double(_ x: Int) {\n        return x * 2\n    }\n\n    return double(x) + 1\n}\n\ndoubleAndAddOne(2)  // is `5`\n```\n\n## Function Overloading\n\n<Callout type=\"info\">\n\n🚧 Status: Function overloading is not implemented.\n\n</Callout>\n\nIt is possible to declare functions with the same name,\nas long as they have different sets of argument labels.\nThis is known as function overloading.\n\n```cadence\n// Declare a function named \"assert\" which requires a test value\n// and a message argument.\n//\nfun assert(_ test: Bool, message: String) {\n    // ...\n}\n\n// Declare a function named \"assert\" which only requires a test value.\n// The function calls the `assert` function declared above.\n//\nfun assert(_ test: Bool) {\n    assert(test, message: \"test is false\")\n}\n```\n\n## Function Expressions\n\nFunctions can be also used as expressions.\nThe syntax is the same as for function declarations,\nexcept that function expressions have no name, i.e., they are anonymous.\n\n```cadence\n// Declare a constant named `double`, which has a function as its value.\n//\n// The function multiplies a number by two when it is called.\n//\n// This function's type is `((Int): Int)`.\n//\nlet double =\n    fun (_ x: Int): Int {\n        return x * 2\n    }\n```\n\n## Function Calls\n\nFunctions can be called (invoked). Function calls\nneed to provide exactly as many argument values as the function has parameters.\n\n```cadence\nfun double(_ x: Int): Int {\n    return x * 2\n}\n\n// Valid: the correct amount of arguments is provided.\n//\ndouble(2)  // is `4`\n\n// Invalid: too many arguments are provided.\n//\ndouble(2, 3)\n\n// Invalid: too few arguments are provided.\n//\ndouble()\n```\n\n## Function Types\n\nFunction types consist of the function's parameter types\nand the function's return type.\n\nThe parameter types need to be enclosed in parentheses,\nfollowed by a colon (`:`), and end with the return type.\nThe whole function type needs to be enclosed in parentheses.\n\n```cadence\n// Declare a function named `add`, with the function type `((Int, Int): Int)`.\n//\nfun add(a: Int, b: Int): Int {\n    return a + b\n}\n```\n\n```cadence\n// Declare a constant named `add`, with the function type `((Int, Int): Int)`\n//\nlet add: ((Int, Int): Int) =\n    fun (a: Int, b: Int): Int {\n        return a + b\n    }\n```\n\nIf the function has no return type, it implicitly has the return type `Void`.\n\n```cadence\n// Declare a constant named `doNothing`, which is a function\n// that takes no parameters and returns nothing.\n//\nlet doNothing: ((): Void) =\n    fun () {}\n```\n\nParentheses also control precedence.\nFor example, a function type `((Int): ((): Int))` is the type\nfor a function which accepts one argument with type `Int`,\nand which returns another function,\nthat takes no arguments and returns an `Int`.\n\nThe type `[((Int): Int); 2]` specifies an array type of two functions,\nwhich accept one integer and return one integer.\n\nArgument labels are not part of the function type.\nThis has the advantage that functions with different argument labels,\npotentially written by different authors are compatible\nas long as the parameter types and the return type match.\nIt has the disadvantage that function calls to plain function values,\ncannot accept argument labels.\n\n```cadence\n// Declare a function which takes one argument that has type `Int`.\n// The function has type `((Int): Void)`.\n//\nfun foo1(x: Int) {}\n\n// Call function `foo1`. This requires an argument label.\nfoo1(x: 1)\n\n// Declare another function which takes one argument that has type `Int`.\n// The function also has type `((Int): Void)`.\n//\nfun foo2(y: Int) {}\n\n// Call function `foo2`. This requires an argument label.\nfoo2(y: 2)\n\n// Declare a variable which has type `((Int): Void)` and use `foo1`\n// as its initial value.\n//\nvar someFoo: ((Int): Void) = foo1\n\n// Call the function assigned to variable `someFoo`.\n// This is valid as the function types match.\n// This does neither require nor allow argument labels.\n//\nsomeFoo(3)\n\n// Assign function `foo2` to variable `someFoo`.\n// This is valid as the function types match.\n//\nsomeFoo = foo2\n\n// Call the function assigned to variable `someFoo`.\n// This does neither require nor allow argument labels.\n//\nsomeFoo(4)\n```\n\n## Closures\n\nA function may refer to variables and constants of its outer scopes\nin which it is defined.\nIt is called a closure, because\nit is closing over those variables and constants.\nA closure can can read from the variables and constants\nand assign to the variables it refers to.\n\n```cadence\n// Declare a function named `makeCounter` which returns a function that\n// each time when called, returns the next integer, starting at 1.\n//\nfun makeCounter(): ((): Int) {\n    var count = 0\n    return fun (): Int {\n        // NOTE: read from and assign to the non-local variable\n        // `count`, which is declared in the outer function.\n        //\n        count = count + 1\n        return count\n    }\n}\n\nlet test = makeCounter()\ntest()  // is `1`\ntest()  // is `2`\n```\n\n## Argument Passing Behavior\n\nWhen arguments are passed to a function, they are copied.\nTherefore, values that are passed into a function\nare unchanged in the caller's scope when the function returns.\nThis behavior is known as\n[call-by-value](https://en.wikipedia.org/w/index.php?title=Evaluation_strategy&oldid=896280571#Call_by_value).\n\n```cadence\n// Declare a function that changes the first two elements\n// of an array of integers.\n//\nfun change(_ numbers: [Int]) {\n    // Change the elements of the passed in array.\n    // The changes are only local, as the array was copied.\n    //\n    numbers[0] = 1\n    numbers[1] = 2\n    // `numbers` is `[1, 2]`\n}\n\nlet numbers = [0, 1]\n\nchange(numbers)\n// `numbers` is still `[0, 1]`\n```\n\nParameters are constant, i.e., it is not allowed to assign to them.\n\n```cadence\nfun test(x: Int) {\n    // Invalid: cannot assign to a parameter (constant)\n    //\n    x = 2\n}\n```\n\n## Function Preconditions and Postconditions\n\nFunctions may have preconditions and may have postconditions.\nPreconditions and postconditions can be used to restrict the inputs (values for parameters)\nand output (return value) of a function.\n\nPreconditions must be true right before the execution of the function.\nPreconditions are part of the function and introduced by the `pre` keyword,\nfollowed by the condition block.\n\nPostconditions must be true right after the execution of the function.\nPostconditions are part of the function and introduced by the `post` keyword,\nfollowed by the condition block.\nPostconditions may only occur after preconditions, if any.\n\nA conditions block consists of one or more conditions.\nConditions are expressions evaluating to a boolean.\nThey may not call functions, i.e., they cannot have side-effects and must be pure expressions.\nAlso, conditions may not contain function expressions.\n\n<!--\n\nTODO:\n\nFor now, function calls are not allowed in preconditions and postconditions.\nSee https://github.com/dapperlabs/flow-go/issues/70\n\n-->\n\nConditions may be written on separate lines,\nor multiple conditions can be written on the same line,\nseparated by a semicolon.\nThis syntax follows the syntax for [statements](../syntax#semicolons).\n\nFollowing each condition, an optional description can be provided after a colon.\nThe condition description is used as an error message when the condition fails.\n\nIn postconditions, the special constant `result` refers to the result of the function.\n\n```cadence\nfun factorial(_ n: Int): Int {\n    pre {\n        // Require the parameter `n` to be greater than or equal to zero.\n        //\n        n >= 0:\n            \"factorial is only defined for integers greater than or equal to zero\"\n    }\n    post {\n        // Ensure the result will be greater than or equal to 1.\n        //\n        result >= 1:\n            \"the result must be greater than or equal to 1\"\n    }\n\n    if n < 1 {\n       return 1\n    }\n\n    return n * factorial(n - 1)\n}\n\nfactorial(5)  // is `120`\n\n// Run-time error: The given argument does not satisfy\n// the precondition `n >= 0` of the function, the program aborts.\n//\nfactorial(-2)\n```\n\nIn postconditions, the special function `before` can be used\nto get the value of an expression just before the function is called.\n\n```cadence\nvar n = 0\n\nfun incrementN() {\n    post {\n        // Require the new value of `n` to be the old value of `n`, plus one.\n        //\n        n == before(n) + 1:\n            \"n must be incremented by 1\"\n    }\n\n    n = n + 1\n}\n```\n\n","path":"language/functions-x"},{"content":"---\ntitle: Imports\n---\n\nPrograms can import declarations (types, functions, variables, etc.) from other programs.\n\nImports are declared using the `import` keyword.\n\nIt can either be followed by a location, which imports all declarations;\nor it can be followed by the names of the declarations that should be imported,\nfollowed by the `from` keyword, and then followed by the location.\n\nIf importing a local file, the location is a string literal, and the path to the file.\n\n<Callout type=\"info\">\n\n🚧 Status: Imports from local files are not currently implemented.\n\n</Callout>\n\nIf importing an external type in a different account,\nthe location is an address literal, and the address\nof the account where the declarations are deployed to and published.\n\n```cadence\n// Import the type `Counter` from a local file.\n//\nimport Counter from \"examples/counter.cdc\"\n\n// Import the type `Counter` from an external account.\n//\nimport Counter from 0x299F20A29311B9248F12\n```\n","path":"language/imports-x"},{"content":"---\ntitle: The Cadence Programming Language\n---\n\n## Introduction\n\nThe Cadence Programming Language is a new high-level programming language\nintended for smart contract development.\n\nThe language's goals are, in order of importance:\n\n- **Safety and security**:\n  Provide a strong static type system, design by contract (preconditions and postconditions),\n  and resources (inspired by linear types).\n\n- **Auditability**:\n  Focus on readability: Make it easy to verify what the code is doing,\n  and make intentions explicit, at a small cost of verbosity.\n\n- **Simplicity**: Focus on developer productivity and usability:\n  Make it easy to write code, provide good tooling.\n\n## Terminology\n\nIn this document, the following terminology is used to describe syntax\nor behavior that is not allowed in the language:\n\n- `Invalid` means that the invalid program will not even be allowed to run.\n  The program error is detected and reported statically by the type checker.\n\n- `Run-time error` means that the erroneous program will run,\n  but bad behavior will result in the execution of the program being aborted.\n\n## Syntax and Behavior\n\nMuch of the language's syntax is inspired by Swift, Kotlin, and TypeScript.\n\nMuch of the syntax, types, and standard library is inspired by Swift,\nwhich popularized e.g. optionals, argument labels,\nand provides safe handling of integers and strings.\n\nResources are based on linear types which were popularized by Rust.\n\nEvents are inspired by Solidity.\n\n**Disclaimer:** In real Cadence code, all type definitions and code\nmust be declared and contained in [contracts](../contracts) or [transactions](../transactions),\nbut we omit these containers in examples for simplicity.\n","path":"language/index"},{"content":"---\ntitle: Interfaces\n---\n\nAn interface is an abstract type that specifies the behavior of types\nthat *implement* the interface.\nInterfaces declare the required functions and fields,\nthe access control for those declarations,\nand preconditions and postconditions that implementing types need to provide.\n\nThere are three kinds of interfaces:\n\n- **Structure interfaces**: implemented by [structures](../composite-types#structures)\n- **Resource interfaces**: implemented by [resources](../composite-types#resources)\n- **Contract interfaces**: implemented by [contracts](../contracts)\n\nStructure, resource, and contract types may implement multiple interfaces.\n\nThere is no support for event and enum interfaces.\n\nNominal typing applies to composite types that implement interfaces.\nThis means that a type only implements an interface\nif it has explicitly declared the conformance,\nthe composite type does not implicitly conform to an interface,\neven if it satisfies all requirements of the interface.\n\nInterfaces consist of the function and field requirements\nthat a type implementing the interface must provide implementations for.\nInterface requirements, and therefore also their implementations,\nmust always be at least public.\n\nVariable field requirements may be annotated\nto require them to be publicly settable.\n\nFunction requirements consist of the name of the function,\nparameter types, an optional return type,\nand optional preconditions and postconditions.\n\nField requirements consist of the name and the type of the field.\nField requirements may optionally declare a getter requirement and a setter requirement,\neach with preconditions and postconditions.\n\nCalling functions with preconditions and postconditions on interfaces\ninstead of concrete implementations can improve the security of a program,\nas it ensures that even if implementations change,\nsome aspects of them will always hold.\n\n## Interface Declaration\n\nInterfaces are declared using the `struct`, `resource`, or `contract` keyword,\nfollowed by the `interface` keyword,\nthe name of the interface,\nand the requirements, which must be enclosed in opening and closing braces.\n\nField requirements can be annotated to\nrequire the implementation to be a variable field, by using the `var` keyword;\nrequire the implementation to be a constant field, by using the `let` keyword;\nor the field requirement may specify nothing,\nin which case the implementation may either be\na variable field, a constant field, or a synthetic field.\n\nField requirements and function requirements must specify the required level of access.\nThe access must be at least be public, so the `pub` keyword must be provided.\nVariable field requirements can be specified to also be publicly settable\nby using the `pub(set)` keyword.\n\nInterfaces can be used in types.\nThis is explained in detail in the section [Interfaces in Types](#interfaces-in-types).\nFor now, the syntax `{I}` can be read as the type of any value that implements the interface `I`.\n\n```cadence\n// Declare a resource interface for a fungible token.\n// Only resources can implement this resource interface.\n//\npub resource interface FungibleToken {\n\n    // Require the implementing type to provide a field for the balance\n    // that is readable in all scopes (`pub`).\n    //\n    // Neither the `var` keyword, nor the `let` keyword is used,\n    // so the field may be implemented as either a variable field,\n    // a constant field, or a synthetic field.\n    //\n    // The read balance must always be positive.\n    //\n    // NOTE: no requirement is made for the kind of field,\n    // it can be either variable or constant in the implementation.\n    //\n    pub balance: Int {\n        set(newBalance) {\n            pre {\n                newBalance >= 0:\n                    \"Balances are always set as non-negative numbers\"\n            }\n        }\n    }\n\n    // Require the implementing type to provide an initializer that\n    // given the initial balance, must initialize the balance field.\n    //\n    init(balance: Int) {\n        pre {\n            balance >= 0:\n                \"Balances are always non-negative\"\n        }\n        post {\n            self.balance == balance:\n                \"the balance must be initialized to the initial balance\"\n        }\n\n        // NOTE: The declaration contains no implementation code.\n    }\n\n    // Require the implementing type to provide a function that is\n    // callable in all scopes, which withdraws an amount from\n    // this fungible token and returns the withdrawn amount as\n    // a new fungible token.\n    //\n    // The given amount must be positive and the function implementation\n    // must add the amount to the balance.\n    //\n    // The function must return a new fungible token.\n    // The type `{FungibleToken}` is the type of any resource\n    // that implements the resource interface `FungibleToken`.\n    //\n    pub fun withdraw(amount: Int): @{FungibleToken} {\n        pre {\n            amount > 0:\n                \"the amount must be positive\"\n            amount <= self.balance:\n                \"insufficient funds: the amount must be smaller or equal to the balance\"\n        }\n        post {\n            self.balance == before(self.balance) - amount:\n                \"the amount must be deducted from the balance\"\n        }\n\n        // NOTE: The declaration contains no implementation code.\n    }\n\n    // Require the implementing type to provide a function that is\n    // callable in all scopes, which deposits a fungible token\n    // into this fungible token.\n    //\n    // No precondition is required to check the given token's balance\n    // is positive, as this condition is already ensured by\n    // the field requirement.\n    //\n    // The parameter type `{FungibleToken}` is the type of any resource\n    // that implements the resource interface `FungibleToken`.\n    //\n    pub fun deposit(_ token: @{FungibleToken}) {\n        post {\n            self.balance == before(self.balance) + token.balance:\n                \"the amount must be added to the balance\"\n        }\n\n        // NOTE: The declaration contains no implementation code.\n    }\n}\n```\n\nNote that the required initializer and functions do not have any executable code.\n\nStruct and resource Interfaces can only be declared directly inside contracts,\ni.e. not inside of functions.\nContract interfaces can only be declared globally and not inside contracts.\n\n## Interface Implementation\n\nDeclaring that a type implements (conforms) to an interface\nis done in the type declaration of the composite type (e.g., structure, resource):\nThe kind and the name of the composite type is followed by a colon (`:`)\nand the name of one or more interfaces that the composite type implements.\n\nThis will tell the checker to enforce any requirements from the specified interfaces\nonto the declared type.\n\nA type implements (conforms to) an interface if it declares\nthe implementation in its signature, provides field declarations\nfor all fields required by the interface,\nand provides implementations for all functions required by the interface.\n\nThe field declarations in the implementing type must match the field requirements\nin the interface in terms of name, type, and declaration kind (e.g. constant, variable)\nif given. For example, an interface may require a field with a certain name and type,\nbut leaves it to the implementation what kind the field is.\n\nThe function implementations must match the function requirements in the interface\nin terms of name, parameter argument labels, parameter types, and the return type.\n\n```cadence\n// Declare a resource named `ExampleToken` that has to implement\n// the `FungibleToken` interface.\n//\n// It has a variable field named `balance`, that can be written\n// by functions of the type, but outer scopes can only read it.\n//\npub resource ExampleToken: FungibleToken {\n\n    // Implement the required field `balance` for the `FungibleToken` interface.\n    // The interface does not specify if the field must be variable, constant,\n    // so in order for this type (`ExampleToken`) to be able to write to the field,\n    // but limit outer scopes to only read from the field, it is declared variable,\n    // and only has public access (non-settable).\n    //\n    pub var balance: Int\n\n    // Implement the required initializer for the `FungibleToken` interface:\n    // accept an initial balance and initialize the `balance` field.\n    //\n    // This implementation satisfies the required postcondition.\n    //\n    // NOTE: the postcondition declared in the interface\n    // does not have to be repeated here in the implementation.\n    //\n    init(balance: Int) {\n        self.balance = balance\n    }\n\n    // Implement the required function named `withdraw` of the interface\n    // `FungibleToken`, that withdraws an amount from the token's balance.\n    //\n    // The function must be public.\n    //\n    // This implementation satisfies the required postcondition.\n    //\n    // NOTE: neither the precondition nor the postcondition declared\n    // in the interface have to be repeated here in the implementation.\n    //\n    pub fun withdraw(amount: Int): @ExampleToken {\n        self.balance = self.balance - amount\n        return create ExampleToken(balance: amount)\n    }\n\n    // Implement the required function named `deposit` of the interface\n    // `FungibleToken`, that deposits the amount from the given token\n    // to this token.\n    //\n    // The function must be public.\n    //\n    // NOTE: the type of the parameter is `{FungibleToken}`,\n    // i.e., any resource that implements the resource interface `FungibleToken`,\n    // so any other token – however, we want to ensure that only tokens\n    // of the same type can be deposited.\n    //\n    // This implementation satisfies the required postconditions.\n    //\n    // NOTE: neither the precondition nor the postcondition declared\n    // in the interface have to be repeated here in the implementation.\n    //\n    pub fun deposit(_ token: @{FungibleToken}) {\n        if let exampleToken = token as? ExampleToken {\n            self.balance = self.balance + exampleToken.balance\n            destroy exampleToken\n        } else {\n            panic(\"cannot deposit token which is not an example token\")\n        }\n    }\n}\n\n// Declare a constant which has type `ExampleToken`,\n// and is initialized with such an example token.\n//\nlet token <- create ExampleToken(balance: 100)\n\n// Withdraw 10 units from the token.\n//\n// The amount satisfies the precondition of the `withdraw` function\n// in the `FungibleToken` interface.\n//\n// Invoking a function of a resource does not destroy the resource,\n// so the resource `token` is still valid after the call of `withdraw`.\n//\nlet withdrawn <- token.withdraw(amount: 10)\n\n// The postcondition of the `withdraw` function in the `FungibleToken`\n// interface ensured the balance field of the token was updated properly.\n//\n// `token.balance` is `90`\n// `withdrawn.balance` is `10`\n\n// Deposit the withdrawn token into another one.\nlet receiver: @ExampleToken <- // ...\nreceiver.deposit(<-withdrawn)\n\n// Run-time error: The precondition of function `withdraw` in interface\n// `FungibleToken` fails, the program aborts: the parameter `amount`\n// is larger than the field `balance` (100 > 90).\n//\ntoken.withdraw(amount: 100)\n\n// Withdrawing tokens so that the balance is zero does not destroy the resource.\n// The resource has to be destroyed explicitly.\n//\ntoken.withdraw(amount: 90)\n```\n\nThe access level for variable fields in an implementation\nmay be less restrictive than the interface requires.\nFor example, an interface may require a field to be\nat least public (i.e. the `pub` keyword is specified),\nand an implementation may provide a variable field which is public,\nbut also publicly settable (the `pub(set)` keyword is specified).\n\n```cadence\npub struct interface AnInterface {\n    // Require the implementing type to provide a publicly readable\n    // field named `a` that has type `Int`. It may be a constant field,\n    // a variable field, or a synthetic field.\n    //\n    pub a: Int\n}\n\npub struct AnImplementation: AnInterface {\n    // Declare a publicly settable variable field named `a` that has type `Int`.\n    // This implementation satisfies the requirement for interface `AnInterface`:\n    // The field is at least publicly readable, but this implementation also\n    // allows the field to be written to in all scopes.\n    //\n    pub(set) var a: Int\n\n    init(a: Int) {\n        self.a = a\n    }\n}\n```\n\n## Interfaces in Types\n\nInterfaces can be used in types: The type `{I}` is the type of all objects\nthat implement the interface `I`.\n\nThis is called a [restricted type](../restricted-types):\nOnly the functionality (members and functions) of the interface can be used\nwhen accessing a value of such a type.\n\n```cadence\n// Declare an interface named `Shape`.\n//\n// Require implementing types to provide a field which returns the area,\n// and a function which scales the shape by a given factor.\n//\npub struct interface Shape {\n    pub fun getArea(): Int\n    pub fun scale(factor: Int)\n}\n\n// Declare a structure named `Square` the implements the `Shape` interface.\n//\npub struct Square: Shape {\n    // In addition to the required fields from the interface,\n    // the type can also declare additional fields.\n    //\n    pub var length: Int\n\n    // Provided the field `area`  which is required to conform\n    // to the interface `Shape`.\n    //\n    // Since `area` was not declared as a constant, variable,\n    // field in the interface, it can be declared.\n    //\n    pub fun getArea(): Int {\n        return self.length * self.length\n    }\n\n    pub init(length: Int) {\n        self.length = length\n    }\n\n    // Provided the implementation of the function `scale`\n    // which is required to conform to the interface `Shape`.\n    //\n    pub fun scale(factor: Int) {\n        self.length = self.length * factor\n    }\n}\n\n// Declare a structure named `Rectangle` that also implements the `Shape` interface.\n//\npub struct Rectangle: Shape {\n    pub var width: Int\n    pub var height: Int\n\n    // Provided the field `area  which is required to conform\n    // to the interface `Shape`.\n    //\n    pub fun getArea(): Int {\n        return self.width * self.height\n    }\n\n    pub init(width: Int, height: Int) {\n        self.width = width\n        self.height = height\n    }\n\n    // Provided the implementation of the function `scale`\n    // which is required to conform to the interface `Shape`.\n    //\n    pub fun scale(factor: Int) {\n        self.width = self.width * factor\n        self.height = self.height * factor\n    }\n}\n\n// Declare a constant that has type `Shape`, which has a value that has type `Rectangle`.\n//\nvar shape: {Shape} = Rectangle(width: 10, height: 20)\n```\n\nValues implementing an interface are assignable to variables that have the interface as their type.\n\n```cadence\n// Assign a value of type `Square` to the variable `shape` that has type `Shape`.\n//\nshape = Square(length: 30)\n\n// Invalid: cannot initialize a constant that has type `Rectangle`.\n// with a value that has type `Square`.\n//\nlet rectangle: Rectangle = Square(length: 10)\n```\n\nFields declared in an interface can be accessed\nand functions declared in an interface\ncan be called on values of a type that implements the interface.\n\n```cadence\n// Declare a constant which has the type `Shape`.\n// and is initialized with a value that has type `Rectangle`.\n//\nlet shape: {Shape} = Rectangle(width: 2, height: 3)\n\n// Access the field `area` declared in the interface `Shape`.\n//\nshape.area  // is `6`\n\n// Call the function `scale` declared in the interface `Shape`.\n//\nshape.scale(factor: 3)\n\nshape.area  // is `54`\n```\n\n## Interface Implementation Requirements\n\nInterfaces can require implementing types\nto also implement other interfaces of the same kind.\nInterface implementation requirements can be declared\nby following the interface name with a colon (`:`)\nand one or more names of interfaces of the same kind, separated by commas.\n\n```cadence\n// Declare a structure interface named `Shape`.\n//\npub struct interface Shape {}\n\n// Declare a structure interface named `Polygon`.\n// Require implementing types to also implement the structure interface `Shape`.\n//\npub struct interface Polygon: Shape {}\n\n// Declare a structure named `Hexagon` that implements the `Polygon` interface.\n// This also is required to implement the `Shape` interface,\n// because the `Polygon` interface requires it.\n//\npub struct Hexagon: Polygon {}\n```\n\n## Interface Nesting\n\n<Callout type=\"info\">\n\n🚧 Status: Currently only contracts and contract interfaces support nested interfaces.\n\n</Callout>\n\nInterfaces can be arbitrarily nested.\nDeclaring an interface inside another does not require implementing types\nof the outer interface to provide an implementation of the inner interfaces.\n\n```cadence\n// Declare a resource interface `OuterInterface`, which declares\n// a nested structure interface named `InnerInterface`.\n//\n// Resources implementing `OuterInterface` do not need to provide\n// an implementation of `InnerInterface`.\n//\n// Structures may just implement `InnerInterface`.\n//\nresource interface OuterInterface {\n\n    struct interface InnerInterface {}\n}\n\n// Declare a resource named `SomeOuter` that implements the interface `OuterInterface`\n//\n// The resource is not required to implement `OuterInterface.InnerInterface`.\n//\nresource SomeOuter: OuterInterface {}\n\n// Declare a structure named `SomeInner` that implements `InnerInterface`,\n// which is nested in interface `OuterInterface`.\n//\nstruct SomeInner: OuterInterface.InnerInterface {}\n\n```\n\n## Nested Type Requirements\n\n<Callout type=\"info\">\n\n🚧 Status: Currently only contracts and contract interfaces support nested type requirements.\n\n</Callout>\n\nInterfaces can require implementing types to provide concrete nested types.\nFor example, a resource interface may require an implementing type to provide a resource type.\n\n```cadence\n// Declare a resource interface named `FungibleToken`.\n//\n// Require implementing types to provide a resource type named `Vault`\n// which must have a field named `balance`.\n//\nresource interface FungibleToken {\n\n    pub resource Vault {\n        pub balance: Int\n    }\n}\n\n// Declare a resource named `ExampleToken` that implements the `FungibleToken` interface.\n//\n// The nested type `Vault` must be provided to conform to the interface.\n//\nresource ExampleToken: FungibleToken {\n\n    pub resource Vault {\n        pub var balance: Int\n\n        init(balance: Int) {\n            self.balance = balance\n        }\n    }\n}\n```\n\n## `Equatable` Interface\n\n<Callout type=\"info\">\n\n🚧 Status: The `Equatable` interface is not implemented yet.\n\n</Callout>\n\nAn equatable type is a type that can be compared for equality.\nTypes are equatable when they  implement the `Equatable` interface.\n\nEquatable types can be compared for equality using the equals operator (`==`)\nor inequality using the unequals operator (`!=`).\n\nMost of the built-in types are equatable, like booleans and integers.\nArrays are equatable when their elements are equatable.\nDictionaries are equatable when their values are equatable.\n\nTo make a type equatable the `Equatable` interface must be implemented,\nwhich requires the implementation of the function `equals`,\nwhich accepts another value that the given value should be compared for equality.\n\n```cadence\nstruct interface Equatable {\n    pub fun equals(_ other: {Equatable}): Bool\n}\n```\n\n```cadence\n// Declare a struct named `Cat`, which has one field named `id`\n// that has type `Int`, i.e., the identifier of the cat.\n//\n// `Cat` also will implement the interface `Equatable`\n// to allow cats to be compared for equality.\n//\nstruct Cat: Equatable {\n    pub let id: Int\n\n    init(id: Int) {\n        self.id = id\n    }\n\n    pub fun equals(_ other: {Equatable}): Bool {\n        if let otherCat = other as? Cat {\n            // Cats are equal if their identifier matches.\n            //\n            return otherCat.id == self.id\n        } else {\n            return false\n        }\n    }\n}\n\nCat(1) == Cat(2)  // is `false`\nCat(3) == Cat(3)  // is `true`\n```\n\n## `Hashable` Interface\n\n<Callout type=\"info\">\n\n🚧 Status: The `Hashable` interface is not implemented yet.\n\n</Callout>\n\nA hashable type is a type that can be hashed to an integer hash value,\ni.e., it is distilled into a value that is used as evidence of inequality.\nTypes are hashable when they implement the `Hashable` interface.\n\nHashable types can be used as keys in dictionaries.\n\nHashable types must also be equatable,\ni.e., they must also implement the `Equatable` interface.\nThis is because the hash value is only evidence for inequality:\ntwo values that have different hash values are guaranteed to be unequal.\nHowever, if the hash values of two values are the same,\nthen the two values could still be unequal\nand just happen to hash to the same hash value.\nIn that case equality still needs to be determined through an equality check.\nWithout `Equatable`, values could be added to a dictionary,\nbut it would not be possible to retrieve them.\n\nMost of the built-in types are hashable, like booleans and integers.\nArrays are hashable when their elements are hashable.\nDictionaries are hashable when their values are equatable.\n\nHashing a value means passing its essential components into a hash function.\nEssential components are those that are used in the type's implementation of `Equatable`.\n\nIf two values are equal because their `equals` function returns true,\nthen the implementation must return the same integer hash value for each of the two values.\n\nThe implementation must also consistently return the same integer hash value during the execution\nof the program when the essential components have not changed.\nThe integer hash value need not necessarily be the same across multiple executions.\n\n```cadence\nstruct interface Hashable: Equatable {\n    pub hashValue: Int\n}\n```\n\n```cadence\n// Declare a structure named `Point` with two fields\n// named `x` and `y` that have type `Int`.\n//\n// `Point` is declared to implement the `Hashable` interface,\n// which also means it needs to implement the `Equatable` interface.\n//\nstruct Point: Hashable {\n\n    pub(set) var x: Int\n    pub(set) var y: Int\n\n    init(x: Int, y: Int) {\n        self.x = x\n        self.y = y\n    }\n\n    // Implementing the function `equals` will allow points to be compared\n    // for equality and satisfies the `Equatable` interface.\n    //\n    pub fun equals(_ other: {Equatable}): Bool {\n        if let otherPoint = other as? Point {\n            // Points are equal if their coordinates match.\n            //\n            // The essential components are therefore the fields `x` and `y`,\n            // which must be used in the implementation of the field requirement\n            // `hashValue` of the `Hashable` interface.\n            //\n            return otherPoint.x == self.x\n                && otherPoint.y == self.y\n        } else {\n            return false\n        }\n    }\n\n    // Providing an implementation for the hash value field\n    // satisfies the `Hashable` interface.\n    //\n    pub synthetic hashValue: Int {\n        get {\n            // Calculate a hash value based on the essential components,\n            // the fields `x` and `y`.\n            //\n            var hash = 7\n            hash = 31 * hash + self.x\n            hash = 31 * hash + self.y\n            return hash\n        }\n    }\n}\n```\n","path":"language/interfaces-x"},{"content":"---\ntitle: Operators\n---\n\nOperators are special symbols that perform a computation\nfor one or more values.\nThey are either unary, binary, or ternary.\n\n- Unary operators perform an operation for a single value.\n  The unary operator symbol appears before the value.\n\n- Binary operators operate on two values.\n    The binary operator symbol appears between the two values (infix).\n\n- Ternary operators operate on three values.\n  The first operator symbol appears between the first and second value,\n  the second operator symbol appears between the second and third value (infix).\n\n## Negation\n\nThe `-` unary operator negates an integer:\n\n```cadence\nlet a = 1\n-a  // is `-1`\n```\n\nThe `!` unary operator logically negates a boolean:\n\n```cadence\nlet a = true\n!a  // is `false`\n```\n\n## Assignment\n\nThe binary assignment operator `=` can be used\nto assign a new value to a variable.\nIt is only allowed in a statement and is not allowed in expressions.\n\n```cadence\nvar a = 1\na = 2\n// `a` is `2`\n\n\nvar b = 3\nvar c = 4\n\n// Invalid: The assignment operation cannot be used in an expression.\na = b = c\n\n// Instead, the intended assignment must be written in multiple statements.\nb = c\na = b\n```\n\nAssignments to constants are invalid.\n\n```cadence\nlet a = 1\n// Invalid: Assignments are only for variables, not constants.\na = 2\n```\n\nThe left-hand side of the assignment operand must be an identifier.\nFor arrays and dictionaries, this identifier can be followed\nby one or more index or access expressions.\n\n```cadence\n// Declare an array of integers.\nlet numbers = [1, 2]\n\n// Change the first element of the array.\n//\nnumbers[0] = 3\n\n// `numbers` is `[3, 2]`\n```\n\n```cadence\n// Declare an array of arrays of integers.\nlet arrays = [[1, 2], [3, 4]]\n\n// Change the first element in the second array\n//\narrays[1][0] = 5\n\n// `arrays` is `[[1, 2], [5, 4]]`\n```\n\n```cadence\nlet dictionaries = {\n  true: {1: 2},\n  false: {3: 4}\n}\n\ndictionaries[false][3] = 0\n\n// `dictionaries` is `{\n//   true: {1: 2},\n//   false: {3: 0}\n//}`\n```\n\n## Swapping\n\nThe binary swap operator `<->` can be used\nto exchange the values of two variables.\nIt is only allowed in a statement and is not allowed in expressions.\n\n```cadence\nvar a = 1\nvar b = 2\na <-> b\n// `a` is `2`\n// `b` is `1`\n\nvar c = 3\n\n// Invalid: The swap operation cannot be used in an expression.\na <-> b <-> c\n\n// Instead, the intended swap must be written in multiple statements.\nb <-> c\na <-> b\n```\n\nBoth sides of the swap operation must be variable,\nassignment to constants is invalid.\n\n```cadence\nvar a = 1\nlet b = 2\n\n// Invalid: Swapping is only possible for variables, not constants.\na <-> b\n```\n\nBoth sides of the swap operation must be an identifier,\nfollowed by one or more index or access expressions.\n\n## Arithmetic\n\nThere are four arithmetic operators:\n\n- Addition: `+`\n- Subtraction: `-`\n- Multiplication: `*`\n- Division: `/`\n- Remainder: `%`\n\n```cadence\nlet a = 1 + 2\n// `a` is `3`\n```\n\nThe arguments for the operators need to be of the same type.\nThe result is always the same type as the arguments.\n\nThe division and remainder operators abort the program when the divisor is zero.\n\nArithmetic operations on the signed integer types\n`Int8`, `Int16`, `Int32`, `Int64`, `Int128`, `Int256`,\nand on the unsigned integer types\n`UInt8`, `UInt16`, `UInt32`, `UInt64`, `UInt128`, `UInt256`,\ndo not cause values to overflow or underflow.\n\n```cadence\nlet a: UInt8 = 255\n\n// Run-time error: The result `256` does not fit in the range of `UInt8`,\n// thus a fatal overflow error is raised and the program aborts\n//\nlet b = a + 1\n```\n\n```cadence\nlet a: Int8 = 100\nlet b: Int8 = 100\n\n// Run-time error: The result `10000` does not fit in the range of `Int8`,\n// thus a fatal overflow error is raised and the program aborts\n//\nlet c = a * b\n```\n\n```cadence\nlet a: Int8 = -128\n\n// Run-time error: The result `128` does not fit in the range of `Int8`,\n// thus a fatal overflow error is raised and the program aborts\n//\nlet b = -a\n```\n\nArithmetic operations on the unsigned integer types\n`Word8`, `Word16`, `Word32`, `Word64`\nmay cause values to overflow or underflow.\n\nFor example, the maximum value of an unsigned 8-bit integer is 255 (binary 11111111).\nAdding 1 results in an overflow, truncation to 8 bits, and the value 0.\n\n```cadence\n//    11111111 = 255\n// +         1\n// = 100000000 = 0\n```\n\n```cadence\nlet a: Word8 = 255\na + 1 // is `0`\n```\n\nSimilarly, for the minimum value 0,\nsubtracting 1 wraps around and results in the maximum value 255.\n\n```cadence\n//    00000000\n// -         1\n// =  11111111 = 255\n```\n\n```cadence\nlet b: Word8 = 0\nb - 1  // is `255`\n```\n\n## Logical Operators\n\nLogical operators work with the boolean values `true` and `false`.\n\n- Logical AND: `a && b`\n\n  ```cadence\n  true && true  // is `true`\n\n  true && false  // is `false`\n\n  false && true  // is `false`\n\n  false && false  // is `false`\n  ```\n\n  If the left-hand side is false, the right-hand side is not evaluated.\n\n- Logical OR: `a || b`\n\n  ```cadence\n  true || true  // is `true`\n\n  true || false  // is `true`\n\n  false || true  // is `true`\n\n  false || false // is `false`\n  ```\n\n  If the left-hand side is true, the right-hand side is not evaluated.\n\n## Comparison operators\n\nComparison operators work with boolean and integer values.\n\n- Equality: `==`, for booleans and integers\n\n  Both sides of the equality operator may be optional, even of different levels,\n  so it is for example possible to compare a non-optional with a double-optional (`??`).\n\n  ```cadence\n  1 == 1  // is `true`\n\n  1 == 2  // is `false`\n  ```\n\n  ```cadence\n  true == true  // is `true`\n\n  true == false  // is `false`\n  ```\n\n  ```cadence\n  let x: Int? = 1\n  x == nil  // is `false`\n  ```\n\n  ```cadence\n  let x: Int = 1\n  x == nil  // is `false`\n  ```\n\n  ```cadence\n  // Comparisons of different levels of optionals are possible.\n  let x: Int? = 2\n  let y: Int?? = nil\n  x == y  // is `false`\n  ```\n\n  ```cadence\n  // Comparisons of different levels of optionals are possible.\n  let x: Int? = 2\n  let y: Int?? = 2\n  x == y  // is `true`\n  ```\n\n- Inequality: `!=`, for booleans and integers (possibly optional)\n\n  Both sides of the inequality operator may be optional, even of different levels,\n  so it is for example possible to compare a non-optional with a double-optional (`??`).\n\n  ```cadence\n  1 != 1  // is `false`\n\n  1 != 2  // is `true`\n  ```\n\n  ```cadence\n  true != true  // is `false`\n\n  true != false  // is `true`\n  ```\n\n  ```cadence\n  let x: Int? = 1\n  x != nil  // is `true`\n  ```\n\n  ```cadence\n  let x: Int = 1\n  x != nil  // is `true`\n  ```\n\n  ```cadence\n  // Comparisons of different levels of optionals are possible.\n  let x: Int? = 2\n  let y: Int?? = nil\n  x != y  // is `true`\n  ```\n\n  ```cadence\n  // Comparisons of different levels of optionals are possible.\n  let x: Int? = 2\n  let y: Int?? = 2\n  x != y  // is `false`\n  ```\n\n- Less than: `<`, for integers\n\n  ```cadence\n  1 < 1  // is `false`\n\n  1 < 2  // is `true`\n\n  2 < 1  // is `false`\n  ```\n\n- Less or equal than: `<=`, for integers\n\n  ```cadence\n  1 <= 1  // is `true`\n\n  1 <= 2  // is `true`\n\n  2 <= 1  // is `false`\n  ```\n\n- Greater than: `>`, for integers\n\n  ```cadence\n  1 > 1  // is `false`\n\n  1 > 2  // is `false`\n\n  2 > 1  // is `true`\n  ```\n\n- Greater or equal than: `>=`, for integers\n\n  ```cadence\n  1 >= 1  // is `true`\n\n  1 >= 2  // is `false`\n\n  2 >= 1  // is `true`\n  ```\n\n## Ternary Conditional Operator\n\nThere is only one ternary conditional operator, the ternary conditional operator (`a ? b : c`).\n\nIt behaves like an if-statement, but is an expression:\nIf the first operator value is true, the second operator value is returned.\nIf the first operator value is false, the third value is returned.\n\nThe first value must be a boolean (must have the type `Bool`).\nThe second value and third value can be of any type.\nThe result type is the least common supertype of the second and third value.\n\n```cadence\nlet x = 1 > 2 ? 3 : 4\n// `x` is `4` and has type `Int`\n\nlet y = 1 > 2 ? nil : 3\n// `y` is `3` and has type `Int?`\n```\n\n## Precedence and Associativity\n\nOperators have the following precedences, highest to lowest:\n\n- Multiplication precedence: `*`, `&*`, `/`, `%`\n- Addition precedence: `+`, `&+`, `-`, `&-`\n- Relational precedence: `<`, `<=`, `>`, `>=`\n- Equality precedence: `==`, `!=`\n- Logical conjunction precedence: `&&`\n- Logical disjunction precedence: `||`\n- Ternary precedence: `? :`\n\nAll operators are left-associative, except for the ternary operator, which is right-associative.\n\nExpressions can be wrapped in parentheses to override precedence conventions,\ni.e. an alternate order should be indicated, or when the default order should be emphasized\ne.g. to avoid confusion.\nFor example, `(2 + 3) * 4` forces addition to precede multiplication,\nand `5 + (6 * 7)` reinforces the default order.\n","path":"language/operators"},{"content":"---\ntitle: References\n---\n\nIt is possible to create references to objects, i.e. resources or structures.\nA reference can be used to access fields and call functions on the referenced object.\n\nReferences are **copied**, i.e. they are value types.\n\nReferences are created by using the `&` operator, followed by the object,\nthe `as` keyword, and the type through which they should be accessed.\nThe given type must be a supertype of the referenced object's type.\n\nReferences have the type `&T`, where `T` is the type of the referenced object.\n\n```cadence\nlet hello = \"Hello\"\n\n// Create a reference to the \"Hello\" string, typed as a `String`\n//\nlet helloRef: &String = &hello as &String\n\nhelloRef.length // is `5`\n\n// Invalid: Cannot create a reference to `hello`\n// typed as `&Int`, as it has type `String`\n//\nlet intRef: &Int = &hello as &Int\n```\n\nReferences are covariant in their base types.\nFor example, `&T` is a subtype of `&U`, if `T` is a subtype of `U`.\n\n```cadence\n\n// Declare a resource interface named `HasCount`,\n// that has a field `count`\n//\nresource interface HasCount {\n    count: Int\n}\n\n// Declare a resource named `Counter` that conforms to `HasCount`\n//\nresource Counter: HasCount {\n    pub var count: Int\n\n    pub init(count: Int) {\n        self.count = count\n    }\n\n    pub fun increment() {\n        self.count = self.count + 1\n    }\n}\n\n// Create a new instance of the resource type `Counter`\n// and create a reference to it, typed as `&Counter`,\n// so the reference allows access to all fields and functions\n// of the counter\n//\nlet counter <- create Counter(count: 42)\nlet counterRef: &Counter = &counter as &Counter\n\ncounterRef.count  // is `42`\n\ncounterRef.increment()\n\ncounterRef.count  // is `43`\n```\n\nReferences may be **authorized** or **unauthorized**.\n\nAuthorized references have the `auth` modifier, i.e. the full syntax is `auth &T`,\nwhereas unauthorized references do not have a modifier.\n\nAuthorized references can be freely upcasted and downcasted,\nwhereas unauthorized references can only be upcasted.\nAlso, authorized references are subtypes of unauthorized references.\n\n```cadence\n\n// Create an unauthorized reference to the counter,\n// typed with the restricted type `&{HasCount}`,\n// i.e. some resource that conforms to the `HasCount` interface\n//\nlet countRef: &{HasCount} = &counter as &{HasCount}\n\ncountRef.count  // is `43`\n\n// Invalid: The function `increment` is not available\n// for the type `&{HasCount}`\n//\ncountRef.increment()\n\n// Invalid: Cannot conditionally downcast to reference type `&Counter`,\n// as the reference `countRef` is unauthorized.\n//\n// The counter value has type `Counter`, which is a subtype of `{HasCount}`,\n// but as the reference is unauthorized, the cast is not allowed.\n// It is not possible to \"look under the covers\"\n//\nlet counterRef2: &Counter = countRef as? &Counter\n\n// Create an authorized reference to the counter,\n// again with the restricted type `{HasCount}`, i.e. some resource\n// that conforms to the `HasCount` interface\n//\nlet authCountRef: auth &{HasCount} = &counter as auth &{HasCount}\n\n// Conditionally downcast to reference type `&Counter`.\n// This is valid, because the reference `authCountRef` is authorized\n//\nlet counterRef3: &Counter = authCountRef as? &Counter\n\ncounterRef3.count  // is `43`\n\ncounterRef3.increment()\n\ncounterRef3.count  // is `44`\n```\n\nReferences are ephemeral, i.e they cannot be [stored](../accounts#account-storage).\nInstead, consider [storing a capability and borrowing it](../capability-based-access-control) when needed.\n","path":"language/references"},{"content":"---\ntitle: Restricted Types\n---\n\nStructure and resource types can be **restricted**. Restrictions are interfaces.\nRestricted types only allow access to a subset of the members and functions\nof the type that is restricted, indicated by the restrictions.\n\nThe syntax of a restricted type is `T{U1, U2, ... Un}`,\nwhere `T` is the restricted type, a concrete resource or structure type,\nand the types `U1` to `Un` are the restrictions, interfaces that `T` conforms to.\n\nOnly the members and functions of the union of the set of restrictions are available.\n\nRestricted types are useful for increasing the safety in functions\nthat are supposed to only work on a subset of the type.\nFor example, by using a restricted type for a parameter's type,\nthe function may only access the functionality of the restriction:\nIf the function accidentally attempts to access other functionality,\nthis is prevented by the static checker.\n\n```cadence\n// Declare a resource interface named `HasCount`,\n// which has a read-only `count` field\n//\nresource interface HasCount {\n    pub let count: Int\n}\n\n// Declare a resource named `Counter`, which has a writeable `count` field,\n// and conforms to the resource interface `HasCount`\n//\npub resource Counter: HasCount {\n    pub var count: Int\n\n    init(count: Int) {\n        self.count = count\n    }\n\n    pub fun increment() {\n        self.count = self.count + 1\n    }\n}\n\n// Create an instance of the resource `Counter`\nlet counter: @Counter <- create Counter(count: 42)\n\ncounterRef.count  // is `42`\n\ncounterRef.increment()\n\ncounterRef.count  // is `43`\n\n// Move the resource in variable `counter` to a new variable `restrictedCounter`,\n// but typed with the restricted type `Counter{HasCount}`:\n// The variable may hold any `Counter`, but only the functionality\n// defined in the given restriction, the interface `HasCount`, may be accessed\n//\nlet restrictedCounter: @Counter{HasCount} <- counter\n\n// Invalid: Only functionality of restriction `Count` is available,\n// i.e. the read-only field `count`, but not the function `increment` of `Counter`\n//\nrestrictedCounter.increment()\n\n// Move the resource in variable `restrictedCounter` to a new variable `unrestrictedCounter`,\n// again typed as `Counter`, i.e. all functionality of the counter is available\n//\nlet unrestrictedCounter: @Counter <- restrictedCounter\n\n// Valid: The variable `unrestrictedCounter` has type `Counter`,\n// so all its functionality is available, including the function `increment`\n//\nunrestrictedCounter.increment()\n\n// Declare another resource type named `Strings`\n// which implements the resource interface `HasCount`\n//\npub resource Strings: HasCount {\n    pub var count: Int\n    access(self) var strings: [String]\n\n    init() {\n        self.count = 0\n        self.strings = []\n    }\n\n    pub fun append(_ string: String) {\n        self.strings.append(string)\n        self.count = self.count + 1\n    }\n}\n\n// Invalid: The resource type `Strings` is not compatible\n// with the restricted type `Counter{HasCount}`.\n// Even though the resource `Strings` implements the resource interface `HasCount`,\n// it is not compatible with `Counter`\n//\nlet counter2: @Counter{HasCount} <- create Strings()\n```\n\nIn addition to restricting concrete types is also possible\nto restrict the built-in types `AnyStruct`, the supertype of all structures,\nand `AnyResource`, the supertype of all resources.\nFor example, restricted type `AnyResource{HasCount}` is any resource type\nfor which only the functionality of the `HasCount` resource interface can be used.\n\nThe restricted types `AnyStruct` and `AnyResource` can be omitted.\nFor example, the type `{HasCount}` is any resource that implements\nthe resource interface `HasCount`.\n\n```cadence\npub struct interface HasID {\n    pub let id: String\n}\n\npub struct A: HasID {\n    pub let name: String\n\n    init(name: String) {\n        self.name = name\n    }\n}\n\npub struct B: HasID {\n    pub let name: String\n\n    init(name: String) {\n        self.name = name\n    }\n}\n\n// Create two instances, one of type `A`, and one of type `B`.\n// Both types conform to interface `HasID`, so the structs can be assigned\n// to variables with type `AnyResource{HasID}`: Some resource type which only allows\n// access to the functionality of resource interface `HasID`\n\nlet hasID1: {HasID} = A(name: \"1\")\nlet hasID2: {HasID} = B(name: \"2\")\n\n// Declare a function named `getID` which has one parameter with type `{HasID}`.\n// The type `{HasID}` is a short-hand for `AnyStruct{HasID}`:\n// Some structure which only allows access to the functionality of interface `HasID`.\n//\npub fun getID(_ value: {HasID}): String {\n    return value.id\n}\n\nlet id1 = getID(hasID1)\n// `id1` is \"1\"\n\nlet id2 = getID(hasID2)\n// `id2` is \"2\"\n```\n\nOnly concrete types may be restricted, e.g., the restricted type may not be an array,\nthe type `[T]{U}` is invalid.\n\nRestricted types are also useful when giving access to resources and structures\nto potentially untrusted third-party programs through [references](references),\nwhich are discussed in the next section.\n","path":"language/restricted-types"},{"content":"---\ntitle: Run-time Types\n---\n\nTypes can be represented at run-time.\nTo create a type value, use the constructor function `Type<T>()`, which accepts the static type as a type argument.\n\nThis is similar to e.g. `T.self` in Swift, `T::class` in Kotlin, and `T.class` in Java.\n\nFor example, to represent the type `Int` at run-time:\n\n```cadence\nlet intType: Type = Type<Int>()\n```\n\nThis works for both built-in and user-defined types. For example, to get the type value for a resource:\n\n```cadence\nresource Collectible {}\n\nlet collectibleType = Type<@Collectible>()\n\n// `collectibleType` has type `Type`\n```\n\nType values are comparable.\n\n```cadence\n\nType<Int>() == Type<Int>()\n\nType<Int>() != Type<String>()\n```\n\nThe method `fun isInstance(_ type: Type): Bool` can be used to check if a value has a certain type,\nusing the concrete run-time type,  and considering subtyping rules,\n\n```cadence\n// Declare a variable named `collectible` that has the *static* type `Collectible`\n// and has a resource of type `Collectible`\n//\nlet collectible: @Collectible <- create Collectible()\n\n// The resource is an instance of type `Collectible`,\n// because the concrete run-time type is `Collectible`\n//\ncollectible.isInstance(Type<@Collectible>())  // is `true`\n\n// The resource is an instance of type `AnyResource`,\n// because the concrete run-time type `Collectible` is a subtype of `AnyResource`\n//\ncollectible.isInstance(Type<@AnyResource>())  // is `true`\n\n// The resource is *not* an instance of type `String`,\n// because the concrete run-time type `Collectible` is *not* a subtype of `String`\n//\ncollectible.isInstance(Type<String>())  // is `false`\n```\n\nNote that the **concrete run-time type** of the object is used, **not** the static type.\n\n```cadence\n// Declare a variable named `something` that has the *static* type `AnyResource`\n// and has a resource of type `Collectible`\n//\nlet something: @AnyResource <- create Collectible()\n\n// The resource is an instance of type `Collectible`,\n// because the concrete run-time type is `Collectible`\n//\nsomething.isInstance(Type<@Collectible>())  // is `true`\n\n// The resource is an instance of type `AnyResource`,\n// because the concrete run-time type `Collectible` is a subtype of `AnyResource`\n//\nsomething.isInstance(Type<@AnyResource>())  // is `true`\n\n// The resource is *not* an instance of type `String`,\n// because the concrete run-time type `Collectible` is *not* a subtype of `String`\n//\nsomething.isInstance(Type<String>())  // is `false`\n```\n\nFor example, this allows implementing a marketplace sale resource:\n\n```cadence\npub resource SimpleSale {\n\n    /// The resource for sale.\n    /// Once the resource is sold, the field becomes `nil`.\n    ///\n    pub var resourceForSale: @AnyResource?\n\n    /// The price that is wanted for the purchase of the resource.\n    ///\n    pub let priceForResource: UFix64\n\n    /// The type of currency that is required for the purchase.\n    ///\n    pub let requiredCurrency: Type\n    pub let paymentReceiver: Capability<&{FungibleToken.Receiver}>\n\n    /// `paymentReceiver` is the capability that will be borrowed\n    /// once a valid purchase is made.\n    /// It is expected to target a resource that allows depositing the paid amount\n    /// (a vault which has the type in `requiredCurrency`).\n    ///\n    init(\n        resourceForSale: @AnyResource,\n        priceForResource: UFix64,\n        requiredCurrency: Type,\n        paymentReceiver: Capability<&{FungibleToken.Receiver}>\n    ) {\n        self.resourceForSale <- resourceForSale\n        self.priceForResource = priceForResource\n        self.requiredCurrency = requiredCurrency\n        self.paymentReceiver = paymentReceiver\n    }\n\n    destroy() {\n        // When this sale resource is destroyed,\n        // also destroy the resource for sale.\n        // Another option could be to transfer it back to the seller.\n        destroy self.resourceForSale\n    }\n\n    /// buyObject allows purchasing the resource for sale by providing\n    /// the required funds.\n    /// If the purchase succeeds, the resource for sale is returned.\n    /// If the purchase fails, the program aborts.\n    ///\n    pub fun buyObject(with funds: @FungibleToken.Vault): @AnyResource {\n        pre {\n            // Ensure the resource is still up for sale\n            self.resourceForSale != nil: \"The resource has already been sold\"\n            // Ensure the paid funds have the right amount\n            funds.balance >= self.priceForResource: \"Payment has insufficient amount\"\n            // Ensure the paid currency is correct\n            funds.isInstance(self.requiredCurrency): \"Incorrect payment currency\"\n        }\n\n        // Transfer the paid funds to the payment receiver\n        // by borrowing the payment receiver capability of this sale resource\n        // and depositing the payment into it\n\n        let receiver = self.paymentReceiver.borrow()\n            ?? panic(\"failed to borrow payment receiver capability\")\n\n        receiver.deposit(from: <-funds)\n        let resourceForSale <- self.resourceForSale <- nil\n        return <-resourceForSale\n    }\n}\n```\n\n","path":"language/run-time-types"},{"content":"---\ntitle: Scope\n---\n\nEvery function and block (`{` ... `}`) introduces a new scope for declarations.\nEach function and block can refer to declarations in its scope or any of the outer scopes.\n\n```cadence\nlet x = 10\n\nfun f(): Int {\n    let y = 10\n    return x + y\n}\n\nf()  // is `20`\n\n// Invalid: the identifier `y` is not in scope.\n//\ny\n```\n\n```cadence\nfun doubleAndAddOne(_ n: Int): Int {\n    fun double(_ x: Int) {\n        return x * 2\n    }\n    return double(n) + 1\n}\n\n// Invalid: the identifier `double` is not in scope.\n//\ndouble(1)\n```\n\nEach scope can introduce new declarations, i.e., the outer declaration is shadowed.\n\n```cadence\nlet x = 2\n\nfun test(): Int {\n    let x = 3\n    return x\n}\n\ntest()  // is `3`\n```\n\nScope is lexical, not dynamic.\n\n```cadence\nlet x = 10\n\nfun f(): Int {\n   return x\n}\n\nfun g(): Int {\n   let x = 20\n   return f()\n}\n\ng()  // is `10`, not `20`\n```\n\nDeclarations are **not** moved to the top of the enclosing function (hoisted).\n\n```cadence\nlet x = 2\n\nfun f(): Int {\n    if x == 0 {\n        let x = 3\n        return x\n    }\n    return x\n}\nf()  // is `2`\n```\n\n","path":"language/scope"},{"content":"---\ntitle: Syntax\n---\n\n## Comments\n\nComments can be used to document code.\nA comment is text that is not executed.\n\n*Single-line comments* start with two slashes (`//`).\nThese comments can go on a line by themselves or they can go directly after a line of code.\n\n```cadence\n// This is a comment on a single line.\n// Another comment line that is not executed.\n\nlet x = 1  // Here is another comment after a line of code.\n```\n\n*Multi-line comments* start with a slash and an asterisk (`/*`)\nand end with an asterisk and a slash (`*/`):\n\n```cadence\n/* This is a comment which\nspans multiple lines. */\n```\n\nComments may be nested.\n\n```cadence\n/* /* this */ is a valid comment */\n```\n\nMulti-line comments are balanced.\n\n```cadence\n/* this is a // comment up to here */ this is not part of the comment */\n```\n\n## Names\n\nNames may start with any upper or lowercase letter (A-Z, a-z)\nor an underscore (`_`).\nThis may be followed by zero or more upper and lower case letters,\nunderscores, and numbers (0-9).\nNames may not begin with a number.\n\n```cadence\n// Valid: title-case\n//\nPersonID\n\n// Valid: with underscore\n//\ntoken_name\n\n// Valid: leading underscore and characters\n//\n_balance\n\n// Valid: leading underscore and numbers\n_8264\n\n// Valid: characters and number\n//\naccount2\n\n// Invalid: leading number\n//\n1something\n\n// Invalid: invalid character #\n_#1\n\n// Invalid: various invalid characters\n//\n!@#$%^&*\n```\n\n### Conventions\n\nBy convention, variables, constants, and functions have lowercase names;\nand types have title-case names.\n\n## Semicolons\n\nSemicolons (;) are used as separators between declarations and statements.\nA semicolon can be placed after any declaration and statement,\nbut can be omitted between declarations and if only one statement appears on the line.\n\nSemicolons must be used to separate multiple statements if they appear on the same line.\n\n```cadence\n// Declare a constant, without a semicolon.\n//\nlet a = 1\n\n// Declare a variable, with a semicolon.\n//\nvar b = 2;\n\n// Declare a constant and a variable on a single line, separated by semicolons.\n//\nlet d = 1; var e = 2\n```\n","path":"language/syntax"},{"content":"---\ntitle: Transactions\n---\n\nTransactions are objects that are signed by one or more [accounts](../accounts)\nand are sent to the chain to interact with it.\n\nTransactions are structured as such:\n\nFirst, the transaction can import any number of types from external accounts\nusing the import syntax.\n\n```cadence\nimport FungibleToken from 0x01\n```\n\nThe body is declared using the `transaction` keyword and its contents\nare contained in curly braces.\n\nNext is the body of the transaction,\nwhich first contains local variable declarations that are valid\nthroughout the whole of the transaction.\n\n```cadence\ntransaction {\n    // transaction contents\n    let localVar: Int\n\n    ...\n}\n```\n\nThen, four optional main phases:\nPreparation, preconditions, execution, and postconditions, in that order.\nThe preparation and execution phases are blocks of code that execute sequentially.\n\nThe following empty Cadence transaction contains no logic,\nbut demonstrates the syntax for each phase, in the order these phases will be executed:\n\n```cadence\ntransaction {\n    prepare(signer1: AuthAccount, signer2: AuthAccount) {\n        // ...\n    }\n\n    pre {\n        // ...\n    }\n\n    execute {\n        // ...\n    }\n\n    post {\n        // ...\n    }\n}\n```\n\nAlthough optional, each phase serves a specific purpose when executing a transaction\nand it is recommended that developers use these phases when creating their transactions.\nThe following will detail the purpose of and how to use each phase.\n\n## Transaction Parameters\n\nTransactions may declare parameters.\nTransaction parameters are declared like function parameters.\nThe arguments for the transaction are passed in the sent transaction.\n\nTransaction parameters are accessible in all phases.\n\n```cadence\n// Declare a transaction which has one parameter named `amount`\n// that has the type `UFix64`\n//\ntransaction(amount: UFix64) {\n\n}\n```\n\n## Prepare phase\n\nThe `prepare` phase is used when access to the private `AuthAccount` object\nof **signing accounts** is required for your transaction.\n\nDirect access to signing accounts is **only possible inside the `prepare` phase**.\n\nFor each signer of the transaction the signing account is passed as an argument to the `prepare` phase.\nFor example, if the transaction has three signers,\nthe prepare **must** have three parameters of type `AuthAccount`.\n\n```cadence\n prepare(signer1: AuthAccount) {\n      // ...\n }\n```\n\nAs a best practice, only use the `prepare` phase to define and execute logic that requires access\nto the `AuthAccount` objects of signing accounts,\nand *move all other logic elsewhere*.\nModifications to accounts can have significant implications,\nso keep this phase clear of unrelated logic to ensure users of your contract are able to easily read\nand understand logic related to their private account objects.\n\nThe prepare phase serves a similar purpose as the initializer of a contract/resource/structure.\n\nFor example, if a transaction performs a token transfer, put the withdrawal in the `prepare` phase,\nas it requires access to the account storage, but perform the deposit in the `execute` phase.\n\n`AuthAccount` objects have the permissions\nto read from and write to the `/storage/` and `/private/` areas\nof the account, which cannot be directly accessed anywhere else.\nThey also have the permission to create and delete capabilities that\nuse these areas.\n\n## Pre Phase\n\nThe `pre` phase is executed after the `prepare` phase, and is used for checking\nif explicit conditions hold before executing the remainder of the transaction.\nA common example would be checking requisite balances before transferring tokens between accounts.\n\n```cadence\npre {\n    sendingAccount.balance > 0\n}\n```\n\nIf the `pre` phase throws an error, or does not return `true` the remainder of the transaction\nis not executed and it will be completely reverted.\n\n## Execute Phase\n\nThe `execute` phase does exactly what it says, it executes the main logic of the transaction.\nThis phase is optional, but it is a best practice to add your main transaction logic in the section,\nso it is explicit.\n\n```cadence\nexecute {\n    // Invalid: Cannot access the authorized account object,\n    // as `account1` is not in scope\n    let resource <- account1.load<@Resource>(from: /storage/resource)\n    destroy resource\n\n    // Valid: Can access any account's public Account object\n    let publicAccount = getAccount(0x03)\n}\n```\n\nYou **may not** access private `AuthAccount` objects in the `execute` phase,\nbut you may get an account's `PublicAccount` object,\nwhich allows reading and calling methods on objects\nthat an account has published in the public domain of its account (resources, contract methods, etc.).\n\n## Post Phase\n\nStatements inside of the `post` phase are used\nto verify that your transaction logic has been executed properly.\nIt contains zero or more condition checks.\n\nFor example, a transfer transaction might ensure that the final balance has a certain value,\nor e.g. it was incremented by a specific amount.\n\n```cadence\npost {\n    result.balance == 30: \"Balance after transaction is incorrect!\"\n}\n```\n\nIf any of the condition checks result in `false`, the transaction will fail and be completely reverted.\n\nOnly condition checks are allowed in this section.\nNo actual computation or modification of values is allowed.\n\n**A Note about `pre` and `post` Phases**\n\nAnother function of the `pre` and `post` phases is to help provide information\nabout how the effects of a transaction on the accounts and resources involved.\nThis is essential because users may want to verify what a transaction does before submitting it.\n`pre` and `post` phases provide a way to introspect transactions before they are executed.\n\nFor example, in the future the phases could be analyzed and interpreted to the user\nin the software they are using,\ne.g. \"this transaction will transfer 30 tokens from A to B.\nThe balance of A will decrease by 30 tokens and the balance of B will increase by 30 tokens.\"\n\n## Summary\n\nCadence transactions use phases to make the transaction's code / intent more readable\nand to provide a way for developer to separate potentially 'unsafe' account\nmodifying code from regular transaction logic,\nas well as provide a way to check for error prior / after transaction execution,\nand abort the transaction if any are found.\n\nThe following is a brief summary of how to use the `prepare`, `pre`, `execute`,\nand `post` phases in a Cadence transaction.\n\n```cadence\ntransaction {\n    prepare(signer1: AuthAccount) {\n        // Access signing accounts for this transaction.\n        //\n        // Avoid logic that does not need access to signing accounts.\n        //\n        // Signing accounts can't be accesed anywhere else in the transaction.\n    }\n\n    pre {\n        // Define conditions that must be true\n        // for this transaction to execute.\n    }\n\n    execute {\n        // The main transaction logic goes here, but you can access\n        // any public information or resources published by any account.\n    }\n\n    post {\n        // Define the expected state of things\n        // as they should be after the transaction executed.\n        //\n        // Also used to provide information about what changes\n        // this transaction will make to accounts in this transaction.\n    }\n}\n```\n","path":"language/transactions"},{"content":"---\ntitle: Type Annotations\n---\n\nWhen declaring a constant or variable,\nan optional *type annotation* can be provided,\nto make it explicit what type the declaration has.\n\nIf no type annotation is provided, the type of the declaration is\n[inferred from the initial value](../type-inference).\n\nFor function parameters a type annotation must be provided.\n\n```cadence\n// Declare a variable named `boolVarWithAnnotation`, which has an explicit type annotation.\n//\n// `Bool` is the type of booleans.\n//\nvar boolVarWithAnnotation: Bool = false\n\n// Declare a constant named `integerWithoutAnnotation`, which has no type annotation\n// and for which the type is inferred to be `Int`, the type of arbitrary-precision integers.\n//\n// This is based on the initial value which is an integer literal.\n// Integer literals are always inferred to be of type `Int`.\n//\nlet integerWithoutAnnotation = 1\n\n// Declare a constant named `smallIntegerWithAnnotation`, which has an explicit type annotation.\n// Because of the explicit type annotation, the type is not inferred.\n// This declaration is valid because the integer literal `1` fits into the range of the type `Int8`,\n// the type of 8-bit signed integers.\n//\nlet smallIntegerWithAnnotation: Int8 = 1\n```\n\nIf a type annotation is provided, the initial value must be of this type.\nAll new values assigned to variables must match its type.\nThis type safety is explained in more detail in a [separate section](../type-safety).\n\n```cadence\n// Invalid: declare a variable with an explicit type `Bool`,\n// but the initial value has type `Int`.\n//\nlet booleanConstant: Bool = 1\n\n// Declare a variable that has the inferred type `Bool`.\n//\nvar booleanVariable = false\n\n// Invalid: assign a value with type `Int` to a variable which has the inferred type `Bool`.\n//\nbooleanVariable = 1\n```\n","path":"language/type-annotations"},{"content":"---\ntitle: Type Hierarchy\n---\n\n![Cadence type hierarchy](type-hierarchy.png)\n","path":"language/type-hierarchy"},{"content":null,"path":"language/type-hierarchy-monopic"},{"content":null,"path":"language/type-hierarchy-png"},{"content":"---\ntitle: Type Inference\n---\n\n<Callout type=\"info\">\n\n🚧 Status: Only basic type inference is implemented.\n\n</Callout>\n\nIf a variable or constant declaration is not annotated explicitly with a type,\nthe declaration's type is inferred from the initial value.\n\nInteger literals are inferred to type `Int`.\n\n```cadence\nlet a = 1\n\n// `a` has type `Int`\n```\n\nArray literals are inferred based on the elements of the literal, and to be variable-size.\n\n```cadence\nlet integers = [1, 2]\n// `integers` has type `[Int]`\n\n// Invalid: mixed types\n//\nlet invalidMixed = [1, true, 2, false]\n```\n\nDictionary literals are inferred based on the keys and values of the literal.\n\n```cadence\nlet booleans = {\n    1: true,\n    2: false\n}\n// `booleans` has type `{Int: Bool}`\n\n// Invalid: mixed types\n//\nlet invalidMixed = {\n    1: true,\n    false: 2\n}\n```\n\nFunctions are inferred based on the parameter types and the return type.\n\n```cadence\nlet add = (a: Int8, b: Int8): Int {\n    return a + b\n}\n\n// `add` has type `((Int8, Int8): Int)`\n```\n\nType inference is performed for each expression / statement, and not across statements.\n\nThere are cases where types cannot be inferred.\nIn these cases explicit type annotations are required.\n\n```cadence\n// Invalid: not possible to infer type based on array literal's elements.\n//\nlet array = []\n\n// Instead, specify the array type and the concrete element type, e.g. `Int`.\n//\nlet array: [Int] = []\n```\n\n```cadence\n// Invalid: not possible to infer type based on dictionary literal's keys and values.\n//\nlet dictionary = {}\n\n// Instead, specify the dictionary type and the concrete key\n// and value types, e.g. `String` and `Int`.\n//\nlet dictionary: {String: Int} = {}\n```\n\n```cadence\n// Invalid: not possible to infer type based on nil literal.\n//\nlet maybeSomething = nil\n\n// Instead, specify the optional type and the concrete element type, e.g. `Int`.\n//\nlet maybeSomething: Int? = nil\n```\n","path":"language/type-inference-x"},{"content":"---\ntitle: Type Safety\n---\n\nThe Cadence programming language is a *type-safe* language.\n\nWhen assigning a new value to a variable, the value must be the same type as the variable.\nFor example, if a variable has type `Bool`,\nit can *only* be assigned a value that has type `Bool`,\nand not for example a value that has type `Int`.\n\n```cadence\n// Declare a variable that has type `Bool`.\nvar a = true\n\n// Invalid: cannot assign a value that has type `Int` to a variable which has type `Bool`.\n//\na = 0\n```\n\nWhen passing arguments to a function,\nthe types of the values must match the function parameters' types.\nFor example, if a function expects an argument that has type `Bool`,\n*only* a value that has type `Bool` can be provided,\nand not for example a value which has type `Int`.\n\n```cadence\nfun nand(_ a: Bool, _ b: Bool): Bool {\n    return !(a && b)\n}\n\nnand(false, false)  // is `true`\n\n// Invalid: The arguments of the function calls are integers and have type `Int`,\n// but the function expects parameters booleans (type `Bool`).\n//\nnand(0, 0)\n```\n\nTypes are **not** automatically converted.\nFor example, an integer is not automatically converted to a boolean,\nnor is an `Int32` automatically converted to an `Int8`,\nnor is an optional integer `Int?`\nautomatically converted to a non-optional integer `Int`,\nor vice-versa.\n\n```cadence\nfun add(_ a: Int8, _ b: Int8): Int8 {\n    return a + b\n}\n\n// The arguments are not declared with a specific type, but they are inferred\n// to be `Int8` since the parameter types of the function `add` are `Int8`.\nadd(1, 2)  // is `3`\n\n// Declare two constants which have type `Int32`.\n//\nlet a: Int32 = 3_000_000_000\nlet b: Int32 = 3_000_000_000\n\n// Invalid: cannot pass arguments which have type `Int32` to parameters which have type `Int8`.\n//\nadd(a, b)\n```\n","path":"language/type-safety"},{"content":"---\ntitle: Values and Types\n---\n\nValues are objects, like for example booleans, integers, or arrays.\nValues are typed.\n\n## Booleans\n\nThe two boolean values `true` and `false` have the type `Bool`.\n\n## Numeric Literals\n\nNumbers can be written in various bases. Numbers are assumed to be decimal by default.\nNon-decimal literals have a specific prefix.\n\n| Numeral system  | Prefix | Characters                                                            |\n|:----------------|:-------|:----------------------------------------------------------------------|\n| **Decimal**     | *None* | one or more numbers (`0` to `9`)                                      |\n| **Binary**      | `0b`   | one or more zeros or ones (`0` or `1`)                                |\n| **Octal**       | `0o`   | one or more numbers in the range `0` to `7`                           |\n| **Hexadecimal** | `0x`   | one or more numbers, or characters `a` to `f`, lowercase or uppercase |\n\n```cadence\n// A decimal number\n//\n1234567890  // is `1234567890`\n\n// A binary number\n//\n0b101010  // is `42`\n\n// An octal number\n//\n0o12345670  // is `2739128`\n\n// A hexadecimal number\n//\n0x1234567890ABCabc  // is `1311768467294898876`\n\n// Invalid: unsupported prefix 0z\n//\n0z0\n\n// A decimal number with leading zeros. Not an octal number!\n00123 // is `123`\n\n// A binary number with several trailing zeros.\n0b001000  // is `8`\n```\n\nDecimal numbers may contain underscores (`_`) to logically separate components.\n\n```cadence\nlet largeNumber = 1_000_000\n\n// Invalid: Value is not a number literal, but a variable.\nlet notNumber = _123\n```\n\nUnderscores are allowed for all numeral systems.\n\n```cadence\nlet binaryNumber = 0b10_11_01\n```\n\n## Integers\n\nIntegers are numbers without a fractional part.\nThey are either *signed* (positive, zero, or negative)\nor *unsigned* (positive or zero).\n\nSigned integer types which check for overflow and underflow have an `Int` prefix\nand can represent values in the following ranges:\n\n- **`Int8`**: −2^7 through 2^7 − 1 (-128 through 127)\n- **`Int16`**: −2^15 through 2^15 − 1 (-32768 through 32767)\n- **`Int32`**: −2^31 through 2^31 − 1 (-2147483648 through 2147483647)\n- **`Int64`**: −2^63 through 2^63 − 1 (-9223372036854775808 through 9223372036854775807)\n- **`Int128`**: −2^127 through 2^127 − 1\n- **`Int256`**: −2^255 through 2^255 − 1\n\nUnsigned integer types which check for overflow and underflow have a `UInt` prefix\nand can represent values in the following ranges:\n\n- **`UInt8`**: 0 through 2^8 − 1 (255)\n- **`UInt16`**: 0 through 2^16 − 1 (65535)\n- **`UInt32`**: 0 through 2^32 − 1 (4294967295)\n- **`UInt64`**: 0 through 2^64 − 1 (18446744073709551615)\n- **`UInt128`**: 0 through 2^128 − 1\n- **`UInt256`**: 0 through 2^256 − 1\n\nUnsigned integer types which do **not** check for overflow and underflow,\ni.e. wrap around, have the `Word` prefix\nand can represent values in the following ranges:\n\n- **`Word8`**: 0 through 2^8 − 1 (255)\n- **`Word16`**: 0 through 2^16 − 1 (65535)\n- **`Word32`**: 0 through 2^32 − 1 (4294967295)\n- **`Word64`**: 0 through 2^64 − 1 (18446744073709551615)\n\nThe types are independent types, i.e. not subtypes of each other.\n\nSee the section about [arithmetic operators](operators#arithmetic) for further\ninformation about the behavior of the different integer types.\n\n```cadence\n// Declare a constant that has type `UInt8` and the value 10.\nlet smallNumber: UInt8 = 10\n```\n\n```cadence\n// Invalid: negative literal cannot be used as an unsigned integer\n//\nlet invalidNumber: UInt8 = -10\n```\n\nIn addition, the arbitrary precision integer type `Int` is provided.\n\n```cadence\nlet veryLargeNumber: Int = 10000000000000000000000000000000\n```\n\nInteger literals are [inferred](type-inference) to have type `Int`,\nor if the literal occurs in a position that expects an explicit type,\ne.g. in a variable declaration with an explicit type annotation.\n\n```cadence\nlet someNumber = 123\n\n// `someNumber` has type `Int`\n```\n\nNegative integers are encoded in two's complement representation.\n\nInteger types are not converted automatically. Types must be explicitly converted,\nwhich can be done by calling the constructor of the type with the integer type.\n\n```cadence\nlet x: Int8 = 1\nlet y: Int16 = 2\n\n// Invalid: the types of the operands, `Int8` and `Int16` are incompatible.\nlet z = x + y\n\n// Explicitly convert `x` from `Int8` to `Int16`.\nlet a = Int16(x) + y\n\n// `a` has type `Int16`\n\n// Invalid: The integer literal is expected to be of type `UInt8`,\n// but the large integer literal does not fit in the range of `UInt8`.\n//\nlet b = x + 1000000000000000000000000\n```\n\n### Integer Functions\n\nIntegers have multiple built-in functions you can use.\n\n- `cadence•fun toString(): String`\n\n  Returns the string representation of the integer.\n\n  ```cadence\n  let answer = 42\n\n  answer.toString()  // is \"42\"\n  ```\n\n- `cadence•fun toBigEndianBytes(): [UInt8]`\n\n  Returns the byte array representation (`[UInt8]`) in big-endian order of the integer.\n\n  ```cadence\n  let largeNumber = 1234567890\n\n  largeNumber.toBigEndianBytes()  // is `[73, 150, 2, 210]`\n  ```\n\n## Fixed-Point Numbers\n\n<Callout type=\"info\">\n\n🚧 Status: Currently only the 64-bit wide `Fix64` and `UFix64` types are available.\nMore fixed-point number types will be added in a future release.\n\n</Callout>\n\nFixed-point numbers are useful for representing fractional values.\nThey have a fixed number of digits after decimal point.\n\nThey are essentially integers which are scaled by a factor.\nFor example, the value 1.23 can be represented as 1230 with a scaling factor of 1/1000.\nThe scaling factor is the same for all values of the same type\nand stays the same during calculations.\n\nFixed-point numbers in Cadence have a scaling factor with a power of 10, instead of a power of 2,\ni.e. they are decimal, not binary.\n\nSigned fixed-point number types have the prefix `Fix`,\nhave the following factors, and can represent values in the following ranges:\n\n- **`Fix64`**: Factor 1/100,000,000; -92233720368.54775808 through 92233720368.54775807\n\nUnsigned fixed-point number types have the prefix `UFix`,\nhave the following factors, and can represent values in the following ranges:\n\n- **`UFix64`**: Factor 1/100,000,000; 0.0 through 184467440737.09551615\n\n### Fixed-Point Number Functions\n\nFixed-Point numbers have multiple built-in functions you can use.\n\n- `cadence•fun toString(): String`\n\n  Returns the string representation of the fixed-point number.\n\n  ```cadence\n  let fix = 1.23\n\n  fix.toString()  // is \"1.23000000\"\n  ```\n\n- `cadence•fun toBigEndianBytes(): [UInt8]`\n\n  Returns the byte array representation (`[UInt8]`) in big-endian order of the fixed-point number.\n\n  ```cadence\n  let fix = 1.23\n\n  fix.toBigEndianBytes()  // is `[0, 0, 0, 0, 7, 84, 212, 192]`\n  ```\n\n## Floating-Point Numbers\n\nThere is **no** support for floating point numbers.\n\nSmart Contracts are not intended to work with values with error margins\nand therefore floating point arithmetic is not appropriate here.\n\nInstead, consider using [fixed point numbers](#fixed-point-numbers).\n\n## Addresses\n\nThe type `Address` represents an address.\nAddresses are unsigned integers with a size of 64 bits (8 bytes).\nHexadecimal integer literals can be used to create address values.\n\n```cadence\n// Declare a constant that has type `Address`.\n//\nlet someAddress: Address = 0x436164656E636521\n\n// Invalid: Initial value is not compatible with type `Address`,\n// it is not a number.\n//\nlet notAnAddress: Address = \"\"\n\n// Invalid: Initial value is not compatible with type `Address`.\n// The integer literal is valid, however, it is larger than 64 bits.\n//\nlet alsoNotAnAddress: Address = 0x436164656E63652146757265766572\n```\n\nInteger literals are not inferred to be an address.\n\n```cadence\n// Declare a number. Even though it happens to be a valid address,\n// it is not inferred as it.\n//\nlet aNumber = 0x436164656E636521\n\n// `aNumber` has type `Int`\n```\n\n### Address Functions\n\nAddresses have multiple built-in functions you can use.\n\n- `cadence•fun toString(): String`\n\n  Returns the string representation of the address.\n\n  ```cadence\n  let someAddress: Address = 0x436164656E636521\n\n  someAddress.toString()  // is \"0x436164656E636521\"\n  ```\n\n- `cadence•fun toBigEndianBytes(): [UInt8]`\n\n  Returns the byte array representation (`[UInt8]`) of the address.\n\n  ```cadence\n  let someAddress: Address = 0x436164656E636521\n\n  someAddress.toString()  // is `[67, 97, 100, 101, 110, 99, 101, 33]`\n  ```\n\n## AnyStruct and AnyResource\n\n`AnyStruct` is the top type of all non-resource types,\ni.e., all non-resource types are a subtype of it.\n\n`AnyResource` is the top type of all resource types.\n\n```cadence\n// Declare a variable that has the type `AnyStruct`.\n// Any non-resource typed value can be assigned to it, for example an integer,\n// but not resource-typed values.\n//\nvar someStruct: AnyStruct = 1\n\n// Assign a value with a different non-resource type, `Bool`.\nsomeStruct = true\n\n// Declare a structure named `TestStruct`, create an instance of it,\n// and assign it to the `AnyStruct`-typed variable\n//\nstruct TestStruct {}\n\nlet testStruct = TestStruct()\n\nsomeStruct = testStruct\n\n// Declare a resource named `TestResource`\n\nresource Test {}\n\n// Declare a variable that has the type `AnyResource`.\n// Any resource-typed value can be assigned to it,\n// but not non-resource typed values.\n//\nvar someResource: @AnyResource <- create Test()\n\n// Invalid: Resource-typed values can not be assigned\n// to `AnyStruct`-typed variables\n//\nsomeStruct <- create Test()\n\n// Invalid: Non-resource typed values can not be assigned\n// to `AnyResource`-typed variables\n//\nsomeResource = 1\n```\n\nHowever, using `AnyStruct` and `AnyResource` does not opt-out of type checking.\nIt is invalid to access fields and call functions on these types,\nas they have no fields and functions.\n\n```cadence\n// Declare a variable that has the type `AnyStruct`.\n// The initial value is an integer,\n// but the variable still has the explicit type `AnyStruct`.\n//\nlet a: AnyStruct = 1\n\n// Invalid: Operator cannot be used for an `AnyStruct` value (`a`, left-hand side)\n// and an `Int` value (`2`, right-hand side).\n//\na + 2\n```\n\n`AnyStruct` and `AnyResource` may be used like other types,\nfor example, they may be the element type of [arrays](#arrays)\nor be the element type of an [optional type](#optionals).\n\n```cadence\n// Declare a variable that has the type `[AnyStruct]`,\n// i.e. an array of elements of any non-resource type.\n//\nlet anyValues: [AnyStruct] = [1, \"2\", true]\n\n// Declare a variable that has the type `AnyStruct?`,\n// i.e. an optional type of any non-resource type.\n//\nvar maybeSomething: AnyStruct? = 42\n\nmaybeSomething = \"twenty-four\"\n\nmaybeSomething = nil\n```\n\n`AnyStruct` is also the super-type of all non-resource optional types,\nand `AnyResource` is the super-type of all resource optional types.\n\n```cadence\nlet maybeInt: Int? = 1\nlet anything: AnyStruct = maybeInt\n```\n\n[Conditional downcasting](operators#conditional-downcasting-operator) allows coercing\na value which has the type `AnyStruct` or `AnyResource` back to its original type.\n\n## Optionals\n\nOptionals are values which can represent the absence of a value. Optionals have two cases:\neither there is a value, or there is nothing.\n\nAn optional type is declared using the `?` suffix for another type.\nFor example, `Int` is a non-optional integer, and `Int?` is an optional integer,\ni.e. either nothing, or an integer.\n\nThe value representing nothing is `nil`.\n\n```cadence\n// Declare a constant which has an optional integer type,\n// with nil as its initial value.\n//\nlet a: Int? = nil\n\n// Declare a constant which has an optional integer type,\n// with 42 as its initial value.\n//\nlet b: Int? = 42\n\n// Invalid: `b` has type `Int?`, which does not support arithmetic.\nb + 23\n\n// Invalid: Declare a constant with a non-optional integer type `Int`,\n// but the initial value is `nil`, which in this context has type `Int?`.\n//\nlet x: Int = nil\n```\n\nOptionals can be created for any value, not just for literals.\n\n```cadence\n// Declare a constant which has a non-optional integer type,\n// with 1 as its initial value.\n//\nlet x = 1\n\n// Declare a constant which has an optional integer type.\n// An optional with the value of `x` is created.\n//\nlet y: Int? = x\n\n// Declare a variable which has an optional any type, i.e. the variable\n// may be `nil`, or any other value.\n// An optional with the value of `x` is created.\n//\nvar z: AnyStruct? = x\n```\n\nA non-optional type is a subtype of its optional type.\n\n```cadence\nvar a: Int? = nil\nlet b = 2\na = b\n\n// `a` is `2`\n```\n\nOptional types may be contained in other types, for example [arrays](#arrays) or even optionals.\n\n```cadence\n// Declare a constant which has an array type of optional integers.\nlet xs: [Int?] = [1, nil, 2, nil]\n\n// Declare a constant which has a double optional type.\n//\nlet doubleOptional: Int?? = nil\n```\n\n### Nil-Coalescing Operator\n\nThe nil-coalescing operator `??` returns\nthe value inside an optional if it contains a value,\nor returns an alternative value if the optional has no value,\ni.e., the optional value is `nil`.\n\nIf the left-hand side is non-nil, the right-hand side is not evaluated.\n\n```cadence\n// Declare a constant which has an optional integer type\n//\nlet a: Int? = nil\n\n// Declare a constant with a non-optional integer type,\n// which is initialized to `a` if it is non-nil, or 42 otherwise.\n//\nlet b: Int = a ?? 42\n// `b` is 42, as `a` is nil\n```\n\nThe nil-coalescing operator can only be applied\nto values which have an optional type.\n\n```cadence\n// Declare a constant with a non-optional integer type.\n//\nlet a = 1\n\n// Invalid: nil-coalescing operator is applied to a value which has a non-optional type\n// (a has the non-optional type `Int`).\n//\nlet b = a ?? 2\n```\n\n```cadence\n// Invalid: nil-coalescing operator is applied to a value which has a non-optional type\n// (the integer literal is of type `Int`).\n//\nlet c = 1 ?? 2\n```\n\nThe type of the right-hand side of the operator (the alternative value) must be a subtype\nof the type of left-hand side, i.e. the right-hand side of the operator must\nbe the non-optional or optional type matching the type of the left-hand side.\n\n```cadence\n// Declare a constant with an optional integer type.\n//\nlet a: Int? = nil\nlet b: Int? = 1\nlet c = a ?? b\n// `c` is `1` and has type `Int?`\n\n// Invalid: nil-coalescing operator is applied to a value of type `Int?`,\n// but the alternative has type `Bool`.\n//\nlet d = a ?? false\n```\n\n### Force Unwrap (`!`)\n\nThe force-unwrap operator (`!`) returns\nthe value inside an optional if it contains a value,\nor panics and aborts the execution if the optional has no value,\ni.e., the optional value is `nil`.\n\n```cadence\n// Declare a constant which has an optional integer type\n//\nlet a: Int? = nil\n\n// Declare a constant with a non-optional integer type,\n// which is initialized to `a` if `a` is non-nil.\n// If `a` is nil, the program aborts.\n//\nlet b: Int = a!\n// The program aborts because `a` is nil.\n\n// Declare another optional integer constant\nlet c: Int? = 3\n\n// Declare a non-optional integer\n// which is initialized to `c` if `a` is non-nil.\n// If `c` is nil, the program aborts.\nlet d: Int = c!\n// `d` is initialized to 3 because c isn't nil.\n\n```\n\nThe force-unwrap operator can only be applied\nto values which have an optional type.\n\n```cadence\n// Declare a constant with a non-optional integer type.\n//\nlet a = 1\n\n// Invalid: force-unwrap operator is applied to a value which has a\n// non-optional type (`a` has the non-optional type `Int`).\n//\nlet b = a!\n```\n\n```cadence\n// Invalid: The force-unwrap operator is applied\n// to a value which has a non-optional type\n// (the integer literal is of type `Int`).\n//\nlet c = 1!\n```\n\n### Force-assignment operator (`<-!`)\n\nThe force-assignment operator (`<-!`) assigns a resource-typed value to an\noptional-typed variable if the variable is nil.\nIf the variable being assigned to is non-nil,\nthe execution of the program aborts.\n\nThe force-assignment operator is only used for\n[resource types](composite-types#resources) and the move operator (`<-`),\nwhich are covered in the resources section of this document.\n\n### Conditional Downcasting Operator\n\n<Callout type=\"info\">\n\n🚧 Status: The conditional downcasting operator `as?` is implemented,\nbut it only supports values that have the type `AnyStruct` and `AnyResource`.\n\n</Callout>\n\nThe conditional downcasting operator `as?`\ncan be used to type cast a value to a type.\nThe operator returns an optional.\nIf the value has a type that is a subtype\nof the given type that should be casted to,\nthe operator returns the value as the given type,\notherwise the result is `nil`.\n\nThe cast and check is performed at run-time, i.e. when the program is executed,\nnot statically, i.e. when the program is checked.\n\n```cadence\n// Declare a constant named `something` which has type `AnyStruct`,\n// with an initial value which has type `Int`.\n//\nlet something: AnyStruct = 1\n\n// Conditionally downcast the value of `something` to `Int`.\n// The cast succeeds, because the value has type `Int`.\n//\nlet number = something as? Int\n// `number` is `1` and has type `Int?`\n\n// Conditionally downcast the value of `something` to `Bool`.\n// The cast fails, because the value has type `Int`,\n// and `Bool` is not a subtype of `Int`.\n//\nlet boolean = something as? Bool\n// `boolean` is `nil` and has type `Bool?`\n```\n\nDowncasting works for nested types (e.g. arrays),\ninterfaces (if a [resource](composite-types#resources) interface not to a concrete resource),\nand optionals.\n\n```cadence\n// Declare a constant named `values` which has type `[AnyStruct]`,\n// i.e. an array of arbitrarily typed values.\n//\nlet values: [AnyStruct] = [1, true]\n\nlet first = values[0] as? Int\n// `first` is `1` and has type `Int?`\n\nlet second = values[1] as? Bool\n// `second` is `true` and has type `Bool?`\n```\n\n## Never\n\n`Never` is the bottom type, i.e., it is a subtype of all types.\nThere is no value that has type `Never`.\n`Never` can be used as the return type for functions that never return normally.\nFor example, it is the return type of the function [`panic`](built-in-functions#panic).\n\n```cadence\n// Declare a function named `crashAndBurn` which will never return,\n// because it calls the function named `panic`, which never returns.\n//\nfun crashAndBurn(): Never {\n    panic(\"An unrecoverable error occurred\")\n}\n\n// Invalid: Declare a constant with a `Never` type, but the initial value is an integer.\n//\nlet x: Never = 1\n\n// Invalid: Declare a function which returns an invalid return value `nil`,\n// which is not a value of type `Never`.\n//\nfun returnNever(): Never {\n    return nil\n}\n```\n\n## Strings and Characters\n\nStrings are collections of characters.\nStrings have the type `String`, and characters have the type `Character`.\nStrings can be used to work with text in a Unicode-compliant way.\nStrings are immutable.\n\nString and character literals are enclosed in double quotation marks (`\"`).\n\n```cadence\nlet someString = \"Hello, world!\"\n```\n\nString literals may contain escape sequences. An escape sequence starts with a backslash (`\\`):\n\n- `\\0`: Null character\n- `\\\\`: Backslash\n- `\\t`: Horizontal tab\n- `\\n`: Line feed\n- `\\r`: Carriage return\n- `\\\"`: Double quotation mark\n- `\\'`: Single quotation mark\n- `\\u`: A Unicode scalar value, written as `\\u{x}`,\n  where `x` is a 1–8 digit hexadecimal number\n  which needs to be a valid Unicode scalar value,\n  i.e., in the range 0 to 0xD7FF and 0xE000 to 0x10FFFF inclusive\n\n```cadence\n// Declare a constant which contains two lines of text\n// (separated by the line feed character `\\n`), and ends\n// with a thumbs up emoji, which has code point U+1F44D (0x1F44D).\n//\nlet thumbsUpText =\n    \"This is the first line.\\nThis is the second line with an emoji: \\u{1F44D}\"\n```\n\nThe type `Character` represents a single, human-readable character.\nCharacters are extended grapheme clusters,\nwhich consist of one or more Unicode scalars.\n\nFor example, the single character `ü` can be represented\nin several ways in Unicode.\nFirst, it can be represented by a single Unicode scalar value `ü`\n(\"LATIN SMALL LETTER U WITH DIAERESIS\", code point U+00FC).\nSecond, the same single character can be represented\nby two Unicode scalar values:\n`u` (\"LATIN SMALL LETTER U\", code point U+0075),\nand \"COMBINING DIAERESIS\" (code point U+0308).\nThe combining Unicode scalar value is applied to the scalar before it,\nwhich turns a `u` into a `ü`.\n\nStill, both variants represent the same human-readable character `ü`.\n\n```cadence\nlet singleScalar: Character = \"\\u{FC}\"\n// `singleScalar` is `ü`\nlet twoScalars: Character = \"\\u{75}\\u{308}\"\n// `twoScalars` is `ü`\n```\n\nAnother example where multiple Unicode scalar values are rendered as a single,\nhuman-readable character is a flag emoji.\nThese emojis consist of two \"REGIONAL INDICATOR SYMBOL LETTER\" Unicode scalar values.\n\n```cadence\n// Declare a constant for a string with a single character, the emoji\n// for the Canadian flag, which consists of two Unicode scalar values:\n// - REGIONAL INDICATOR SYMBOL LETTER C (U+1F1E8)\n// - REGIONAL INDICATOR SYMBOL LETTER A (U+1F1E6)\n//\nlet canadianFlag: Character = \"\\u{1F1E8}\\u{1F1E6}\"\n// `canadianFlag` is `🇨🇦`\n```\n\n### String Fields and Functions\n\nStrings have multiple built-in functions you can use.\n\n- `cadence•let length: Int`\n\n  Returns the number of characters in the string as an integer.\n\n  ```cadence\n  let example = \"hello\"\n\n  // Find the number of elements of the string.\n  let length = example.length\n  // `length` is `5`\n  ```\n\n- `cadence•fun concat(_ other: String): String`\n\n  Concatenates the string `other` to the end of the original string,\n  but does not modify the original string.\n  This function creates a new string whose length is the sum of the lengths\n  of the string the function is called on and the string given as a parameter.\n\n  ```cadence\n  let example = \"hello\"\n  let new = \"world\"\n\n  // Concatenate the new string onto the example string and return thenew string.\n  let helloWorld = example.concat(new)\n  // `helloWorld` is now `\"helloworld\"`\n  ```\n\n- `cadence•fun slice(from: Int, upTo: Int): String`\n\n  Returns a string slice of the characters\n  in the given string from start index `from` up to,\n  but not including, the end index `upTo`.\n  This function creates a new string whose length is `upTo - from`.\n  It does not modify the original string.\n  If either of the parameters are out of\n  the bounds of the string, the function will fail.\n\n  ```cadence\n  let example = \"helloworld\"\n\n  // Create a new slice of part of the original string.\n  let slice = example.slice(from: 3, upTo: 6)\n  // `slice` is now `\"lowo\"`\n\n  // Run-time error: Out of bounds index, the program aborts.\n  let outOfBounds = example.slice(from: 2, upTo: 10)\n  ```\n\n- `cadence•fun decodeHex(): [UInt8]`\n\n  Returns an array containing the bytes represented by the given hexadecimal string.\n\n  The given string must only contain hexadecimal characters and must have an even length.\n  If the string is malformed, the program aborts\n\n  ```cadence\n  let example = \"436164656e636521\"\n\n  example.decodeHex()  // is `[67, 97, 100, 101, 110, 99, 101, 33]`\n  ```\n\n## Arrays\n\nArrays are mutable, ordered collections of values.\nAll values in an array must have the same type.\nArrays may contain a value multiple times.\nArray literals start with an opening square bracket `[` and end with a closing square bracket `]`.\n\n```cadence\n// An empty array\n//\n[]\n\n// An array with integers\n//\n[1, 2, 3]\n\n// Invalid: mixed types\n//\n[1, true, 2, false]\n```\n\n### Array Types\n\nArrays either have a fixed size or are variably sized, i.e., elements can be added and removed.\n\nFixed-size arrays have the form `[T; N]`, where `T` is the element type,\nand `N` is the size of the array.  `N` has to be statically known, meaning\nthat it needs to be an integer literal.\nFor example, a fixed-size array of 3 `Int8` elements has the type `[Int8; 3]`.\n\nVariable-size arrays have the form `[T]`, where `T` is the element type.\nFor example, the type `[Int16]` specifies a variable-size array of elements that have type `Int16`.\n\nIt is important to understand that arrays are value types and are only ever copied\nwhen used as an initial value for a constant or variable,\nwhen assigning to a variable,\nwhen used as function argument,\nor when returned from a function call.\n\n```cadence\nlet size = 2\n// Invalid: Array-size must be an integer literal\nlet numbers: [Int; size] = []\n\n// Declare a fixed-sized array of integers\n// which always contains exactly two elements.\n//\nlet array: [Int8; 2] = [1, 2]\n\n// Declare a fixed-sized array of fixed-sized arrays of integers.\n// The inner arrays always contain exactly three elements,\n// the outer array always contains two elements.\n//\nlet arrays: [[Int16; 3]; 2] = [\n    [1, 2, 3],\n    [4, 5, 6]\n]\n\n// Declare a variable length array of integers\nvar variableLengthArray: [Int] = []\n```\n\nArray types are covariant in their element types.\nFor example, `[Int]` is a subtype of `[AnyStruct]`.\nThis is safe because arrays are value types and not reference types.\n\n### Array Indexing\n\nTo get the element of an array at a specific index, the indexing syntax can be used:\nThe array is followed by an opening square bracket `[`, the indexing value,\nand ends with a closing square bracket `]`.\n\nIndexes start at 0 for the first element in the array.\n\nAccessing an element which is out of bounds results in a fatal error at run-time\nand aborts the program.\n\n```cadence\n// Declare an array of integers.\nlet numbers = [42, 23]\n\n// Get the first number of the array.\n//\nnumbers[0] // is `42`\n\n// Get the second number of the array.\n//\nnumbers[1] // is `23`\n\n// Run-time error: Index 2 is out of bounds, the program aborts.\n//\nnumbers[2]\n```\n\n```cadence\n// Declare an array of arrays of integers, i.e. the type is `[[Int]]`.\nlet arrays = [[1, 2], [3, 4]]\n\n// Get the first number of the second array.\n//\narrays[1][0] // is `3`\n```\n\nTo set an element of an array at a specific index, the indexing syntax can be used as well.\n\n```cadence\n// Declare an array of integers.\nlet numbers = [42, 23]\n\n// Change the second number in the array.\n//\n// NOTE: The declaration `numbers` is constant, which means that\n// the *name* is constant, not the *value* – the value, i.e. the array,\n// is mutable and can be changed.\n//\nnumbers[1] = 2\n\n// `numbers` is `[42, 2]`\n```\n\n### Array Fields and Functions\n\nArrays have multiple built-in fields and functions\nthat can be used to get information about and manipulate the contents of the array.\n\nThe field `length`, and the functions `concat`, and `contains`\nare available for both variable-sized and fixed-sized or variable-sized arrays.\n\n- `cadence•let length: Int`\n\n  The number of elements in the array.\n\n  ```cadence\n  // Declare an array of integers.\n  let numbers = [42, 23, 31, 12]\n\n  // Find the number of elements of the array.\n  let length = numbers.length\n\n  // `length` is `4`\n  ```\n\n- `cadence•fun concat(_ array: T): T`\n\n  Concatenates the parameter `array` to the end\n  of the array the function is called on,\n  but does not modify that array.\n\n  Both arrays must be the same type `T`.\n\n  This function creates a new array whose length is the sum of the length of the array\n  the function is called on and the length of the array given as the parameter.\n\n  ```cadence\n  // Declare two arrays of integers.\n  let numbers = [42, 23, 31, 12]\n  let moreNumbers = [11, 27]\n\n  // Concatenate the array `moreNumbers` to the array `numbers`\n  // and declare a new variable for the result.\n  //\n  let allNumbers = numbers.concat(moreNumbers)\n\n  // `allNumbers` is `[42, 23, 31, 12, 11, 27]`\n  // `numbers` is still `[42, 23, 31, 12]`\n  // `moreNumbers` is still `[11, 27]`\n  ```\n\n- `cadence•fun contains(_ element: T): Bool`\n\n  Returns true if the given element of type `T` is in the array.\n\n  ```cadence\n  // Declare an array of integers.\n  let numbers = [42, 23, 31, 12]\n\n  // Check if the array contains 11.\n  let containsEleven = numbers.contains(11)\n  // `containsEleven` is `false`\n\n  // Check if the array contains 12.\n  let containsTwelve = numbers.contains(12)\n  // `containsTwelve` is `true`\n\n  // Invalid: Check if the array contains the string \"Kitty\".\n  // This results in a type error, as the array only contains integers.\n  //\n  let containsKitty = numbers.contains(\"Kitty\")\n  ```\n\n#### Variable-size Array Functions\n\nThe following functions can only be used on variable-sized arrays.\nIt is invalid to use one of these functions on a fixed-sized array.\n\n- `cadence•fun append(_ element: T): Void`\n\n  Adds the new element `element` of type `T` to the end of the array.\n\n  The new element must be the same type as all the other elements in the array.\n\n  ```cadence\n  // Declare an array of integers.\n  let numbers = [42, 23, 31, 12]\n\n  // Add a new element to the array.\n  numbers.append(20)\n  // `numbers` is now `[42, 23, 31, 12, 20]`\n\n  // Invalid: The parameter has the wrong type `String`.\n  numbers.append(\"SneakyString\")\n  ```\n\n- `cadence•fun insert(at index: Int, _ element: T): Void`\n\n  Inserts the new element `element` of type `T`\n  at the given `index` of the array.\n\n  The new element must be of the same type as the other elements in the array.\n\n  The `index` must be within the bounds of the array.\n  If the index is outside the bounds, the program aborts.\n\n  The existing element at the supplied index is not overwritten.\n\n  All the elements after the new inserted element\n  are shifted to the right by one.\n\n  ```cadence\n  // Declare an array of integers.\n  let numbers = [42, 23, 31, 12]\n\n  // Insert a new element at position 1 of the array.\n  numbers.insert(at: 1, 20)\n  // `numbers` is now `[42, 20, 23, 31, 12]`\n\n  // Run-time error: Out of bounds index, the program aborts.\n  numbers.insert(at: 12, 39)\n  ```\n\n- `cadence•fun remove(at index: Int): T`\n\n  Removes the element at the given `index` from the array and returns it.\n\n  The `index` must be within the bounds of the array.\n  If the index is outside the bounds, the program aborts.\n\n  ```cadence\n  // Declare an array of integers.\n  let numbers = [42, 23, 31]\n\n  // Remove element at position 1 of the array.\n  let twentyThree = numbers.remove(at: 1)\n  // `numbers` is now `[42, 31]`\n  // `twentyThree` is `23`\n\n  // Run-time error: Out of bounds index, the program aborts.\n  numbers.remove(at: 19)\n  ```\n\n- `cadence•fun removeFirst(): T`\n\n  Removes the first element from the array and returns it.\n\n  The array must not be empty.\n  If the array is empty, the program aborts.\n\n  ```cadence\n  // Declare an array of integers.\n  let numbers = [42, 23]\n\n  // Remove the first element of the array.\n  let fortytwo = numbers.removeFirst()\n  // `numbers` is now `[23]`\n  // `fortywo` is `42`\n\n  // Remove the first element of the array.\n  let twentyThree = numbers.removeFirst()\n  // `numbers` is now `[]`\n  // `twentyThree` is `23`\n\n  // Run-time error: The array is empty, the program aborts.\n  numbers.removeFirst()\n  ```\n\n- `cadence•fun removeLast(): T`\n\n  Removes the last element from the array and returns it.\n\n  The array must not be empty.\n  If the array is empty, the program aborts.\n\n  ```cadence\n  // Declare an array of integers.\n  let numbers = [42, 23]\n\n  // Remove the last element of the array.\n  let twentyThree = numbers.removeLast()\n  // `numbers` is now `[42]`\n  // `twentyThree` is `23`\n\n  // Remove the last element of the array.\n  let fortyTwo = numbers.removeLast()\n  // `numbers` is now `[]`\n  // `fortyTwo` is `42`\n\n  // Run-time error: The array is empty, the program aborts.\n  numbers.removeLast()\n  ```\n\n## Dictionaries\n\nDictionaries are mutable, unordered collections of key-value associations.\nIn a dictionary, all keys must have the same type,\nand all values must have the same type.\nDictionaries may contain a key only once and\nmay contain a value multiple times.\n\nDictionary literals start with an opening brace `{`\nand end with a closing brace `}`.\nKeys are separated from values by a colon,\nand key-value associations are separated by commas.\n\n```cadence\n// An empty dictionary\n//\n{}\n\n// A dictionary which associates integers with booleans\n//\n{\n    1: true,\n    2: false\n}\n\n// Invalid: mixed types\n//\n{\n    1: true,\n    false: 2\n}\n```\n\n### Dictionary Types\n\nDictionaries have the form `{K: V}`,\nwhere `K` is the type of the key,\nand `V` is the type of the value.\nFor example, a dictionary with `Int` keys and `Bool`\nvalues has type `{Int: Bool}`.\n\n```cadence\n// Declare a constant that has type `{Int: Bool}`,\n// a dictionary mapping integers to booleans.\n//\nlet booleans = {\n    1: true,\n    0: false\n}\n\n// Declare a constant that has type `{Bool: Int}`,\n// a dictionary mapping booleans to integers.\n//\nlet integers = {\n    true: 1,\n    false: 0\n}\n```\n\nDictionary types are covariant in their key and value types.\nFor example, `{Int: String}` is a subtype of `{AnyStruct: String}`\nand also a subtype of `{Int: AnyStruct}`.\nThis is safe because dictionaries are value types and not reference types.\n\n### Dictionary Access\n\nTo get the value for a specific key from a dictionary,\nthe access syntax can be used:\nThe dictionary is followed by an opening square bracket `[`, the key,\nand ends with a closing square bracket `]`.\n\nAccessing a key returns an [optional](#optionals):\nIf the key is found in the dictionary, the value for the given key is returned,\nand if the key is not found, `nil` is returned.\n\n```cadence\n// Declare a constant that has type `{Bool: Int}`,\n// a dictionary mapping integers to booleans.\n//\nlet booleans = {\n    1: true,\n    0: false\n}\n\n// The result of accessing a key has type `Bool?`.\n//\nbooleans[1]  // is `true`\nbooleans[0]  // is `false`\nbooleans[2]  // is `nil`\n\n// Invalid: Accessing a key which does not have type `Int`.\n//\nbooleans[\"1\"]\n```\n\n```cadence\n// Declare a constant that has type `{Bool: Int}`,\n// a dictionary mapping booleans to integers.\n//\nlet integers = {\n    true: 1,\n    false: 0\n}\n\n// The result of accessing a key has type `Int?`\n//\nintegers[true] // is `1`\nintegers[false] // is `0`\n```\n\nTo set the value for a key of a dictionary,\nthe access syntax can be used as well.\n\n```cadence\n// Declare a constant that has type `{Int: Bool}`,\n// a dictionary mapping booleans to integers.\n//\nlet booleans = {\n    1: true,\n    0: false\n}\n\n// Assign new values for the keys `1` and `0`.\n//\nbooleans[1] = false\nbooleans[0] = true\n// `booleans` is `{1: false, 0: true}`\n```\n\n### Dictionary Fields and Functions\n\n- `cadence•let length: Int`\n\n  The number of entries in the dictionary.\n\n  ```cadence\n  // Declare a dictionary mapping strings to integers.\n  let numbers = {\"fortyTwo\": 42, \"twentyThree\": 23}\n\n  // Find the number of entries of the dictionary.\n  let length = numbers.length\n\n  // `length` is `2`\n  ```\n\n- `cadence•fun insert(key: K, _ value: V): V?`\n\n  Inserts the given value of type `V` into the dictionary under the given `key` of type `K`.\n\n  Returns the previous value as an optional\n  if the dictionary contained the key,\n  otherwise `nil`.\n\n  ```cadence\n  // Declare a dictionary mapping strings to integers.\n  let numbers = {\"twentyThree\": 23}\n\n  // Insert the key `\"fortyTwo\"` with the value `42` into the dictionary.\n  // The key did not previously exist in the dictionary,\n  // so the result is `nil`\n  //\n  let old = numbers.insert(key: \"fortyTwo\", 42)\n\n  // `old` is `nil`\n  // `numbers` is `{\"twentyThree\": 23, \"fortyTwo\": 42}`\n  ```\n\n- `cadence•fun remove(key: K): V?`\n\n  Removes the value for the given `key` of type `K` from the dictionary.\n\n  Returns the value of type `V` as an optional\n  if the dictionary contained the key,\n  otherwise `nil`.\n\n  ```cadence\n  // Declare a dictionary mapping strings to integers.\n  let numbers = {\"fortyTwo\": 42, \"twentyThree\": 23}\n\n  // Remove the key `\"fortyTwo\"` from the dictionary.\n  // The key exists in the dictionary,\n  // so the value associated with the key is returned.\n  //\n  let fortyTwo = numbers.remove(key: \"fortyTwo\")\n\n  // `fortyTwo` is `42`\n  // `numbers` is `{\"twentyThree\": 23}`\n\n  // Remove the key `\"oneHundred\"` from the dictionary.\n  // The key does not exist in the dictionary, so `nil` is returned.\n  //\n  let oneHundred = numbers.remove(key: \"oneHundred\")\n\n  // `oneHundred` is `nil`\n  // `numbers` is `{\"twentyThree\": 23}`\n  ```\n\n- `cadence•let keys: [K]`\n\n  Returns an array of the keys of type `K` in the dictionary.  This does not\n  modify the dictionary, just returns a copy of the keys as an array.\n  If the dictionary is empty, this returns an empty array.\n\n  ```cadence\n  // Declare a dictionary mapping strings to integers.\n  let numbers = {\"fortyTwo\": 42, \"twentyThree\": 23}\n\n  // Find the keys of the dictionary.\n  let keys = numbers.keys\n\n  // `keys` has type `[String]` and is `[\"fortyTwo\",\"twentyThree\"]`\n  ```\n\n- `cadence•let values: [V]`\n\n  Returns an array of the values of type `V` in the dictionary.  This does not\n  modify the dictionary, just returns a copy of the values as an array.\n  If the dictionary is empty, this returns an empty array.\n\n  This field is not available if `V` is a resource type.\n\n  ```cadence\n  // Declare a dictionary mapping strings to integers.\n  let numbers = {\"fortyTwo\": 42, \"twentyThree\": 23}\n\n  // Find the values of the dictionary.\n  let values = numbers.values\n\n  // `values` has type [Int] and is `[42, 23]`\n  ```\n\n### Dictionary Keys\n\nDictionary keys must be hashable and equatable,\ni.e., must implement the [`Hashable`](../interfaces#hashable-interface)\nand [`Equatable`](../interfaces#equatable-interface) [interfaces](../interfaces).\n\nMost of the built-in types, like booleans and integers,\nare hashable and equatable, so can be used as keys in dictionaries.\n","path":"language/values-and-types-x"}],"root":[{"content":null,"path":"/cadence-implementation-present-and-future-odp"},{"content":null,"path":"/cadence-implementation-present-and-future-pdf"},{"content":"# FAQ\n\n## Is there a formal grammar (e.g. in BNF) for Cadence?\n\nYes, there is a [EBNF for Cadence](https://github.com/onflow/cadence/blob/master/docs/cadence.ebnf).\n\n## How can we get syntax highlighting on GitHub?\n\nSyntax highlighting for GitHub is implemented in the [`linguist`](https://github.com/github/linguist) library.\nLinguist supports TextMate grammars, and we already have a [TextMate grammar for Cadence in the Visual Studio Code extension](https://github.com/onflow/vscode-flow/blob/master/syntaxes/cadence.tmGrammar.json).\n\nHowever, GitHub \"[...] prefers that each new file extension be in use in hundreds of repositories before supporting them in Linguist\".\nOnce we have reached this threshold for Cadence, we should add support for Cadence to linguist.\n\n## How can I inject additional values when executing a transaction or script?\n\nThe runtime `Interface` functions `ExecuteTransaction` and `ExecuteScript` require a `Context` argument.\nThe context has a `PredeclaredValues` field, which can be filled with `ValueDeclaration` values.\n\nOptionally, value declarations may have a predicate function `Available` of type `func(common.Location) bool`.\nThe checker calls this function for every location that is checked,\nto determine if the value declaration should be available/declared in the given location.\n\nFor example, this allows declaring a function that is only available in the service account.\nIn this case, the availability function would need to check if the location is an `AddressLocation`,\nand that the address of the address location is the address of the service account.\n","path":"/faq"},{"content":"# Documentation\n\nThis directory contains the documentation for Cadence.\n\nThe [`language` directory](https://github.com/onflow/cadence/tree/master/docs/language) contains the Cadence Language Reference.\nThe contents of this directory are deployed to the [Flow Documentation website](https://docs.onflow.org).\nThis is done through the `docs` directory in the [`onflow/flow` repository](https://github.com/onflow/flow),\nwhich pulls in the content when it is built.\n\nThe remaining files in this directory can be considered developer/contributor documentation.\n\nDocumentation is written in Markdown or [MDX](https://mdxjs.com/), an extension of Markdown.\n","path":"/readme"},{"content":"(*\n\nCadence's grammar is described by a dialect of Extended Backus-Naur Form (EBNF),\nrather than the dialect given in ISO 14977.\n\nThe dialect can be defined self-referentially as follows:\n\n    grammar : rule + ;\n    rule : nonterminal ':' productionrule ';' ;\n    productionrule : production ( '|' production )* ;\n    production : term* ;\n    term : element repeats? ;\n    element\n        : LITERAL\n        | '~'? SET\n        | ( IDENTIFIER '=' )? IDENTIFIER\n        | '(' productionrule ')'\n        ;\n    repeats : '?' | '*' | '+' ;\n\nWhere:\n  - Whitespace in the grammar is ignored.\n  - Square brackets are used to group rules.\n  - LITERAL are printable ASCII characters or escaped characters enclosed in single quotes.\n    Escaped characters are hexadecimal ASCII code of the form \\xQQ,\n    denoting the corresponding Unicode codepoint U+00QQ.\n  - IDENTIFIER is a nonempty string of ASCII letters and underscores.\n  - SET is a set of characters enclosed in square brackets. A prefix ~ specifies negation.\n  - The repeat forms apply to the adjacent element, and are as follows:\n      ? means zero or one repetition\n      * means zero or more repetitions\n      + means one or more repetitions\n\nThis EBNF dialect should hopefully be familiar to many readers.\n\n*)\n\nprogram\n    : ( declaration ';'? )* EOF\n    ;\n\nreplInput\n    : replElement* EOF\n    ;\n\nreplElement\n    : replDeclaration\n    | replStatement\n    ;\n\nreplStatement\n    : statement eos\n    ;\n\nreplDeclaration\n    : declaration ';'?\n    ;\n\ndeclaration\n    : compositeDeclaration\n    | interfaceDeclaration\n    | functionDeclaration\n    | variableDeclaration\n    | importDeclaration\n    | eventDeclaration\n    | transactionDeclaration\n    ;\n\ntransactionDeclaration\n    : Transaction\n      parameterList?\n      '{'\n      fields\n      prepare?\n      preConditions?\n      ( execute\n      | execute postConditions\n      | postConditions\n      | postConditions execute\n      | (* no execute or postConditions *)\n      )\n      '}'\n    ;\n\n(*\n  NOTE: allow any identifier in parser, then check identifier\n  is `prepare` in semantic analysis to provide better error\n*)\nprepare\n    : specialFunctionDeclaration\n    ;\n\n(*\n  NOTE: allow any identifier in parser, then check identifier\n  is `execute` in semantic analysis to provide better error\n*)\nexecute\n    : identifier block\n    ;\n\nimportDeclaration\n    : Import ( identifier ( ',' identifier )* From )?\n      ( stringLiteral | HexadecimalLiteral | location=identifier )\n    ;\n\naccess\n    : (* Not specified *)\n    | Priv\n    | Pub ( '(' Set ')' )?\n    | Access '(' ( Self | Contract | Account | All ) ')'\n    ;\n\ncompositeDeclaration\n    : access compositeKind identifier conformances\n      '{' membersAndNestedDeclarations '}'\n    ;\n\nconformances\n    : ( ':' nominalType ( ',' nominalType )* )?\n    ;\n\nvariableKind\n    : Let\n    | Var\n    ;\n\nfield\n    : access variableKind? identifier ':' typeAnnotation\n    ;\n\nfields\n    : ( field ';'? )*\n    ;\n\ninterfaceDeclaration\n    : access compositeKind Interface identifier '{' membersAndNestedDeclarations '}'\n    ;\n\nmembersAndNestedDeclarations\n    : ( memberOrNestedDeclaration ';'? )*\n    ;\n\nmemberOrNestedDeclaration\n    : field\n    | specialFunctionDeclaration\n    | functionDeclaration\n    | interfaceDeclaration\n    | compositeDeclaration\n    | eventDeclaration\n    ;\n\ncompositeKind\n    : Struct\n    | Resource\n    | Contract\n    ;\n\n(*\n  specialFunctionDeclaration is the rule for special function declarations,\n  i.e., those that don't require a `fun` keyword and don't have a return type,\n  e.g. initializers (`init`) and destructors (`destroy`).\n\n  NOTE: allow any identifier in parser, then check identifier is one of\n  the valid identifiers in the semantic analysis to provide better error\n*)\nspecialFunctionDeclaration\n    : identifier parameterList functionBlock?\n    ;\n\nfunctionDeclaration\n    : access Fun identifier parameterList ( ':' returnType=typeAnnotation )? functionBlock?\n    ;\n\neventDeclaration\n    : access Event identifier parameterList\n    ;\n\nparameterList\n    : '(' ( parameter ( ',' parameter )* )? ')'\n    ;\n\nparameter\n    : ( argumentLabel=identifier )? parameterName=identifier ':' typeAnnotation\n    ;\n\ntypeAnnotation\n    : ResourceAnnotation? fullType\n    ;\n\nfullType\n    : ( Auth? Ampersand (* followed by no whitespace *) )?\n      innerType\n      ( (* no whitespace *) optionals+=Optional)*\n    ;\n\n\ninnerType\n    : typeRestrictions\n    | baseType ( (* no whitespace *) typeRestrictions )?\n    ;\n\nbaseType\n    : nominalType\n    | functionType\n    | variableSizedType\n    | constantSizedType\n    | dictionaryType\n    ;\n\ntypeRestrictions\n    : '{' ( nominalType ( ',' nominalType )* )? '}'\n    ;\n\nnominalType\n    : identifier ( '.' identifier )*\n      ( '<' ( typeAnnotation ( ',' typeAnnotation )* )? '>' )?\n    ;\n\nfunctionType\n    : '('\n        '(' ( parameterTypes+=typeAnnotation ( ',' parameterTypes+=typeAnnotation )* )? ')'\n        ':' returnType=typeAnnotation\n      ')'\n    ;\n\nvariableSizedType\n    : '[' fullType ']'\n    ;\n\nconstantSizedType\n    : '[' fullType ';' size=integerLiteral ']'\n    ;\n\ndictionaryType\n    : '{' keyType=fullType ':' valueType=fullType '}'\n    ;\n\nblock\n    : '{' statements '}'\n    ;\n\nfunctionBlock\n    : '{' preConditions? postConditions? statements '}'\n    ;\n\npreConditions\n    : Pre '{' conditions '}'\n    ;\n\npostConditions\n    : Post '{' conditions '}'\n    ;\n\nconditions\n    : ( condition eos )*\n    ;\n\ncondition\n    : test=expression ( ':' message=expression )?\n    ;\n\nstatements\n    : ( statement eos )*\n    ;\n\n(* NOTE: important to have expression last *)\nstatement\n    : returnStatement\n    | breakStatement\n    | continueStatement\n    | ifStatement\n    | whileStatement\n    | forStatement\n    | emitStatement\n    (*\n      NOTE: allow all declarations, even structures, in parser,\n      then check identifier declaration is variable/constant or function\n      in semantic analysis to provide better error\n    *)\n    | declaration\n    | assignment\n    | swap\n    | expression\n    ;\n\n(*\n  only parse the return value expression if it is\n  on the same line. this prevents the return statement\n  from greedily taking an expression from a potentialy\n  following expression statement\n*)\nreturnStatement\n    : Return ( (* if no line terminator ahead *) expression )?\n    ;\n\nbreakStatement\n    : Break\n    ;\n\ncontinueStatement\n    : Continue\n    ;\n\nifStatement\n    : If\n      ( testExpression=expression | testDeclaration=variableDeclaration )\n      then=block\n      ( Else ( ifStatement | alt=block ))?\n    ;\n\nwhileStatement\n    : While expression block\n    ;\n\nforStatement\n    : For identifier In expression block\n    ;\n\nemitStatement\n    : Emit identifier invocation\n    ;\n\n(*\n  Variable declarations might be of the form `let|var <- x <- y`\n*)\nvariableDeclaration\n    : access variableKind identifier ( ':' typeAnnotation )?\n      leftTransfer=transfer leftExpression=expression\n      ( rightTransfer=transfer rightExpression=expression )?\n    ;\n\n(*\n  NOTE: we allow any kind of transfer, i.e. moves, but ensure\n  that move is not used in the semantic analysis (as assignment\n  to resource type will cause a loss of the old value).\n  Being unrestritive here allows us to provide better error messages\n  in the semantic analysis.\n*)\nassignment\n    : target=expression transfer value=expression\n    ;\n\n(*\n  NOTE: we allow expressions on both sides when parsing, but ensure\n  that both sides are targets (identifier, member access, or index access)\n  in the semantic analysis. This allows us to provide better error messages\n*)\nswap\n    : left=expression '<->' right=expression\n    ;\n\ntransfer\n    : '='\n    | Move\n    | MoveForced\n    ;\n\nexpression\n    : conditionalExpression\n    ;\n\nconditionalExpression\n    (* right associative *)\n    : orExpression ( '?' then=expression ':' alt=expression )?\n    ;\n\norExpression\n    : andExpression\n    | orExpression '||' andExpression\n    ;\n\nandExpression\n    : equalityExpression\n    | andExpression '&&' equalityExpression\n    ;\n\nequalityExpression\n    : relationalExpression\n    | equalityExpression equalityOp relationalExpression\n    ;\n\nrelationalExpression\n    : nilCoalescingExpression\n    | relationalExpression relationalOp nilCoalescingExpression\n    ;\n\nnilCoalescingExpression\n    (* NOTE: right associative *)\n    : bitwiseOrExpression ( NilCoalescing nilCoalescingExpression )?\n    ;\n\nbitwiseOrExpression\n    : bitwiseXorExpression\n    | bitwiseOrExpression '|' bitwiseXorExpression\n    ;\n\nbitwiseXorExpression\n    : bitwiseAndExpression\n    | bitwiseXorExpression '^' bitwiseAndExpression\n    ;\n\nbitwiseAndExpression\n    : bitwiseShiftExpression\n    | bitwiseAndExpression '&' bitwiseShiftExpression\n    ;\n\nbitwiseShiftExpression\n    : additiveExpression\n    | bitwiseShiftExpression bitwiseShiftOp additiveExpression\n    ;\n\nadditiveExpression\n    : multiplicativeExpression\n    | additiveExpression additiveOp multiplicativeExpression\n    ;\n\nmultiplicativeExpression\n    : castingExpression\n    | multiplicativeExpression multiplicativeOp castingExpression\n    ;\n\n(*\n  Like in Rust and Kotlin, but unlike Swift,\n  casting has precedence over arithmetic\n*)\ncastingExpression\n    : unaryExpression\n    | castingExpression castingOp typeAnnotation\n    ;\n\nunaryExpression\n    : primaryExpression\n    (*\n      NOTE: allow multiple unary operators, but reject in visitor\n      to provide better error for invalid juxtaposition\n    *)\n    | unaryOp+ unaryExpression\n    ;\n\nprimaryExpression\n    : createExpression\n    | destroyExpression\n    | referenceExpression\n    | postfixExpression\n    ;\n\npostfixExpression\n    : identifier\n    | literal\n    | Fun parameterList ( ':' returnType=typeAnnotation )? functionBlock\n    | '(' expression ')'\n    | postfixExpression (* if no line terminator ahead *) invocation\n    | postfixExpression expressionAccess\n    | postfixExpression (* if no line terminator ahead *) '!'\n    ;\n\nequalityOp\n    : Equal\n    | Unequal\n    ;\n\nEqual : '==' ;\nUnequal : '!=' ;\n\nrelationalOp\n    : Less\n    | Greater\n    | LessEqual\n    | GreaterEqual\n    ;\n\nLess : '<' ;\nGreater : '>' ;\nLessEqual : '<=' ;\nGreaterEqual : '>=' ;\n\nbitwiseShiftOp\n    : ShiftLeft\n    | ShiftRight\n    ;\n\nShiftLeft : '<<' ;\nShiftRight : '>>' ;\n\nadditiveOp\n    : Plus\n    | Minus\n    ;\n\nPlus : '+' ;\nMinus : '-' ;\n\nmultiplicativeOp\n    : Mul\n    | Div\n    | Mod\n    ;\n\nMul : '*' ;\nDiv : '/' ;\nMod : '%' ;\n\nAuth : 'auth' ;\nAmpersand : '&';\n\nunaryOp\n    : Minus\n    | Negate\n    | Move\n    ;\n\nNegate : '!' ;\nMove : '<-' ;\nMoveForced : '<-!' ;\n\nOptional : '?' ;\n\nNilCoalescing : WS '??';\n\nCasting : 'as' ;\nFailableCasting : 'as?' ;\nForceCasting : 'as!' ;\n\nResourceAnnotation : '@' ;\n\ncastingOp\n    : Casting\n    | FailableCasting\n    | ForceCasting\n    ;\n\ncreateExpression\n    : Create nominalType invocation\n    ;\n\ndestroyExpression\n    : Destroy expression\n    ;\n\nreferenceExpression\n    : Ampersand expression Casting fullType\n    ;\n\nexpressionAccess\n    : memberAccess\n    | (* if no line terminator ahead *) bracketExpression\n    ;\n\nmemberAccess\n    : Optional? '.' identifier\n    ;\n\nbracketExpression\n    : '[' expression']'\n    ;\n\ninvocation\n    : ( '<' ( typeAnnotation ( ',' typeAnnotation )* )? '>' )?\n      '(' ( argument ( ',' argument )* )? ')'\n    ;\n\nargument\n    : ( identifier ':' )? expression\n    ;\n\nliteral\n    : fixedPointLiteral\n    | integerLiteral\n    | booleanLiteral\n    | arrayLiteral\n    | dictionaryLiteral\n    | stringLiteral\n    | nilLiteral\n    | pathLiteral\n    ;\n\nbooleanLiteral\n    : True\n    | False\n    ;\n\nnilLiteral\n    : Nil\n    ;\n\npathLiteral\n    : '/' (* no whitespace *) domain=identifier (* no whitespace *)\n      '/' (* no whitespace *) id=identifier\n    ;\n\nstringLiteral\n    : StringLiteral\n    ;\n\nfixedPointLiteral\n    : Minus? PositiveFixedPointLiteral\n    ;\n\nintegerLiteral\n    : Minus? positiveIntegerLiteral\n    ;\n\npositiveIntegerLiteral\n    : DecimalLiteral\n    | BinaryLiteral\n    | OctalLiteral\n    | HexadecimalLiteral\n    | InvalidNumberLiteral\n    ;\n\narrayLiteral\n    : '[' ( expression ( ',' expression )* )? ']'\n    ;\n\ndictionaryLiteral\n    : '{' ( dictionaryEntry ( ',' dictionaryEntry )* )? '}'\n    ;\n\ndictionaryEntry\n    : key=expression ':' value=expression\n    ;\n\nOpenParen: '(' ;\nCloseParen: ')' ;\n\nTransaction : 'transaction' ;\n\nStruct : 'struct' ;\nResource : 'resource' ;\nContract : 'contract' ;\n\nInterface : 'interface' ;\n\nFun : 'fun' ;\n\nEvent : 'event' ;\nEmit : 'emit' ;\n\nPre : 'pre' ;\nPost : 'post' ;\n\nPriv : 'priv' ;\nPub : 'pub' ;\nSet : 'set' ;\n\nAccess : 'access' ;\nAll : 'all' ;\nSelf : 'self' ;\nAccount : 'account' ;\n\nReturn : 'return' ;\n\nBreak : 'break' ;\nContinue : 'continue' ;\n\nLet : 'let' ;\nVar : 'var' ;\n\nIf : 'if' ;\nElse : 'else' ;\n\nWhile : 'while' ;\n\nFor : 'for' ;\nIn : 'in' ;\n\nTrue : 'true' ;\nFalse : 'false' ;\n\nNil : 'nil' ;\n\nImport : 'import' ;\nFrom : 'from' ;\n\nCreate : 'create' ;\nDestroy : 'destroy' ;\n\nidentifier\n    : Identifier\n    | From\n    | Create\n    | Destroy\n    | Emit\n    | Contract\n    | Resource\n    | Struct\n    | Event\n    | All\n    | Access\n    | Account\n    | Self\n    | Auth\n    | In\n    | Set\n    ;\n\nIdentifier\n    : IdentifierHead IdentifierCharacter*\n    ;\n\nIdentifierHead\n    : [a-zA-Z]\n    |  '_'\n    ;\n\nIdentifierCharacter\n    : [0-9]\n    | IdentifierHead\n    ;\n\nPositiveFixedPointLiteral\n    : [0-9] ( [0-9_]* [0-9] )? '.' [0-9] ( [0-9_]* [0-9] )?\n    ;\n\nDecimalLiteral\n    (*\n      NOTE: allows trailing underscores, but the parser checks underscores\n      only occur inside, to provide better syntax errors\n    *)\n    : [0-9] [0-9_]*\n    ;\n\n\nBinaryLiteral\n    (*\n      NOTE: allows underscores anywhere after prefix, but the parser checks underscores\n      only occur inside, to provide better syntax errors\n    *)\n    : '0b' [01_]+\n    ;\n\n\nOctalLiteral\n    (*\n      NOTE: allows underscores anywhere after prefix, but the parser checks underscores\n      only occur inside, to provide better syntax errors\n    *)\n    : '0o' [0-7_]+\n    ;\n\nHexadecimalLiteral\n    (*\n      NOTE: allows underscores anywhere after prefix, but the parser checks underscores\n      only occur inside, to provide better syntax errors\n    *)\n    : '0x' [0-9a-fA-F_]+\n    ;\n\n(*\n   NOTE: invalid literal, to provide better syntax errors\n*)\nInvalidNumberLiteral\n    : '0' [a-zA-Z] [0-9a-zA-Z_]*\n    ;\n\nStringLiteral\n    : '\"' QuotedText* '\"'\n    ;\n\nQuotedText\n    : EscapedCharacter\n    | ~[\"\\n\\r\\\\]\n    ;\n\nEscapedCharacter\n    : '\\\\' [0\\\\tnr\"']\n    (* NOTE: allow arbitrary length in parser, but check length in semantic analysis *)\n    | '\\\\u' '{' HexadecimalDigit+ '}'\n    ;\n\nHexadecimalDigit : [0-9a-fA-F] ;\n\nWS\n    : [ \\t\\u000B\\u000C\\u0000]+\n    ;\n\nTerminator\n    : [\\r\\n\\u2028\\u2029]+\n    ;\n\nBlockComment\n    : '/*' ( BlockComment | . )* '*/' (* nesting comments is allowed *)\n    ;\n\nLineComment\n    : '//' ~[\\r\\n]*\n    ;\n\neos\n    : ';'\n    | EOF\n    | (* line terminator ahead *)\n    | (* next token is '}' *)\n    ;\n","path":"/cadence-ebnf"},{"content":"# Development\n\n## Running the latest version of the Language Server in the Visual Studio Code Extension\n\n- Ensure that a `replace` statement exists in `languageserver/go.mod`, so that the language server compiles with the local changes to Cadence.\n\n- Find the Visual Studio Code preference named \"Cadence: Flow Command\" and change it to:\n\n  ```text\n  /path/to/cadence/languageserver/run.sh\n  ```\n\n- Restart Visual Studio Code\n\nThis will automatically recompile the language server every time it is started.\n\n## Tools\n\nThe [`runtime/cmd` directory](https://github.com/onflow/cadence/tree/master/runtime/cmd)\ncontains command-line tools that are useful when working on the implementation for Cadence, or with Cadence code:\n\n- The [`parse`](https://github.com/onflow/cadence/tree/master/runtime/cmd/parse) tool\n  can be used to parse (syntactically analyze) Cadence code.\n  By default, it reports syntactical errors in the given Cadence program, if any, in a human-readable format.\n  By providing the `-json` it returns the AST of the program in JSON format if the given program is syntactically valid,\n  or syntactical errors in JSON format (including position information).\n\n  ```\n  $ echo \"X\" |  go run ./runtime/cmd/parse\n  error: unexpected token: identifier\n   --> :1:0\n    |\n  1 | X\n    | ^\n  ```\n\n  ```\n  $ echo \"let x = 1\" |  go run ./runtime/cmd/parse -json\n  [\n    {\n      \"program\": {\n        \"Type\": \"Program\",\n        \"Declarations\": [\n          {\n            \"Type\": \"VariableDeclaration\",\n            \"StartPos\": {\n              \"Offset\": 0,\n              \"Line\": 1,\n              \"Column\": 0\n            },\n            \"EndPos\": {\n              \"Offset\": 8,\n              \"Line\": 1,\n              \"Column\": 8\n            },\n            [...]\n  ```\n\n- The [`check`](https://github.com/onflow/cadence/tree/master/runtime/cmd/check) tool\n  can be used to check (semantically analyze) Cadence code.\n  By default, it reports semantic errors in the given Cadence program, if any, in a human-readable format.\n  By providing the `-json` it returns the AST in JSON format, or semantic errors in JSON format (including position information).\n\n  ```\n  $ echo \"let x = 1\" |  go run ./runtime/cmd/check                                                                                                                                                                                        1 ↵\n  error: error: missing access modifier for constant\n   --> :1:0\n    |\n  1 | let x = 1\n    | ^\n  ```\n\n- The [`main`](https://github.com/onflow/cadence/tree/master/runtime/cmd/check) tools\n  can be used to execute Cadence programs.\n  If a no argument is provided, the REPL (Read-Eval-Print-Loop) is started.\n  If an argument is provided, the Cadence program at the given path is executed.\n  The program must have a function named `main` which has no parameters and no return type.\n\n  ```\n   $ go run ./runtime/cmd/main                                                                                                                                                                                                           130 ↵\n   Welcome to Cadence v0.12.3!\n   Type '.help' for assistance.\n\n   1> let x = 2\n   2> x + 3\n   5\n   ```\n\n   ```\n   $ echo 'pub fun main () { log(\"Hello, world!\") }' > hello.cdc\n   $ go run ./runtime/cmd/main hello.cdc\n   \"Hello, world!\"\n   ```\n\n## How is it possible to detect non-determinism and data races in the checker?\n\nRun the checker tests with the `cadence.checkConcurrently` flag, e.g.\n\n```shell\ngo test -race -v ./runtime/tests/checker -cadence.checkConcurrently=10\n```\n\nThis runs each check of a checker test 10 times, concurrently,\nand asserts that the checker errors of all checks are equal.\n\n","path":"/development"},{"path":"/language"},{"content":"\n## Resources\n\n- Supertype: **Restricted Resource**:\n\n  - **Not** `AnyResource`:\n\n    - A restricted resource type `T{Us}`\n      is a subtype of a restricted resource type `V{Ws}`:\n\n      - When `T != AnyResource`: if `T == V`.\n\n        `Us` and `Ws` do *not* have to be subsets:\n        The owner of the resource may freely restrict and unrestrict the resource.\n\n        - Static: Yes\n        - Dynamic: Yes\n\n      - When `T == AnyResource`: if the run-time type is `V`.\n\n        - Static: No\n        - Dynamic: Yes\n\n    - An unrestricted resource type `T`\n      is a subtype of a restricted resource type `U{Vs}`:\n\n      - When `T != AnyResource`: if `T == U`.\n\n        The owner of the resource may freely restrict the resource.\n\n        - Static: Yes\n        - Dynamic: Yes\n\n      - When `T == AnyResource`: if the run-time type is `U`.\n\n        - Static: No\n        - Dynamic: Yes\n\n  - `AnyResource`:\n\n    - A restricted resource type `T{Us}`\n      is a subtype of a restricted resource type `AnyResource{Vs}`:\n\n      - When `T != AnyResource`: if `T` conforms to `Vs`.\n\n        `Us` and `Vs` do *not* have to be subsets.\n\n        - Static: Yes\n        - Dynamic: Yes\n\n      - When `T == AnyResource`:\n\n        - Static: if `Vs` is a subset of `Us`\n        - Dynamic: if the run-time type conforms to `Vs`\n\n    - An unrestricted resource type `T`\n      is a subtype of a restricted resource type `AnyResource{Us}`:\n\n      - When `T != AnyResource`: if `T` conforms to `Us`.\n\n        - Static: Yes\n        - Dynamic: Yes\n\n      - When `T == AnyResource`: if the run-time type conforms to `Us`.\n\n        - Static: No\n        - Dynamic: Yes\n\n- Supertype: **Unrestricted Resource**:\n\n  - **Not** `AnyResource`:\n\n    - A restricted resource type `T{Us}`\n      is a subtype of an unrestricted resource type `V`:\n\n      - When `T != AnyResource`: if `T == V`.\n\n        The owner of the resource may freely unrestrict the resource.\n\n        - Static: Yes\n        - Dynamic: Yes\n\n      - When `T == AnyResource`: if the run-time type is `V`.\n\n        - Static: No\n        - Dynamic: Yes\n\n    - An unrestricted resource type `T`\n      is a subtype of an unrestricted resource type `V`: if `T == V`.\n\n      - Static: Yes\n      - Dynamic: Yes\n\n  - `AnyResource`\n\n    - A restricted resource type `T{Us}` or unrestricted resource type `T`\n      is a subtype of the type `AnyResource`: always.\n\n      - Static: Yes\n      - Dynamic: Yes\n\n## References\n\n- **Authorized**\n\n  An authorized reference type `auth &T` is a subtype of an unauthorized reference type `&U`\n  or an authorized reference type `auth &U` if `T` is a subtype of `U`.\n\n  - Static: Yes\n  - Dynamic: Yes\n\n- **Unauthorized**\n\n  - An unauthorized reference type `&T` is a subtype of an authorized reference type `auth &T`: never.\n\n    The holder of the reference may not gain more permissions.\n\n    - Static: No\n    - Dynamic: No\n\n  - Supertype: **Reference to Restricted Resource**\n\n    - **Not** `AnyResource`:\n\n      - An unauthorized reference to a restricted resource type `&T{Us}`\n        is a subtype of a reference to a restricted resource type `&V{Ws}`:\n\n        - When `T != AnyResource`: if `T == V` and `Ws` is a subset of `Us`.\n\n          The holder of the reference may not gain more permissions or knowledge\n          and may only further restrict the reference to the resource.\n\n          - Static: Yes\n          - Dynamic: Yes\n\n        - When `T == AnyResource`: never.\n\n          The holder of the reference may not gain more permissions or knowledge.\n\n          - Static: No\n          - Dynamic: No\n\n      - An unauthorized reference to an unrestricted resource type `&T`\n        is a subtype of a reference to a restricted resource type `&U{Vs}`:\n\n        - When `T != AnyResource`: if `T == U`.\n\n          The holder of the reference may only further restrict the reference.\n\n          - Static: Yes\n          - Dynamic: Yes\n\n        - When `T == AnyResource`: never.\n\n          The holder of the reference may not gain more permissions or knowledge.\n\n          - Static: No\n          - Dynamic: No\n\n    - `AnyResource`:\n\n      - An unauthorized reference to a restricted resource type `&T{Us}`\n        is a subtype of a reference to a restricted resource type `&AnyResource{Vs}`: if `Vs` is a subset of `Us`.\n\n        The holder of the reference may only further restrict the reference.\n\n        The requirement for `T` to conform to `Vs` is implied by the subset requirement.\n\n        - Static: Yes\n        - Dynamic: Yes\n\n      - An unauthorized reference to an unrestricted resource type `&T`\n        is a subtype of a reference to a restricted resource type `&AnyResource{Us}`:\n\n        - When `T != AnyResource`: if `T` conforms to `Us`.\n\n          The holder of the reference may only restrict the reference.\n\n          - Static: Yes\n          - Dynamic: Yes\n\n        - When `T == AnyResource`: never.\n\n          The holder of the reference may not gain more permissions or knowledge.\n\n          - Static: No\n          - Dynamic: No\n\n  - Supertype: **Unrestricted Resource**:\n\n    - **Not** `AnyResource`:\n\n      - An unauthorized reference to a restricted resource type `&T{Us}`\n        is a subtype of a reference to an unrestricted resource type `&V`: never.\n\n        The holder of the reference may not gain more permissions or knowledge.\n\n        - Static: No\n        - Dynamic: No\n\n      - An unauthorized reference to an unrestricted resource type `&T`\n        is a subtype of a reference to an unrestricted resource type `&V`: if `T == V`.\n\n        - Static: Yes\n        - Dynamic: Yes\n\n    - `AnyResource`\n\n      - An unauthorized reference to a restricted resource type `&T{Us}` or\n        to a unrestricted resource type `&T`\n        is a subtype of the type `&AnyResource`: always.\n\n        - Static: Yes\n        - Dynamic: Yes\n\n","path":"/subtyping"},{"content":"# Syntax Highlighting Cadence\n\nThere are currently several options to highlight Cadence code.\nCurrently those options are integrated into the projects they are used in, but they could be extracted and made generally useable (please let us know e.g. by creating a feature request issue).\n\n## HTML output\n\nIf highlighted Cadence code is needed as HTML output, then a highlighter based on a [TextMate grammar for Cadence](https://github.com/onflow/flow/blob/2b5d5316784c31240a310252783ce2c63549787b/docs/plugins/gatsby-theme-flow/cadence.tmGrammar.json) can be used.\n\nThis option is currently used by the Flow documentation: Code fences with Cadence code in the Markdown documents are converted to HTML using a [plugin](https://github.com/onflow/flow/tree/2b5d5316784c31240a310252783ce2c63549787b/docs/plugins/gatsby-remark-vscode-flow).\nPart of the plugin is a [highlighter class](https://github.com/onflow/flow/blob/2b5d5316784c31240a310252783ce2c63549787b/docs/plugins/gatsby-remark-vscode-flow/highlighter.js) which was written to be fairly self-standing, takes Cadence code as input, and returns [hast](https://github.com/syntax-tree/hast), which is then [further converted to HTML using the `hast-util-to-html` package](https://github.com/onflow/flow/blob/2b5d5316784c31240a310252783ce2c63549787b/docs/plugins/gatsby-remark-vscode-flow/index.js#L59-L77).\n\n## Editor\n\nCadence code can also be highlighted in an editor like [Monaco](https://microsoft.github.io/monaco-editor/) (which is the editor library used in Visual Studio Code), potentially in a read-only mode.\n\nThis option is currently used in the [Flow Playground](https://play.onflow.org/).\n\nThe Monaco editor does not support TextMate grammars and has its [own grammar format Monarch](https://microsoft.github.io/monaco-editor/monarch.html), so a [separate Monarch grammar for Cadence](https://github.com/onflow/flow-playground/blob/79657ebaf8682695c89c028c3bed91c780633666/src/util/cadence.ts#L15-L194) exists.\n","path":"/syntax-highlighting"}]}